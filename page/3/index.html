
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>中继点</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="中继点">
    

    
    <meta name="description" content="大数据，R，研发管理，移动互联，Lean Startup">
<meta property="og:type" content="website">
<meta property="og:title" content="中继点">
<meta property="og:url" content="http://www.zjdian.com/page/3/index.html">
<meta property="og:site_name" content="中继点">
<meta property="og:description" content="大数据，R，研发管理，移动互联，Lean Startup">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="中继点">
<meta name="twitter:description" content="大数据，R，研发管理，移动互联，Lean Startup">

    
    <link rel="alternative" href="/atom.xml" title="中继点" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="中继点" title="中继点"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="中继点">中继点</a></h1>
				<h2 class="blog-motto">大数据，R，研发管理，移动互联，Lean Startup</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜單">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:www.zjdian.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/08/22/2014-8-22-exploring-data-1/" title="机器学习与R(6)-数据探索-1" itemprop="url">机器学习与R(6)-数据探索-1</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="中继点" target="_blank" itemprop="author">中继点</a>
		
  <p class="article-time">
    <time datetime="2014-08-22T11:30:56.000Z" itemprop="datePublished"> 發表於 2014 Aug 22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>探索数据是对数据进行初步研究,以便更好的理解数据，帮助选择合适的数据预处理和数据分析技术。通过数据探索我们将识别原始数据中的问题，缺失值，异常，分布等等。通常我们会考察：</p>
<ul>
<li>频数，均值，方差，偏度…</li>
<li>对数据可视化，以快速找到数据的特征</li>
</ul>
<h2 id="u6570_u636E_u8BFB_u5165"><a href="#u6570_u636E_u8BFB_u5165" class="headerlink" title="数据读入"></a>数据读入</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">contribution=read.csv(<span class="string">"contribution.csv"</span>,stringsAsFactors=<span class="literal">F</span>)</span><br><span class="line">str(contribution)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## &#39;data.frame&#39;:&#9;1230 obs. of  11 variables:&#10;##  $ Gender         : chr  &#34;M&#34; &#34;M&#34; &#34;F&#34; &#34;M&#34; ...&#10;##  $ Class.Year     : int  1957 1957 1957 1957 1957 1957 1957 1957 1957 1957 ...&#10;##  $ Marital.Status : chr  &#34;M&#34; &#34;M&#34; &#34;M&#34; &#34;M&#34; ...&#10;##  $ Major          : chr  &#34;History&#34; &#34;Physics&#34; &#34;Music&#34; &#34;History&#34; ...&#10;##  $ Next.Degree    : chr  &#34;LLB&#34; &#34;MS&#34; &#34;NONE&#34; &#34;NONE&#34; ...&#10;##  $ FY04Giving     : num  2500 5000 5000 0 1000 0 0 100 100 0 ...&#10;##  $ FY03Giving     : num  2500 5000 5000 5100 1000 0 0 100 100 0 ...&#10;##  $ FY02Giving     : num  1400 5000 5000 200 1000 0 0 100 100 0 ...&#10;##  $ FY01Giving     : num  12060 5000 5000 200 1005 ...&#10;##  $ FY00Giving     : num  12000 10000 10000 0 1000 0 0 100 100 0 ...&#10;##  $ AttendenceEvent: int  1 1 1 1 1 0 0 0 0 1 ...</span><br></pre></td></tr></table></figure>
<p>1230条观察记录，11个变量，其中的文本变量都是<code>char</code>类型，没有转换成factor，这里可以根据需求来转换。</p>
<h1 id="u6570_u5B57_u53D8_u91CF_u63A2_u7D22"><a href="#u6570_u5B57_u53D8_u91CF_u63A2_u7D22" class="headerlink" title="数字变量探索"></a>数字变量探索</h1><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">summary(contribution$FY00Giving)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. &#10;##       0       0       0     169      60   21000</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">summary(contribution$FY01Giving)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. &#10;##       0       0       0     277      75  161000</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">summary(contribution[c(<span class="string">"FY00Giving"</span>,<span class="string">"FY01Giving"</span>)])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##    FY00Giving      FY01Giving    &#10;##  Min.   :    0   Min.   :     0  &#10;##  1st Qu.:    0   1st Qu.:     0  &#10;##  Median :    0   Median :     0  &#10;##  Mean   :  169   Mean   :   277  &#10;##  3rd Qu.:   60   3rd Qu.:    75  &#10;##  Max.   :21000   Max.   :161370</span><br></pre></td></tr></table></figure>
<p><code>summary</code>列出了最小，最大，第1，3个四分位值以及mean，median。通过这些数据我们大致对数据的分布区间有了了解。而其它的来自<code>Hmisc</code>包的<code>describe</code>提供了更详细的数据描述。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">describe(contribution$FY01Giving)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Error: could not find function &#34;describe&#34;</span><br></pre></td></tr></table></figure>
<h2 id="u6570_u636E_u7684_u4E2D_u5FC3_u8D8B_u52BF"><a href="#u6570_u636E_u7684_u4E2D_u5FC3_u8D8B_u52BF" class="headerlink" title="数据的中心趋势"></a>数据的中心趋势</h2><p>对于一组数据的描述，我们常用均值来进行描述，而均值有<code>mean</code>和<code>median</code>两种，其中<code>mean</code>很容易受到异常值的影响(outlier)</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=c(<span class="number">10</span>:<span class="number">20</span>,<span class="number">80</span>,<span class="number">100</span>,<span class="number">120</span>)</span><br><span class="line">mean(x)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 33.21</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">median(x)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 16.5</span><br></pre></td></tr></table></figure>
<p>显然在这是用<code>median</code>是更好描述方法，通过<code>summary</code>，我们可以同时获得<code>mean,median</code>，通过比较二者，我们也可以知道数据的分布情况。比如这里<code>mean</code>远大于<code>median</code>，虽然数据中大部分点位于10到20，但是少数几个较大的outlier使得mean为33.2，而此时median则为16.5</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">range(contribution$FY00Giving)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1]     0 21000</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff(range(contribution$FY00Giving))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 21000</span><br></pre></td></tr></table></figure>
<p>利用<code>range</code>与<code>diff</code>我们可以获得数据的分布区间，而</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IQR(contribution$FY00Giving)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 60</span><br></pre></td></tr></table></figure>
<p>则直接给出中间50%的数据的区间即Q1与Q3间的差。直接使用</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quantile(contribution$FY00Giving)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##    0%   25%   50%   75%  100% &#10;##     0     0     0    60 21000</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quantile(contribution$FY00Giving,prob=c(<span class="number">0.75</span>,<span class="number">0.85</span>,<span class="number">0.95</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## 75% 85% 95% &#10;##  60 154 350</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#试试这个</span></span><br><span class="line"><span class="comment">#quantile(contribution$FY00Giving,prob=seq(from=0,to=1,by=0.1))</span></span><br></pre></td></tr></table></figure>
<p>可以给出更详细的值，比如我们可以由此知道85%的人的捐款都少于154$。通过这些数据你应该可以理解前面的<code>summary(contribution$FY00Giving)</code>为什么<code>median</code>为0了，数据分布的非正态。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/数据科学/">数据科学</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/R/">R</a><a href="/tags/数据科学/">数据科学</a><a href="/tags/机器学习/">机器学习</a><a href="/tags/机器学习与R/">机器学习与R</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/08/22/2014-8-22-exploring-data-1/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/08/22/2014-8-22-exploring-data-1/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/08/17/2014-8-data-science-chp7-sample/" title="数据科学(7)-第七章：罐子中的样本" itemprop="url">数据科学(7)-第七章：罐子中的样本</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="中继点" target="_blank" itemprop="author">中继点</a>
		
  <p class="article-time">
    <time datetime="2014-08-17T03:13:03.000Z" itemprop="datePublished"> 發表於 2014 Aug 17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本文为<strong>Introduction to Data Science</strong>一书的翻译，由网友义务完成，了解参加翻译的网友，请点击<a href="https://github.com/johnstart/data-science/blob/gh-pages/task.md" target="_blank" rel="external">这里</a>，如果要加入我们请加入qq群171546473,了解翻译规则点击<a href="https://github.com/johnstart/data-science/blob/gh-pages/index.md" target="_blank" rel="external">这里</a></p>
<h1 id="u7B2C_u4E03_u7AE0_uFF1A_u7F50_u5B50_u4E2D_u7684_u6837_u672C"><a href="#u7B2C_u4E03_u7AE0_uFF1A_u7F50_u5B50_u4E2D_u7684_u6837_u672C" class="headerlink" title="第七章：罐子中的样本"></a>第七章：罐子中的样本</h1><hr>
<p><center><br><img src="/img/datascience/jar.jpg" alt="header"></center></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>抽样分布是理解统计推断的关键概念。为了理解随机性在抽样时所产生的影响，很多讲解抽样分布的方法都提到了从罐子中抽取弹球或糖果这样的经典例子。通过前面提到的美国人口的例子，我们可以清楚的看到尽管总体的分布不是正态的，但其样本均值的分布却服从正态分布。</p>
<p>想象你拥有一个装满了红色和蓝色糖果的罐子。罐子中放入的红色糖果和蓝色糖果各有100颗，但这些糖果在放入罐中时是混合在一起的。如果你从罐中随机抽取8颗糖果，你会得到什么颜色的糖果？如果抽取如想象中般顺利的话（虽然通常都没那么走运），你将会抽到4颗红糖果和4颗蓝糖果。红的和蓝的各占一半，这个比例和罐中的红蓝比例是一样的。当然了，你很难抽到这个结果，是不？除了4红4蓝的组合，你也可能会抽到3颗红糖果和5颗蓝糖果，或者其他各种你能想到的组合。事实上，尽管概率很小，但你还是有可能抽中8颗红色的。虽然有多种可能，但仅就一次抽取结果来看，我们是无法预测会抽到红和蓝的哪种组合的。而这种不确定性，就是能够以无法预知的方式来影响你抽取结果的随机性的力量。</p>
<p>我们现在提出一个有趣的想法，这虽然对预测单次抽取结果没什么帮助，但却能很好的展示多次抽取的<em>长期趋势</em>。从罐子中抽取8颗糖果，数一数其中有多少红色的，然后将所有的糖果都放回罐中。我们并不需要数蓝色糖果的数量，这是因为 <code>8 - 红色糖果的数量 = 蓝色糖果的数量</code>。将罐中的糖果晃动一下，这样能混合的更好一些，然后再抽取8颗糖果，同时数一下红色糖果的数量。将这种操作重复多次，我们可以对每次记录的结果用下面的表格来表示：</p>
<table>
<thead>
<tr>
<th style="text-align:right">抽取次数</th>
<th style="text-align:right">红色糖果的数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">1</td>
<td style="text-align:right">5</td>
</tr>
<tr>
<td style="text-align:right">2</td>
<td style="text-align:right">3</td>
</tr>
<tr>
<td style="text-align:right">3</td>
<td style="text-align:right">6</td>
</tr>
<tr>
<td style="text-align:right">4</td>
<td style="text-align:right">2</td>
</tr>
</tbody>
</table>
<p>注意到表格左边的列就是对抽取次数的计数而已。表格右边的列是我们感兴趣的内容，它列出了每次抽样中的红色糖果数量。在本例中，红色糖果的数量真是天南海北。在第4次抽样时，我们只抽到了两颗红色糖果，但是在第3次抽样时，我们却抽到了足足6颗红色糖果。但是本例最有趣的地方就是，如果你将这4次抽取的红色糖果数量进行<em>算术平均</em>，你会得到平均每次抽到<em>正好4颗红色糖果</em>的结果，而这正是我们期望的红蓝各半的罐子中应该抽出的结果。以上只是一个人为制造的例子，而我们在平时抽取时，很难在仅仅4次抽取之后就遇到这么好的平均的结果。但是如果你将随机抽取这一操作，进行了4000次，你将会肯定得到一个接近 <strong>平均每次抽到4颗红色糖果</strong> 的完美结果。</p>
<p>从总体中不断的抽取子集的过程称为“抽样”，而经过大量的抽样之后，我们会最终得到抽样分布。注意到，在刚才这句话中，我们用到了“总体”这个词汇，用来代表我们从什么地方做的抽样，这也是它的统计含义。在前面章节的例子中，我们的数据集包含美国各个州的人口数量，这个“人口”与“总体”同样使用英文单次 population 可以说是一个巧合。下面，我们使用 R 来帮助我们从美国各州人口数据集中抽取大量样本。</p>
<p>R 中有一个很便捷的函数 sample()，可以用来从数据集中简便的抽取样本。我们可以用它来从我们的数据集中抽取样本：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set.seed(<span class="number">31415</span>)</span><br><span class="line">sample(USstatePops$V1, size = <span class="number">16</span>, replace = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##  [1]  1852994  4339367  3574097  2967297  2915918  4533372  1360301&#10;##  [8]  5773552  6724540  6346105  3574097  3751351  1052567 37253956&#10;## [15]   814180  3046355</span><br></pre></td></tr></table></figure>
<p>(译者注：原著中并未使用set.seed()来设置随机的种子，这会导致读者的可重复性研究非常困难。在本章中我们统一将种子设置为31415。读者也如此设置，便可实现和我们相同的抽样结果。)在本例中，注意到我们调用的sample()函数含有三个参数。第一个参数是数据源。对于第二个和第三个参数，为了让 R 能够正确识别，我们采用了“命名参数”的方式来调用，而不是单靠这些参数在参数列中的位置。参数 <code>size = 16</code> 可以让 R 从总体中抽取16个州的人口作为样本。参数 <code>replace = TRUE</code> 则规定了一种统计学家经常用来简化数学证明的抽样方法。对我们来说，采取放回抽样还是不放回抽样通常没有实际的影响，所以我们直接使用统计学家的常用方法。</p>
<p>相较于给抽取的各色糖果计数，我们在处理类似于各州人口的这类数值时，对其算数平均数，或者称为均值，更感兴趣。于是我们可以让 R 使用mean()来计算所抽取的样本均值：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set.seed(<span class="number">31415</span>)</span><br><span class="line">mean(sample(USstatePops$V1, size = <span class="number">16</span>, replace = <span class="literal">TRUE</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 5617503</span><br></pre></td></tr></table></figure>
<p>从上面的mean()函数可以看出，我们又遇到了函数的嵌套调用了。我们在mean()函数的输出中并未看到从51个州中随机抽取的16个州人口数值，而是看到了mean()函数直接用这16个数来为我们计算出来的均值。如果你的记忆力很好，或者往前面的章节翻一下，你会看到51个数值的均值是 6053834. 于是你会发现我们从这16个州<br>的样本获得的均值真的是离总体的均值相差的有点远。我们是不是应该感到焦虑？当然不是！我们知道，当抽取样本时，无论是抽取糖果，还是抽取各个州，我们的样本均值永远都不会和总体均值正好一样。其实我们并非对某一次抽样的结果感兴趣，而是要专注于长期抽样的结果。于是，我们现在要让 R 来帮我们做重复抽样了，不是抽取1次、4次，而是400次甚至4000次。和其他的编程语言一样，R 有很多方法可以重复某个操作。其中最简单的一个方法非replicate()函数莫属。让我们先尝试一下重复4次：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set.seed(<span class="number">31415</span>)</span><br><span class="line">replicate(<span class="number">4</span>, mean(sample(USstatePops$V1, size = <span class="number">16</span>, replace = <span class="literal">TRUE</span>)), simplify = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 5617503 3945129 6510150 4407374</span><br></pre></td></tr></table></figure>
<p>简单的不可思议吧！我们仍然使用了刚才用过的命令，即用来计算16个州的均值的mean()函数。只不过这一次，我们将mean()函数作为一个参数放到replicate()函数里面，于是我们才可以一次又一次的求均值。其中的 <code>simplify = TRUE</code> 参数是让 R 将函数运行的结果以一个均值构成的向量形式返回，而这正是我们想要的形式。由于我们只将mean()函数运行了4次，所以我们不会看到满屏的数字。从刚才的尝试来看，我们可以很轻易地将求均值的过程重复400次。你可以自己试一下，看看结果。至于在本书中，我们要将replicate()函数整个塞进另一个mean()函数，于是我们可以得到400个样本均值的平均数。我们来看一下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set.seed(<span class="number">31415</span>)</span><br><span class="line">mean(replicate(<span class="number">400</span>, mean(sample(USstatePops$V1, size = <span class="number">16</span>, replace = <span class="literal">TRUE</span>)), </span><br><span class="line">    simplify = <span class="literal">TRUE</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 5983180</span><br></pre></td></tr></table></figure>
<p>在上述命令中，最外层的mean()函数地位与之前命令的不同。将这个多层嵌套的命令的效果，用语言来描述一下就是：a)从51个州的总体中抽取400个样本容量为16的样本; b)对每一个样本计算其样本均值，并将均值保存到一个列表中; c)当计算完这400个均值后，计算包含有400个均值的列表的均值。从刚才的计算结果可以看到400个样本的均值是5983180. 虽然这个值和总体均值仍然不相等，但是已经接近了。我们距离总体均值的真值大概70000多，大概是1.16%(更精确的数值为70654/6053834 = 1.167%)。你可能也注意到了，即使你有一个速度较快的电脑，运行刚才的命令也得花一些时间。因为刚才的命令的确包含了很多操作！让我们更进一步，看看我们是否能更加接近总体均值：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set.seed(<span class="number">31415</span>)</span><br><span class="line">mean(replicate(<span class="number">4000</span>, mean(sample(USstatePops$V1, size = <span class="number">16</span>, replace = <span class="literal">TRUE</span>)), </span><br><span class="line">    simplify = <span class="literal">TRUE</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 6052941</span><br></pre></td></tr></table></figure>
<p>现在我们更加接近真值了！我们得到的均值距离总体均值的真值只差不到千分之一！你可能注意到你在运行上述几个命令时得到的结果与我们有少许不同，这是因为你在运行sample()函数时，随机抽取的400或4000个样本与上述命令得到的不同，但是最终均值结论的精确性却相差不多。(译者注：这是由于原著中没有使用set.seed()来明确生成的随机序列，读者如果按照译文中的命令来执行，是会得到与我们完全相同的结论的。我们也建议读者在任何涉及到随机抽样的模拟中，添加set.seed()，以便将来的可重复性研究。)</p>
<p>我们准备进行下一步了。这次我们不用一个简单的算术平均来概括抽样分布的均值了，我们使用更复杂的直方图来观察抽样分布的均值序列。</p>
<p>这个直方图展示了4000个均值的频数分布。对这张图详细观察可以训练你阅读频数直方图的能力。这个直方图具有典型的近乎于钟形的但仍然有点右偏的形状。最高的，也就是频数最大的区间正好和均值真值6053834不远。</p>
<p>另外，你能否自己找出生成这张直方图的命令？你只需要将前面的命令之中的最外层mean()函数替换为hist()函数即可。在本例中，代码如下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set.seed(<span class="number">31415</span>)</span><br><span class="line">hist(replicate(<span class="number">4000</span>, mean(sample(USstatePops$V1, size = <span class="number">16</span>, replace = <span class="literal">TRUE</span>)), </span><br><span class="line">    simplify = <span class="literal">TRUE</span>), main = <span class="string">"Frequency of 4000 sample mean"</span>, xlab = <span class="string">"Sample Mean"</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/datascience/unnamed-chunk-7.png" alt="plot of chunk unnamed-chunk-7"> </p>
<p>这是一个伟大的时刻，请让我们做一下深呼吸。我们刚刚仅用短短几页就概括了统计思想在数百年间的成果。事实上，我们提到的有两个重要思想，“大数定律”和“中心极限定理”。这两个重要理论的确花费了像Gerolamo Cardano(1501-1576)和Jacob Bernoulli(1645-1705)这些数学家们数个世纪才最终得到。如果你去查阅这些理论，你会发现有很多令人迷惑的数学论证细节，但对我们来说，在这之中是两个浅显的道理。首先，如果你运行了同一个统计过程很多次数，则最后通常会收敛到一个稳定的结果。对本例来说，我们知道50个州加上哥伦比亚特区（即华盛顿首府）的平均人口是多少。这51个观测值就是我们的总体，此时我们想知道要像得到这个均值真值的较好的近似，我们需要抽取多少个容量为16的样本。我们了解到只抽取一个样本会得到较差的结果。抽取400个样本能够得到距离真值只差1.16%的较小的误差。而抽取4000个样本得到的均值距离真值的差距都不超过千分之一。如果我们将抽样过程重复40000次乃至400000次，我们会得到和真值6053384极端接近的所有样本的均值。</p>
<p>其次，当我们将大数定律纳入考虑，并将其运用到样本均值时，我们发现样本均值形成的分布开始向钟形或正态分布靠拢，所有样本均值的均值也和总体均值真值越来越近。样本容量越大，则均值接近真值的速度也越快，相反，当样本容量小的时候，你就得抽取非常多的样本来使得样本均值的均值和总体均值足够接近。为了说明这一点，我们举一个有趣的例子，该例中样本容量大于16. 我们抽取的样本容量为 <code>n = 51</code>(与总体的单位数量相同)，共重复抽取100次：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set.seed(<span class="number">31415</span>)</span><br><span class="line">mean(replicate(<span class="number">100</span>, mean(sample(USstatePops$V1, size = <span class="number">51</span>, replace = <span class="literal">TRUE</span>)), </span><br><span class="line">    simplify = <span class="literal">TRUE</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 6016650</span><br></pre></td></tr></table></figure>
<p>现在我们的计算结果与总体均值已经相差不超过1%了。你可能会觉得有点摸不到头脑，“等一等，难道样本容量为51不就是把总体中所有的单位都抽取了吗？”这的确让人迷惑，但这个问题可以追溯到前几页里我们提到的可放回抽样（当时我们在抽样命令里也是使用了 <code>replace = TRUE</code> 这个参数）。可放回抽样的意思是随着你从总体中抽取了一个单位来放到你的样本中，紧接着你就把它又放回了总体的单位里去，这也意味着你有潜在的可能性在接下来的抽取过程中再次抽中它。如前文所说，我们已经省略掉了相应的证明部分，而这除了会让你迷惑以外，并不产生任何问题。事实上，我们可以让样本容量更大，而不会带来任何麻烦：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set.seed(<span class="number">31415</span>)</span><br><span class="line">mean(replicate(<span class="number">100</span>, mean(sample(USstatePops$V1, size = <span class="number">120</span>, replace = <span class="literal">TRUE</span>)), </span><br><span class="line">    simplify = <span class="literal">TRUE</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 6028504</span><br></pre></td></tr></table></figure>
<p>这个命令对容量为 <code>n = 120</code> 的样本重复抽取了100次。让我们来看看抽样分布的均值和总体均值有多么的接近了！回顾之前我们提到过的，每次你运行这个程序，你都会得到稍微不同的结果，这是因为每次抽取的都是不同的样本（译者注：如果使用了set.seed()就不会遇到这种情况）。但是按照以往的经验，随着统计学家们用 <code>n</code> 来表示的样本容量越来越大，你对总体均值的估计也会越来越接近真值。相应的，如果你抽取更多的样本量，你的估计也是越来越准的。</p>
<p>现在，如果你已经从刚才的状况缓了过来，那么就让我们来进一步的利用抽样分布来做更多的事情吧。首先，让我们将所有样本均值保存下来，以便我们可以对这列数进行下一步的计算：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set.seed(<span class="number">31415</span>)</span><br><span class="line">SampleMeans &lt;- replicate(<span class="number">10000</span>, mean(sample(USstatePops$V1, size = <span class="number">5</span>, replace = <span class="literal">TRUE</span>)), </span><br><span class="line">    simplify = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure>
<p>我们是将所有的抽样均值保存到一个称为“SampleMeans”的新向量中。我们应该有10000个样本均值：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">length(SampleMeans)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 10000</span><br></pre></td></tr></table></figure>
<p>这些抽样均值的算术平均数应该和我们的总体均值6053384相当接近：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mean(SampleMeans)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 6062372</span><br></pre></td></tr></table></figure>
<p>你可能还想要对 SampleMeans 生成一个直方图，来看看频数分布是如何的。目前，我们所需要查看的只是这列抽样均值数列的一个总括：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">summary(SampleMeans)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##     Min.  1st Qu.   Median     Mean  3rd Qu.     Max. &#10;##   822000  3880000  5380000  6060000  7650000 24500000</span><br></pre></td></tr></table></figure>
<p>如果你需要回顾中位数（median）和分位数（quantile）的概念，可以回头看看第3章-行和列。</p>
<p>这个总括里包含了很多信息。首先让我们来看看最大值（max）和最小值（min）。这列样本均值的最小值是822000。让我们思考一下，当我们知道总体均值是那么大的时候，怎么会抽取到均值这么小的样本呢？怀俄明州（Wyoming）在那个样本中一定被抽到过好几次吧！答案和伴随着抽样过程的随机性有关。如果你运行某个随机抽样程序10000次，那么你肯定会遇到几个很怪异的样本的。这很像是买彩票。你买的大多数彩票都是正常的——中不了奖的。但是就在某个时刻，你也会遇到那个极其特殊的大奖。抽样过程和此类似：极端特殊的情况是很不寻常的，但是如果你抽样的次数足够多，你也会遇到这种情况的。对于最大值我们也有类似的结论：我们抽到的最大的样本均值24500000，比总体均值大得多。</p>
<p>SampleMeans的中位数5380000和均值6060000比较接近，但并不完全相同。这是因为我们的样本均值分布有点右偏（数值较大的右侧尾巴比对称情况下要长，这是由于原始分布是反向J形的）。中位数是很有用的，这是因为它把所有的样本等分为两半：50%，或者5000个样本均值是比5380000大的，另外一半是比5380000要小的。因此，如果我们此时要从总体中再随机抽取一个样本的话，那么它就有一半的可能性大于中位数。分位数能够帮助我们更好的对数据进行分割。第三分位数将数据较小的75%和较大的25%分开。因此只有25%的样本均值大于7650000。这意味着如果我们再从总体中随机抽取一个样本的话，那么这个样本均值只有25%的可能性是大于7650000的。类似的，第一分位数告诉我们，如果随机抽取一个新的样本的话，那么样本均值只有25%的可能性是比3880000要小的。</p>
<p>有另外一种更加灵活的从R中获取相同信息的方法. quantile()函数可以展示中位数以及分位数, 例如</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quantile(SampleMeans, probs = c(<span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##     25%     50%     75% &#10;## 3875658 5379840 7649252</span><br></pre></td></tr></table></figure>
<p>你会注意到这些数值与上文summary()函数展示的数值的少了千分之一(one tenth of one percent). quantile()函数的结果比较精准, 尽管summary()函数的结果可以满足绝大多数的需求. 使用quantile()函数的另一个原因是我们可以精准的控制分割点. 为了得到分位数, 我们在25%, 50%, 75%进行分割. 但是如果我们希望在2.5%和97.5%进行分割该怎么办? 这对于quantile()函数来说很容易:</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quantile(SampleMeans, probs = c(<span class="number">0.025</span>, <span class="number">0.975</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##     2.5%    97.5% &#10;##  2019463 13318627</span><br></pre></td></tr></table></figure>
<p>在这个例子里, 如果我们选取新的样本, 样本均值仅有2.5%的几率低于2019463. 类似的, 样本均值仅有2.5%的可能性会大于13318627(因为有97.5%的数值低于样本均值的分布).</p>
<p>我们来做个练习. 这里的人在一定区域内，其中每一个领域是某种与美国相关联的单元的数目的样本</p>
<p>3,706,690<br>159,358<br>106,405<br>55,519<br>53,883</p>
<p>我们可以很容易的在R中计算样本均值</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MysterySample &lt;- c(<span class="number">3706690</span>, <span class="number">159358</span>, <span class="number">106405</span>, <span class="number">55519</span>, <span class="number">53883</span>)</span><br><span class="line">mean(MysterySample)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 816371</span><br></pre></td></tr></table></figure>
<p>我们的神秘样本的均值是 816371. 但问题是, 这是一个美国各州的样本还是其他? 仅有这一个样本很难回答这个问题. 我们首先会观察到样本中含有比Kansas, Utah, Nebraska 和其他几个州都要多的人数. 从上文的人口数据的分布我们也可以看出很多州的人数都很小. 多亏了我们在上文中举的例子使得我们可以更好的进行比较. 我们有样本均值的分布并且我们可以很公平的拿新的样本均值与之对比, 新的均值超出了样本分布的极限区域, 也就是低于2.5%或高于97.5%. 故我们的神秘样本看起来不像是美国各州的取样.</p>
<p>既然这样, 我们可以清楚的看到816371处在样本分布的极低区域. 回想我们使用quantile()函数时我们发现仅2.5%的样本均值低于2019463.</p>
<p>事实上, 我们可以使用更为严格的标准:</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quantile(SampleMeans, probs = c(<span class="number">0.005</span>, <span class="number">0.995</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##     0.5%    99.5% &#10;##  1414671 17084662</span><br></pre></td></tr></table></figure>
<p>quantile()函数显示仅有0.5%的样本均值低于1414671. 因此我们的神秘样本的均值816371如果是美国各州的采样, 那么必然是个小概率事件. 从这一点我们可以基于有力的统计证据来暂时推测, 我们的神秘样本<strong>不是</strong>美国各州的采样. 神秘样本的均值比美国各州样本的均值小太多.</p>
<p>事实上我们的推测是正确的: 神秘样本包含五个不同的美国领土, 其中包含在太平洋加勒比海地区的Puerto Rico. 那些领土是由一些大陆块和与美国有关系的一群人组成, 但是他们与美国各州不同. 也就是说他们都是岛屿, 因此他们的人口数都限制在大陆块中. 尽管在美国各州中仅夏威夷是岛屿, 但事实上夏威夷岛是美国大陆上各州面积的10倍以上. 这个例子中我们最值得学习的就是这组数据的属性, 尤其是与已知样本均值的分布不同的均值, 可以让我们推断出这组数据并非从原始数据中采样.</p>
<p>这是所有统计推断的基础. 你构建一个比较分布并且划分出一些极限值所在的区域,然后你用新获取到的数据与已知分布进行比较看新样本是否会落入极限区域. 如果新样本符合上述规律, 那么你可以暂时认为新样本是从其他数据源获取到的.</p>
<p>如果你有一些困惑，那么不要气馁. 上一段话代表了四五百年的数学发展. 在没有像R这样的可以创造和分析真实样本分布的工具之前, 上述的绝大多数材料仅是一系列的公式和证明. 在后续的章节里我们会回到用户证明上述描述的特定统计规程. 但是现在我们仅需要记下其他三条信息.</p>
<p>第一, 我们使用mean()函数查看样本均值的分布和使用hist()函数查看它的形状, 但是我们从不量化分布的离散程度.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sd(SampleMeans)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 3016920</span><br></pre></td></tr></table></figure>
<p>这里显示样本分布的标准差. 统计学家称之为”均值的标准误差”. 这个拗口的术语有另外一个清晰但较长的解释: 人口采样的样本分布均值的标准偏差. 不幸的是, 统计学家并非全都知道. 当我们看一个分布并且分布中的每个点都代表一个样本(例如, 一个均值), 那么标准差就可以认为是标准误差.</p>
<p>第二, 发现标准误差其实不需要构造一个10000个（或其他任意个数的）样本均值构成的经验分布. 事实上, 原始数据的标准差和标准误差具有一定的关系:</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sd(USstatePops$V1)/sqrt(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 3051779</span><br></pre></td></tr></table></figure>
<p>上述公式表示用原始数据的标准差除以样本大小的平方根. 在上文中当我们使用replicate()和sample()命令创建SampleMeans向量时, 我们使用的样本大小n=5. 这就是为什么你在上文中看到sqrt(5)的原因. 在R或者其他软件中sqrt()是”square root”的简写, 而不是你预期的”squirt”. 因此如果你有一系列数据并且你想计算他们的标准差,  你可以计算样本均值分布的标准误差(每一个都有相同的样本大小), 除以样本大小的平方根. 你可能发现通过使用这种方法得出的结果会比直接从样本分布中得到的结果大一些, 但是这种差异没有任何意义(仅是因为分布的随机性导致). 另一个你会注意到的事情是样本空间越大, 标准差越小. 这对于样本的选择有很重要的法则: 样本越大越好.</p>
<p>最后是另外一个简便方法. 我们创建样本分布的97.5%的分割点并且使用quantile()函数计算真实的分割. 我们同样可以使用均值和标准差计算分割点. 均值减去2倍标准差就是2.5%的分割点, 均值加上2倍标准差就是97.5%的分割点.</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StdError &lt;- sd(USstatePops$V1)/sqrt(<span class="number">5</span>)</span><br><span class="line">CutPoint975 &lt;- mean(USstatePops$V1) + (<span class="number">2</span> * StdError)</span><br><span class="line">CutPoint975</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 12157391</span><br></pre></td></tr></table></figure>
<p>你会发现这个数值与我们使用quantile()函数计算全部分布的数值有差别. 这种差异由我们构建的分布的随机性导致. 上述结果仅是基于统计证明的估计值, 而我们创建的SampleMeans 数据集仅是我们能创建的最大的接近无限的集合. 我们可以很容易的通过使用更大的样本容量和添加更多的抽样分布的抽取次数来降低两种方法之间的矛盾.</p>
<p>总结一下, 我们使用了一个有51个美国各州人口数据的数据点和一些R的知识创建了一个样本均值分布, 我们学到了以下知识:</p>
<ul>
<li>持续运行一个统计过程多次你就可以得到一致的规律.</li>
<li>计算大样本的均值和绘制直方图可以展示样本均值是正态分布并且分布中心与原始数据的均值接近.</li>
<li>样本均值形成的分布可以用来进行比较. 通过在极低的区域和极高的区域使用分割点, 例如2.5%和97.5%, 我们可以把它与新获取的样本进行比较.</li>
<li>如果我们获得新的样本均值, 并且我们发现它掉入我们设定的极限区域, 我们可以暂时认为新样本与之前的数据来自不同数据源.</li>
<li>另外一种更精确的计算标准差的方法是使用原始数据的标准误差.</li>
</ul>
<p>目前为止我们仍不是统计学家, 但是建立在样本分布上的推理过程是统计推理的核心. 假如你理解了本章的内容, 你已经向成为一个应用统计人才的道路迈出了坚实的一步. </p>
<p>本章测试<br>收集一个包含至少20个数据点的样本并且构造样本分布. 计算标准差和并且使用标准误差计算2.5%和97.5%的分布分割点. 你收集的数据点必须代表相同数量的现象. 例如, 你可以手机20本教科书的价格, 或者统计20段文字中的单词数量.</p>
<p>资源  </p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Central_limit_theorem" target="_blank" rel="external">中心极限定理</a>  </li>
<li><a href="http://en.wikipedia.org/wiki/Gerolamo_Cardano" target="_blank" rel="external">Gerolamo Cardano</a>  </li>
<li><a href="http://en.wikipedia.org/wiki/Jacob_Bernoulli" target="_blank" rel="external">Jacob Bernoulli</a>  </li>
<li><a href="http://en.wikipedia.org/wiki/Law_of_large_numbers" target="_blank" rel="external">大数定理</a>  </li>
<li><a href="http://en.wikipedia.org/wiki/List_of_U.S._states_and_territories_by_population" target="_blank" rel="external">美国各州及领土人口</a>  </li>
<li><a href="http://www.khanacademy.org/math/statistics/v/central-limit-theorem" target="_blank" rel="external">中心极限定理</a>  </li>
</ul>
<p>本章使用的R命令  </p>
<ul>
<li>length(). 获得向量中的元素数量.  </li>
<li>mean(). 算术平均值或者一系列值的均值  </li>
<li>quantile(). 基于百分比或比例计算分割点.  </li>
<li>replicate(). 多次运行一条语句/计算.  </li>
<li>sample(). 在向量中随机抽取元素.  </li>
<li>sd(). 计算标准差.  </li>
<li>sqrt(). 计算平方根.  </li>
<li>summary(). 返回向量的描述性信息.   </li>
</ul>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/数据科学/">数据科学</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Introduction-to-data-science/">Introduction to data science</a><a href="/tags/数据科学/">数据科学</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/08/17/2014-8-data-science-chp7-sample/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/08/17/2014-8-data-science-chp7-sample/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/08/17/2014-8-data-science-chp6-beer/" title="数据科学(6)-啤酒，农场和豌豆" itemprop="url">数据科学(6)-啤酒，农场和豌豆</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="中继点" target="_blank" itemprop="author">中继点</a>
		
  <p class="article-time">
    <time datetime="2014-08-17T03:09:50.000Z" itemprop="datePublished"> 發表於 2014 Aug 17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本文为<strong>Introduction to Data Science</strong>一书的翻译，由网友义务完成，了解参加翻译的网友，请点击<a href="https://github.com/johnstart/data-science/blob/gh-pages/task.md" target="_blank" rel="external">这里</a>，如果要加入我们请加入qq群171546473,了解翻译规则点击<a href="https://github.com/johnstart/data-science/blob/gh-pages/index.md" target="_blank" rel="external">这里</a></p>
<h1 id="u7B2C_u516D_u7AE0_uFF1A_u5564_u9152_uFF0C_u519C_u573A_u548C_u8C4C_u8C46"><a href="#u7B2C_u516D_u7AE0_uFF1A_u5564_u9152_uFF0C_u519C_u573A_u548C_u8C4C_u8C46" class="headerlink" title="第六章：啤酒，农场和豌豆"></a>第六章：啤酒，农场和豌豆</h1><p><img src="/img/datascience/chp6-header.png" alt="header"></p>
<h4 id="u5F88_u591A_u6700_u7B80_u5355_u548C_u6700_u5B9E_u7528_u7684_u7EDF_u8BA1_u65B9_u6CD5_u90FD_u6765_u81EA_u4E8E_u51FA_u751F_u4E8E_u5341_u4E5D_u4E16_u7EAA_u5DE5_u4E1A_u9769_u547D_u65F6_u671F_u7684_u56DB_u4E2A_u5E74_u8F7B_u4EBA_u3002_u4ED6_u4EEC_u5927_u90E8_u5206_u7684_u5DE5_u4F5C_u90FD_u4E13_u6CE8_u4E8E_u4F7F_u7528_u6536_u96C6_u5230_u7684_u6570_u636E_u6765_u63CF_u8FF0_u89C2_u5BDF_u5230_u7684_u73B0_u8C61_u5E76_u4E14_u505A_u51FA_u76F8_u5E94_u7684_u63A8_u65AD_uFF0C_u5E94_u7528_u5230_u5DE5_u4E1A_u548C_u519C_u4E1A_u751F_u4EA7_u5B9E_u9645_u4E2D_u53BB_u89E3_u51B3_u95EE_u9898_u3002"><a href="#u5F88_u591A_u6700_u7B80_u5355_u548C_u6700_u5B9E_u7528_u7684_u7EDF_u8BA1_u65B9_u6CD5_u90FD_u6765_u81EA_u4E8E_u51FA_u751F_u4E8E_u5341_u4E5D_u4E16_u7EAA_u5DE5_u4E1A_u9769_u547D_u65F6_u671F_u7684_u56DB_u4E2A_u5E74_u8F7B_u4EBA_u3002_u4ED6_u4EEC_u5927_u90E8_u5206_u7684_u5DE5_u4F5C_u90FD_u4E13_u6CE8_u4E8E_u4F7F_u7528_u6536_u96C6_u5230_u7684_u6570_u636E_u6765_u63CF_u8FF0_u89C2_u5BDF_u5230_u7684_u73B0_u8C61_u5E76_u4E14_u505A_u51FA_u76F8_u5E94_u7684_u63A8_u65AD_uFF0C_u5E94_u7528_u5230_u5DE5_u4E1A_u548C_u519C_u4E1A_u751F_u4EA7_u5B9E_u9645_u4E2D_u53BB_u89E3_u51B3_u95EE_u9898_u3002" class="headerlink" title="很多最简单和最实用的统计方法都来自于出生于十九世纪工业革命时期的四个年轻人。他们大部分的工作都专注于使用收集到的数据来描述观察到的现象并且做出相应的推断，应用到工业和农业生产实际中去解决问题。"></a>很多最简单和最实用的统计方法都来自于出生于十九世纪工业革命时期的四个年轻人。他们大部分的工作都专注于使用收集到的数据来描述观察到的现象并且做出相应的推断，应用到工业和农业生产实际中去解决问题。</h4><p>十八世纪末到十九世纪初，数学和科学取得了突破性的进展。那个年代的科学家和数学家们认为只需要纸、笔和足够的时间，人类所面临的一切问题（包括人类无法突破自身局限的问题）都可以被测量、分解、分析和重建使之更为有效。法兰西斯·高尔顿，卡尔·皮尔逊，威廉·戈塞和罗纳德·费雪这四个英国人成为了当时科学发展观和理想主义信念的代表。</p>
<p>首先要提到的是法兰西斯·高尔顿，大名鼎鼎的查尔斯·达尔文的表兄，虽然名气没有表兄大，但他也是智商超群。高尔顿是一位绅士，通晓拉丁文和希腊语，学过医学和数学，他还是一位著名的非洲探险家。他提出了“优生学”的概念，也因极力倡导优生学而为人所知。优生学是指通过有选择的生育来改善人种。高尔顿研究了豌豆、兔子和人类的遗传特征，推断称我们应该奖励部分人结婚生育，因为他们的后代可以改善人种。这些观念在二战时被纳粹德国错误利用，他们认为自己是优等种族，这也成为他们惨绝人寰的屠杀理由。当然除了优生学之外，高尔顿对数学和统计学的发展也做出了重要和珍贵的贡献，特别是建立了两种如今广泛使用的基础方法：相关性分析和回归分析。</p>
<p>细看高尔顿的研究和理论，客观来讲他本人并不是个出色的数学家，但是他有个年轻的搭档，也就是常被认为是数理统计奠基人的卡尔·皮尔逊。皮尔逊重新处理了相关性和回归分析理论背后的数学推导，并且在数据处理方面做了很多影响至今的工作。和高尔顿一样，皮尔逊也支持优生学的理论，他也因为启发了爱因斯坦的相对论而获得赞誉，同时，他还是一名早期的女权主义的拥护者。</p>
<p>下一位要介绍的是威廉·戈塞，一个数学和化学的奇才。也许因为他在化学方面的专业知识，他大学刚毕业就受聘于爱尔兰都柏林的健力士精酿公司。作为一个前瞻性的公司，健力士酿酒厂此时正想办法解决大批量生产精酿啤酒时品质波动的问题。戈塞加入公司之后提出了一种现在被称为小样本抽样的统计方法，也就是分析容量相对较小的样本，得到对整体的估计结果。当然，大批量精酿啤酒是个耗时且昂贵的工艺流程，所以要想从小样本抽样分析得到对整体质量的估计，戈塞只好研究概率对在决定一批啤酒质量所起到的作用。健力士公司并不赞成他把这项研究的结果对学术界公开，无奈的戈塞用了“学生”这一谦虚的化名将他的方法公之于众。“学生t检验”中的“学生”就是由此而来的。</p>
<p>最后要介绍的这位十八世纪的数学家是罗纳德·费雪，他同时也研究生物和遗传学。和高尔顿不同，费雪并不是一名富有的绅士，事实上,他和夫人刚结婚时是两个靠干农活维持生计农民。在费雪的众多论文中，有一篇是在洛桑试验站投稿发表的。在洛桑试验站，他研究粮食产量波动的数据，提出了一个非常重要的统计分析方法–方差分析。费雪还是实验设计的先驱，提出了我们在前几章提到过的要素、水平、实验组和对照组等方面内容。</p>
<p>当然，十九、二十世纪期间对实用统计做出贡献的数学家肯定不止以上提到的四位，但是这四位在应用数理和统计到其他科学研究方面确实颇有地位（所以“啤酒、农场和豌豆”也是一个好的章节名）。</p>
<p>纵观这四位的研究，问题的关键在于他们手头上能拿到的数据“样本”和可能或者的确存在的大的数据总量在数量上有很大区别。当戈塞在啤酒厂批量精酿啤酒时，他知道穷尽所有种原料配比和制备方法来获取数据是不现实的。戈塞明白他只能小批次取样分析，描述数据然后来推测在将来的批次可能发生的情况。这也是处理各种类型、各种容量数据时我们面临的窘境：不论你有什么样的数据，总会有更多没有被取样的数据。你可以通过改变测量和处理方法来获取数据，但未来还会有更多没有被收集到的数据，也许永远不会被收集。甚至于我们使用了完全相同的数据收集方法，但是数据却仍然会因随机性而不同。不管你有什么数据，它只是总体的一个快照，或者说一个样本。这让我们明白我们无法完全信任我们手上的数据；我们必须有所保留，记住在数据中总有不确定性。统计学提供了很多强大的统计工具，这些费雪们开发的实用工具帮助人们描述并量化数据中的不确定性，帮助我们了解对单一样本的信任程度。所以请记住：尽管我们可以<strong>描述</strong>我们手上的样本数据，但最大的挑战在于如何<strong>推测</strong>我们无法获取的更大的总量数据的意义。这正是描述统计学和推断统计学之间最重要的差别。</p>
<p>在前面几章我们已经学习过几种描述统计学概念，下面从实际应用角度重新定义了这几种概念：</p>
<ul>
<li><p>平均数（严格说是算术平均数）是表征数据集中趋势的一个指标。 它是由观测数据之和除以这组数据的观测个数得到的。</p>
</li>
<li><p>中位数也可以表征数据集中的趋势，但它不能直接计算得出。把所有观察值由高到低排序后，位于正中间的那个数就是中位数。</p>
</li>
<li><p>全距，又称极差，是表征离散程度的一个指标，通过计算样本中最大值与最小值之间的差得到。</p>
</li>
</ul>
<p>在这个列表中我们应该再加上三个在不同情况下会遇到的概念：</p>
<ul>
<li><p>众数，另一个表征集中趋势的指标，指一组数据中出现次数最多的值。和中位数一样，众数也无法被直接计算得出。你得数出每个变量出现的个数，然后那个出现次数最多的数就是众数。</p>
</li>
<li><p>方差，测量样本数据的离散程度。和全距类似，方差也描述样本的展开程度，然而与全距仅仅由最大最小数之差来描述不同，方差是各个数据与平均数之差的平方和的平均数。前面章节提到过家庭成员年龄的数据，他们的平均年龄是22岁。如果你还能想起细节，那你就能读懂如下的表格：</p>
</li>
</ul>
<p><img src="/img/datascience/chp6-table1.png" alt="table1"></p>
<p>这个表格演示了如何计算方差：先计算各个数据与平均数之间的偏离量，然后将差值平方（乘以自己）来消除负数偏离量的影响（比如弟弟的偏离量为-14）。然后我们求出偏离量的平方和，最后除以观察值的个数来得到“平均的偏移量平方”。注意，将平方和除以4而不是5并不是一个错误，当我们在后面谈到自由度这个概念的时候你就会明白这么做的原因。这样我们就得到了方差这个应用广泛的统计概念。虽然在数学上很有用，但联系实际方差看起来并不能描述所有问题。比如从家庭成员年龄的数据，得到对平均年龄有356.5“平方年”的偏离量，看起来怪怪的。平方米或许容易理解，但那是另一码事情了。所以为了应付这种尴尬，统计学家又提供了一种更容易理解的概念：</p>
<ul>
<li>标准差，另一个描述离散程度的特征量，且和方差联系紧密。标准差其实就是对方差进行开平方，消除了“平方年”这种尴尬的单位带来的困惑。在上面的例子里，标准差约是18.88年（保留两位小数，在这种情况已经足够）。</li>
</ul>
<p>下面我们来看看在R中如何计算这些数值：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; var(myFamily$myFamilyAges)</span><br><span class="line">[<span class="number">1</span>] <span class="number">365.5</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; sd(myFamily$myFamilyAges)</span><br><span class="line">[<span class="number">1</span>] <span class="number">18.88121</span></span><br></pre></td></tr></table></figure>
<p>注意这里使用了前面章节用到的数据，通过使用“$”来获取数据框的变量。如果你没有前面章节的数据，你也可以这样做：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; var(c(<span class="number">43</span>, <span class="number">42</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">5</span>))</span><br><span class="line">[<span class="number">1</span>] <span class="number">365.5</span></span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; sd(c(<span class="number">43</span>, <span class="number">42</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">5</span>))</span><br><span class="line">[<span class="number">1</span>] <span class="number">18.88121</span></span><br></pre></td></tr></table></figure>
<p>这里例子真是很无聊，而且对后面章节的内容也没有太多用，所以下面我们换一组数据来分析。我们要使用Windows或者Mac的剪切板程序来复制粘贴一组大一点的数据到R里。进入美国统计局网站，那里存储了许多人口数据：</p>
<p><a href="http://www.census.gov/popest/data/national/totals/2011/index.html" target="_blank" rel="external">http://www.census.gov/popest/data/national/totals/2011/index.html</a></p>
<p>如果你有电子表格程序，点击XLS链接（“Annual Estimates of the Resident Population for the United States”）。当表格打开之后，选择五十个州的人口估算数据。前几行数据应该像下面这样（2011年数据）：</p>
<p><img src="/img/datascience/chp6-table2.png" alt="table2"></p>
<p>为了使用下面介绍的R命令，请只选择数字而不是文本。在你复制数字之前，把单元格类型改为“常规”来去除逗号。通常可以在格式菜单里选择修改单元格，当然你也可以在工具栏里很容易找到相关按钮。把数字复制到剪切板中（Windows用户使用快捷键Ctrl + C，Mac用户使用快捷键command + C）。在Windows上使用如下命令：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read.DIF(<span class="string">"clipboard"</span>, transpose=<span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure>
<p>在Mac电脑上使用下面代码：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read.table(pipe(<span class="string">"pbpaste"</span>))</span><br></pre></td></tr></table></figure>
<p>在不同类型电脑上使用不同命令很烦人，谁让微软和苹果的工程师使用不同的方法来设置剪切板呢，这种副作用无法避免，况且R又是跨平台设计，只能屈从于不同的平台采用不同的代码了。不管怎么说，你现在应该能在R的控制台看到很长一串人口数量数据输出了。光是这串数字其实没什么用，下面我们把他们放到一个向量里面：</p>
<p>在Windows上使用<code>read.DIF</code>:</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; USstatePops &lt;- +</span><br><span class="line">read.DIF(<span class="string">"clipboard"</span>, transpose=<span class="literal">TRUE</span>)</span><br><span class="line"></span><br><span class="line">&gt; USstatePops</span><br><span class="line">            V1</span><br><span class="line"><span class="number">1</span>   <span class="number">4779736</span></span><br><span class="line"><span class="number">2</span>    <span class="number">710231</span></span><br><span class="line"><span class="number">1</span>   <span class="number">6392017</span></span><br><span class="line"><span class="keyword">...</span></span><br></pre></td></tr></table></figure>
<p>在Mac电脑上使用<code>read.table</code>:</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; USstatePops &lt;- read.table(pipe(<span class="string">"pbpaste"</span>))</span><br><span class="line"></span><br><span class="line">&gt; USstatePops</span><br><span class="line">            V1</span><br><span class="line"><span class="number">1</span>   <span class="number">4779736</span></span><br><span class="line"><span class="number">2</span>    <span class="number">710231</span></span><br><span class="line"><span class="number">1</span>   <span class="number">6392017</span></span><br><span class="line"><span class="keyword">...</span></span><br></pre></td></tr></table></figure>
<p>这里因篇幅所限只显示前三行数据。你的R的输出应该是全部列表。注意其实这里和之前章节的不同不过是我们使用了<code>read.DIF()</code>或者<code>read.table()</code>函数来获取更大一点的数据，而不需要手动输入。像<code>read.table()</code>这样的函数在今后使用R的过程中显得十分重要，因为这些函数让我们能把从外部文件存储的数据读入R的存储空间来进行数据分析。如果在使用中出现问题，你可以复制粘贴本章最后的“如果失败了”部分的命令代码来把相同的数据输入到R里。</p>
<p>注意我们使用赋值符号<code>&lt;-</code>把<code>read.DIF()</code>或者<code>read.table()</code>的结果放到了一个R数据对象中。现在你可以使用前面章节学到的<code>str()</code>和<code>summary()</code>函数来对这个新的数据对象<code>USstatePops</code>进行练习了。你有没有发现这些函数返回的结果很有趣？你会发现这里有51个观测值而不是50个，你知道为什么吗？如果一时想不出，你可以看看网站或者是表格里的原始数据。另外你会发现<code>USstatePops</code>是一个数据框，而不是一个向量。你可以从上面的输出看出来：在第二行代码我们要求R返回<code>USstatePops</code>变量里存储的内容，R输出了一列，列名称为<code>V1</code>。因为我们没有给这个列命名，于是R缺省地将此列命名为<code>V1</code>，即Variable One的缩写。所以当我们想要获取这一列数据的时候，我们就可以使用<code>USstatePop$V1</code>。如果这听起来挺陌生的，那请在看一看前面“行与列”那章关于如何获取数据框中一列的内容。</p>
<p>现在我们已经准备好在这个稍微大一点的数据上小试牛刀了。首先是对各州人口的一些描述性统计量：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; mean(USstatePops$V1)</span><br><span class="line">[<span class="number">1</span>] <span class="number">6053834</span></span><br><span class="line">&gt; median(USstatePops$V1)</span><br><span class="line">[<span class="number">1</span>] <span class="number">4339367</span></span><br><span class="line">&gt; mode(USstatePops$V1)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"numeric"</span></span><br><span class="line">&gt; var(USstatePops$V1)</span><br><span class="line">[<span class="number">1</span>] <span class="number">4.656676e+13</span></span><br><span class="line">&gt; sd(USstatePops$V1)</span><br><span class="line">[<span class="number">1</span>] <span class="number">6823984</span></span><br></pre></td></tr></table></figure>
<p>上面的总结内容看起来很棒，但是等一下，有些返回值好像跟想象有所不同：</p>
<ul>
<li><p><code>mode()</code>函数返回了数据向量的类型，而不是统计变量：众数。这挺怪的，但是确是对的：基础的R包其实并没有一个计算众数的函数！这是因为众数只少数情况下使用。我们在后面的章节会告诉你如何添加R的包来获取新的R函数，其中就包括计算众数的函数。</p>
</li>
<li><p>方差的返回值是4.656676e+13。这是在本书中我们第一次看到R中使用科学计数法。如果你以前没看过这种计数方法，没关系，你可以这么想：把4.656676乘以10000000000000（也就是10的13次方）。这个数太大了，而且写起来很累，所以使用科学记数法很省事。如果你不想在计算器上按照科学计数法来输入，还有一个窍门就是把小数点向右移13位。</p>
</li>
</ul>
<p>除了这两点，我们现在知道美国各州人口平均数为6053834，标准差为6823984。你可能会想标准差接近七百万意味着什么？平均数和标准差的数值都没问题，而且他们还十分精确，但是对我们大多数人来说，用一张图来展示这种数据集中趋势和离散程度会更为直观。那么我们就来画一张直方图。运行如下代码：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hist(USstatePops$V1)</span><br></pre></td></tr></table></figure>
<p>在图片输出那里你应该能看到如下图片</p>
<p><img src="/img/datascience/chp6-plot1.png" alt="histogram"></p>
<p>直方图是专门用来显示“频率”的条形统计图表。频率在这里指在一个数据集合中一个特定的数值或者数值空间出现的次数。上面的直方图很有趣，大约有30个州人口不足500万，另外有10个州人口不到1000万，剩下很少一部分州人口超过1000万。那么我们到底该如何从统计图表中提取这些信息呢？首先顺着Y轴（左面垂直的轴线）读取频率信息。最高的竖长条就挨着Y轴，最高点接近Y轴的标记30。顺着X轴（底部水平的轴线）可以读出这个竖长条所表示的内容了，注意到每两个竖长条之间就会有一个X轴的科学计数标记，第一个是1e+07，也就是1000万.所以每出现一个新的竖长条（或者没有数据）代表人口增加500万。知道X，Y轴标记代表的意义之后就很容易推断出大约有30个州人口不足500万这个结论了。</p>
<p>如果你考虑总统选举，或者学校或者公司的地址，或者拿美国的一个州和世界上其他国家的比较，你得知道美国有两个特别大的州，以及一群特别小的州。当你能熟练阅读直方图之后，这些信息就会一目了然了。</p>
<p>另一个角度来说，这张统计直方图还有点不尽如人意。超40个州都挤到最前面几个竖长条里了，这其中应该还有许多我们想知道的隐藏信息。我们可以通过改变竖长条的个数来揭示这些隐藏的内容。在刚的那直方图中，一共有8个直方长条，那么为什么R会选择8呢？</p>
<p>答案就在于<code>hist()</code>函数有自己默认的计算长条数量的算法，观测值的数量、数据的分布以及空缺的区间都被这个算法考虑在内。幸运的是我们可以通过调整<code>breaks</code>这个参数让R调整直方长条的数量，就像下面的代码：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hist(USstatePops$V1, breaks = <span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/datascience/chp6-plot2.png" alt="histogram"></p>
<p>这样X轴每两个标记之间就会有5个直方长条，或者说每个直方长条代表了200万的人口增长。那么新得到的这个直方图还是告诉我们以前一样的信息：有15个州的人口低于200万。这种图样表示了一种统计分布，从左开始有很高的频率，然后向右迅速跌落。你可以称这种分布为“倒J”分布，因为它的形状很像倒下来的英文字母“J”。统计学中，这种分布被称为帕累托分布（以意大利经济学家维弗雷多·帕雷托命名）。现在我们不必太过纠结为什么人口分布符合帕累托分布，但是我们可以猜测为什么会出现这样的分布图样。首先每个州的人口数量都是正数，不会出现零或者负人口，否则也不太合情理了。那么一个州总得有些人住，而且如果你回顾美国历史，每个州都起源于有人居住的殖民地或者领地。换个角度想，是什么因素导致某些州拥有巨大人口的呢？首先你得有足够的土地，然后有足够吸引人们搬到这个州或者在这个州出生的原因。同时也有很多制约人口增长的因素：比如罗德岛地盘小装不了太多人口，再比如阿拉斯加尽管地盘挺大，却因为太冷了很少有人愿意搬过去。所以每个州刚开始的时候人口都挺少的，随着时间推移人口数量有所上升，但很难增长太多。因此，在这个分布中大多数州都聚集在靠近Y轴的区域，只有少数州人口不断增长，成为人口大州。在这些州中，有只能有极少的几个州人口能接近4000万，事实上只有一个州实现了这个目标。顺带问一句，你知道或者你能猜出这个超级大州是哪个州吗？</p>
<p>除了帕累托分布，还有许多其他的分布图样。最普通的也是大家最常听说的是“钟”形分布，因为分布的曲线长得像钟。统计学中，这种分布被称为正态（常态）分布。“常态”这个词是卡尔·弗里德里希·高斯（1777-1855）第一次提出的，也许他认为自然现象研究中，这种分布最为典型，在常态下最容易发生。下面的直方图就体现了这种典型的钟形正态分布图样。</p>
<p><img src="/img/datascience/chp6-plot3.png" alt="histogram"></p>
<p>如果你很好奇，你就会想到底R是怎么弄出上面这个直方图的呢？而且如果你仔细观察，你就会发现这张图里有好几处都出现了”rnorm”这个词。其实这是R另外一个很棒的功能：当解决问题或者做展示的时候，可以轻易利用R生成“假”数据来辅助说明。上面直方图所使用的数据是R中的<code>rnorm()</code>函数随机生成的，这些数据被用来拟合图示的正态分布（数据越多图样越接近正态分布）。更多对<code>rnorm()</code>命令的解释有助于理解这一过程，如果你还记得上面用到的美国人口数据，平均数是6043834，标准差是6823984，使用下面的命令就能得到刚才的正态分布直方图：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hist(rnorm(<span class="number">51</span>, <span class="number">6043834</span>, <span class="number">6823984</span>))</span><br></pre></td></tr></table></figure>
<p>这里要介绍两个很重要的概念。一是嵌套函数：<code>rnorm()</code>函数生成了用来绘制直方图的随机“假”数据，<code>hist()</code>函数利用数据生成对应的直方图（要加倍注意括号的位置）。R先运行里面的函数<code>rnorm()</code>，生成的数据直接并且立即传送给<code>hist()</code>函数绘图。</p>
<p>还有个重要概念是在“传送”到<code>rnorm()</code>函数里的“参数”。其实在刚才我们调用<code>read.DIF()</code>和<code>read.table()</code>的时候就已经在使用函数参数的概念了，只是我们没有提出来。计算机科学家常使用“参数”来告诉函数进行运算的附加信息。在这个例子里，我们传递了三个参数给<code>rnorm()</code>：生成假数据的观察个数、分布的平均值和标准差。<code>rnorm()</code>函数使用了这三个参数来生成51个随机数据，这些数据粗略来说可以拟合一个正态分布。因此直方图里面的数据其实是利用“假”数据来演示按照正态分布的51州人口数据的形态。</p>
<p>在应用统计学中，正态分布被广泛用于比较。如果你看一下刚才那张正态分布直方图中最右面的那个直方长条，它旁边的那个标签是3e+07，或者说3000万。我们从真实的人口数据中得到的结论是只有一个州的人口超过了3000万（如果你还没查，那个州是加利佛尼亚州）。所以如果有个人告诉你他（她）们州人口有3000多万，但他（她）不住加州，那么你自动联想：“这不太正常的啊，我不相信”。你不相信的原因就是你有个分布函数来作对比。分布函数不仅仅拥有一个特征形状，而且有一个中值点（平均值）和一个分布空间（标准差）。有了这三个信息，你有拥有了对比数据的武器。</p>
<p>下一张我们会做一些上述提到的数据对比分析，看看我们能基于现有数据的子集（统计学家称为样本）来推断整体的关系。</p>
<h4 id="u672C_u7AE0_u6311_u6218"><a href="#u672C_u7AE0_u6311_u6218" class="headerlink" title="本章挑战"></a>本章挑战</h4><p>这一章我们使用了<code>rnorm()</code>函数来生成一系列近似拟合正态分布的数据。我们也知道了人口数据是帕累托分布。查一查哪种R函数可以生成近似拟合帕累托分布的随机数据。然后传递正确的参数到该函数生成51个随机数据（提示：可以尝试不同的概率值）。利用这些数据绘制直方图，并描述分布的形状。</p>
<h4 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://en.wikipedia.org/wiki/Carl_Friedrich_Gauss" target="_blank" rel="external">http://en.wikipedia.org/wiki/Carl_Friedrich_Gauss</a></p>
<p><a href="http://en.wikipedia.org/wiki/Francis_Galton" target="_blank" rel="external">http://en.wikipedia.org/wiki/Francis_Galton</a></p>
<p><a href="http://en.wikipedia.org/wiki/Pareto_distribution" target="_blank" rel="external">http://en.wikipedia.org/wiki/Pareto_distribution</a></p>
<p><a href="http://en.wikipedia.org/wiki/Karl_Pearson" target="_blank" rel="external">http://en.wikipedia.org/wiki/Karl_Pearson</a></p>
<p><a href="http://en.wikipedia.org/wiki/Ronald_Fisher" target="_blank" rel="external">http://en.wikipedia.org/wiki/Ronald_Fisher</a></p>
<p><a href="http://en.wikipedia.org/wiki/William_Sealy_Gosset" target="_blank" rel="external">http://en.wikipedia.org/wiki/William_Sealy_Gosset</a></p>
<p><a href="http://en.wikipedia.org/wiki/Normal_distribution" target="_blank" rel="external">http://en.wikipedia.org/wiki/Normal_distribution</a></p>
<p><a href="http://stat.ethz.ch/R-manual/R-devel/library/utils/html/read.table.html" target="_blank" rel="external">http://stat.ethz.ch/R-manual/R-devel/library/utils/html/read.table.html</a></p>
<p><a href="http://www.census.gov/popest/data/national/totals/2011/index.html" target="_blank" rel="external">http://www.census.gov/popest/data/national/totals/2011/index.html</a> </p>
<p><a href="http://www.r-tutor.com/elementary-statistics/numerical-measures/standard-deviation" target="_blank" rel="external">http://www.r-tutor.com/elementary-statistics/numerical-measures/standard-deviation</a></p>
<h4 id="u590D_u4E60_6-1__u5564_u9152_uFF0C_u519C_u573A_u548C_u8C4C_u8C46"><a href="#u590D_u4E60_6-1__u5564_u9152_uFF0C_u519C_u573A_u548C_u8C4C_u8C46" class="headerlink" title="复习 6.1 啤酒，农场和豌豆"></a>复习 6.1 啤酒，农场和豌豆</h4><p>用来展示数值型变量频率的条形图称为：</p>
<ul>
<li>A.Histogram</li>
<li>B.Pictogram</li>
<li>C.Bar Graph</li>
<li>D.Bar Chart</li>
</ul>
<h4 id="u672C_u7AE0_u4F7F_u7528_u7684R_u51FD_u6570"><a href="#u672C_u7AE0_u4F7F_u7528_u7684R_u51FD_u6570" class="headerlink" title="本章使用的R函数"></a>本章使用的R函数</h4><p><code>read.DIF()</code>        将数据读入可交换模式<br><code>read.table()</code>      从外部资源将数据读入数据表格<br><code>mean()</code>            计算算术平均数<br><code>median()</code>          找到一组数据的中位数<br><code>mode()</code>            返回数据对象的数据类型<br>                    注：<strong>不返回</strong>统计众数<br><code>var()</code>             计算样本方差<br><code>sd()</code>              计算样本标准差<br><code>hist()</code>            绘制统计直方图 </p>
<h4 id="u81EA_u6211_u6D4B_u8BD5"><a href="#u81EA_u6211_u6D4B_u8BD5" class="headerlink" title="自我测试"></a>自我测试</h4><h4 id="u5982_u679C_u5931_u8D25_u4E86"><a href="#u5982_u679C_u5931_u8D25_u4E86" class="headerlink" title="如果失败了"></a>如果失败了</h4><p>如果你在使用<code>read.DIF()</code>或者<code>read.table()</code>时遇到困难，下面的代码可以被复制粘贴（如果不能就只好手动输入）到R的控制台，来生成本章需要使用的数据。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">V1 &lt;- c(<span class="number">4779736</span>,<span class="number">710231</span>,<span class="number">6392017</span>,<span class="number">2915918</span>,<span class="number">37253956</span>,<span class="number">5029196</span>,<span class="number">3574097</span>,<span class="number">897934</span>,<span class="number">601723</span>,<span class="number">18801310</span>,<span class="number">9687653</span>, <span class="number">1360301</span>,<span class="number">1567582</span>,<span class="number">12830632</span>,<span class="number">6483802</span>,<span class="number">3046355</span>,<span class="number">2853118</span>,<span class="number">4339367</span>,<span class="number">4533372</span>,<span class="number">1328361</span>,<span class="number">5773552</span>,<span class="number">6547629</span>,<span class="number">9883640</span>,<span class="number">5303925</span>,<span class="number">2967297</span>,<span class="number">5988927</span>,<span class="number">989415</span>,<span class="number">1826341</span>,<span class="number">2700551</span>,<span class="number">1316470</span>,<span class="number">8791894</span>,<span class="number">2059179</span>,<span class="number">19378102</span>,<span class="number">9535483</span>,<span class="number">672591</span>,<span class="number">11536504</span>,<span class="number">3751351</span>,<span class="number">3831074</span>,<span class="number">12702379</span>,<span class="number">1052567</span>,<span class="number">4625364</span>,<span class="number">814180</span>,<span class="number">6346105</span>,<span class="number">25145561</span>,<span class="number">2763885</span>,<span class="number">625741</span>,<span class="number">8001024</span>,<span class="number">6724540</span>,<span class="number">1852994</span>,<span class="number">5686986</span>,<span class="number">563626</span>)</span><br><span class="line"></span><br><span class="line">USstatePops &lt;- data.frame(V1)</span><br></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/数据科学/">数据科学</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Introduction-to-data-science/">Introduction to data science</a><a href="/tags/数据科学/">数据科学</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/08/17/2014-8-data-science-chp6-beer/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/08/17/2014-8-data-science-chp6-beer/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/08/17/2014-8-data-science-chp5-row-col-2/" title="数据科学(5)-行与列-2" itemprop="url">数据科学(5)-行与列-2</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="中继点" target="_blank" itemprop="author">中继点</a>
		
  <p class="article-time">
    <time datetime="2014-08-17T03:06:44.000Z" itemprop="datePublished"> 發表於 2014 Aug 17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本文为<strong>Introduction to Data Science</strong>一书的翻译，由网友义务完成，了解参加翻译的网友，请点击<a href="https://github.com/johnstart/data-science/blob/gh-pages/task.md" target="_blank" rel="external">这里</a>，如果要加入我们请加入qq群171546473,了解翻译规则点击<a href="https://github.com/johnstart/data-science/blob/gh-pages/index.md" target="_blank" rel="external">这里</a></p>
<p> <code>str()</code>函数展现了括号内数据对象的结构。在这个例子中，我们可以肯定myFamily是一个数据框，因为我们先前的命令建立了这个数据框。但是，未来会遇到各种各样的情况，我们无法确定R是怎样建立一个新的数据对象。因此，使用 <code>str()</code>函数随时了解数据对象的结构很重要。</p>
<p>在第一行输出结果中，我们可以确定myFamily是一个数据框，其中包含了5个观测值（统计师通常使用观测值而不是案例或实例）和4个变量。”$” 符号将后续的输出信息分为四个部分，分别对应4个变量。这四个部分分别描述了myFamily数据框对象的列信息。</p>
<p>根据R的输出格式，变量名紧跟着冒号和数据类型。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myFamilyNames&#60;-c(&#34;Dad&#34;,&#34;Mom&#34;,&#34;Sis&#34;,&#34;Bro&#34;,&#34;Dog&#34;)&#10;myFamilyAges&#60;-c(43,42,12,8,5)&#10;myFamilyGenders&#60;-c(&#34;Male&#34;,&#34;Female&#34;,&#34;Female&#34;,&#34;Male&#34;,&#34;Female&#34;)&#10;myFamilyWeights&#60;-c(188,136,83,61,44)&#10;myFamily&#60;-data.frame(myFamilyNames,myFamilyAges,myFamilyGenders,myFamilyWeights)&#10;str(myFamily)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ myFamilyGenders: Factor w/ 2 levels &#34;Female&#34;,&#34;Male&#34;: 2 1 1 2 1</span><br></pre></td></tr></table></figure>
<p>例如，myFamilyGenders显示的结果是”factor”(因子)。”因子”是R的一个专业术语，是一类特殊类型的标签，用于识别和管理观测值。R按照字母顺序排列呈现开头部分少许的观测值（由于例子中的数据框比较小，现在呈现的是数据框内所有的观测值。）变量myFamilyGenders一共有两个水平，表示这个变量一共有两个选项：”female”和”male”。R会分配一个从1开始的数字给每个水平。所以，在这个例子中，1表示观测值”female”，2表示观测值”male”（因为female比male先出现在字母表，所以Female是第一个因子标签表示为1。）如果仔细思考的话，你会产生这个的疑问为什么我们输入一些字符串文本例如”male”但是R会将字符串文本转换成为数字并称之为”因子”。这是由于统计的起源。多年来，研究人员习惯将实验组称之为”Exp”,对照组称之为”Ctl”,不使用文本字符串以外的其他标签。因此，R假定，当你输入一些字符串的时候，例如”male”，你想表达的是一个组的标签，R会将”male”当做因子的一个水平，除非告诉R你不想将字符串转化为水平。如果你不想将字符串转化为水平，可以使用 <code>data.frame()</code>函数的一个选项： <code>stringsAsFactors=FALSE</code>。我们之后会深入研究选项和默认值。</p>
<p>这个真的是很复杂。相比之下，两个数值变量myFamilyAges和myFamilyWeights就简单地多了。我们可以看到冒号后面的数据类型是“num”(数值)和开头部分少许的观测值：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myFamilyNames&#60;-c(&#34;Dad&#34;,&#34;Mom&#34;,&#34;Sis&#34;,&#34;Bro&#34;,&#34;Dog&#34;)&#10;myFamilyAges&#60;-c(43,42,12,8,5)&#10;myFamilyGenders&#60;-c(&#34;Male&#34;,&#34;Female&#34;,&#34;Female&#34;,&#34;Male&#34;,&#34;Female&#34;)&#10;myFamilyWeights&#60;-c(188,136,83,61,44)&#10;myFamily&#60;-data.frame(myFamilyNames,myFamilyAges,myFamilyGenders,myFamilyWeights)&#10;str(myFamily)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ myFamilyAges   : num  43 42 12 8 5</span><br></pre></td></tr></table></figure>
<p>综合所有的输出结果，我们得到了数据框myFamily的详尽信息，同时可以使用这些信息做一些深入的分析。综合上述信息可知，R使用一些难懂的标签和转化规则。R是为专业人员设计的而不是为业余人员设计的，所以我们要好好学习，早日成为专业人员。</p>
<p>接下来，我们要研究另一个非常有用的函数 <code>summary()</code>. <code>summary()</code>函数和 <code>str()</code>所呈现的信息有共同点，但是<code>summary()</code>会提供更多的信息，特别对数值型变量。下面是我们所得的：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myFamilyNames&#60;-c(&#34;Dad&#34;,&#34;Mom&#34;,&#34;Sis&#34;,&#34;Bro&#34;,&#34;Dog&#34;)&#10;myFamilyAges&#60;-c(43,42,12,8,5)&#10;myFamilyGenders&#60;-c(&#34;Male&#34;,&#34;Female&#34;,&#34;Female&#34;,&#34;Male&#34;,&#34;Female&#34;)&#10;myFamilyWeights&#60;-c(188,136,83,61,44)&#10;myFamily&#60;-data.frame(myFamilyNames,myFamilyAges,myFamilyGenders,myFamilyWeights)&#10;summary(myFamily)</span><br></pre></td></tr></table></figure>
<p>为了更好地展示输出结果，这些列做了一定的调整。列/变量的名字显示了关于这列的信息，每一格所涵盖的信息都是独立于其他的。（所以是没有任何意义的。例如，”Bro:1”和”Min.”在同一行输出）。值得注意的是，<code>str()</code>输出结果有很大不同，取决于我们所说的因子，例如myFamilyNames和myFamilyGenders，和数值变量如myFamilyAges和myFamilyWeights。因子所在的列列出了水平的名称和观测值出现的次数。例如，在myFamilyGenders列中有3个女性和2个男性。相反，在数值型变量，我们得到5个不同的分位数来总结这个变量。下面是这个五个分位数的介绍：</p>
<ul>
<li>“Min”(最小值)指的是观测值中的最小值。在这个数据框中，5是狗狗的年纪，也是家庭成员中年纪最小的成员。</li>
<li>“1st Qu.” (第一四分位数)指的是第一个四分之一组的上限值。如果我们观测所有的观测值，并将它们按年纪大小（或者体重轻重）排序分成四组，每一组都含有相同个数的观测值。</li>
</ul>
<table>
<thead>
<tr>
<th>第一四分位数</th>
<th>第二四分位数</th>
<th>第三四分位数</th>
<th>第四四分位数</th>
</tr>
</thead>
<tbody>
<tr>
<td>最小25%的观测值</td>
<td>小于中位数25%的观测值</td>
<td>大于中位数25%的观测值</td>
<td>大于中位数25%的观测值</td>
</tr>
</tbody>
</table>
<p>就像数轴一样，最小的观测值在左边最大的观测值在最右边。我们看一下myFamilyAges 最左边这组（包含了四分之一观测值），它的下限是5（狗狗的年龄），它的上限是8（哥哥的年龄）。所以年龄或其他变量的”第一个四分位数”值是区分第一个四分之一组和其他四分之一组的值。值得注意的是，如果观测值的个数不能被四整除，这个值是一个近似值。</p>
<ul>
<li><p>“Median”(中位数)指的是将所有观测值平均分为两部分的值，即有一半的观测值大于中位数，另一半观测值小于中位数。如果在深入思考一下，中位数也是区分第二个四分之一组和第三个四分之一组的值。</p>
</li>
<li><p>“Mean” (平均值)如之前所学的是所有观测值的平均值。例如，这个家庭的平均年龄是22岁。</p>
</li>
<li><p>“3rd Qu.” 是第三四分位数。如果你还记得第一四分位数和中位数，那第三四分位数是区分第三个四分之一组和第四个四分之一组的值。你或许会对这些分位数产生疑惑，他们为什么有用。统计学家很喜欢这些，因为他们可以初步展现数据的分布情况。大家都有排序或分割东西的经历，如分披萨，理牌，给队员分组。对大多数人来说，已知四个相等大小的组，知道需要多大年纪多少体重（或者其他变量）可以进入下一个组是很有用的信息。</p>
</li>
<li><p>最后，”Max” (最大值)是观测值中最大的值。例如，在这个数据框中父亲的体重是最大的，有188.看上去是个比较苗条的人。</p>
</li>
</ul>
<p>本章结束前的最后一点：如何获取存储在新数据框内的变量。R使用向量列表存储在数据框内，我们可以使用数据框的名字和向量的名字和”$”符合将两者相关联起来，例如：</p>
<pre><code class="{r,echo=c(6)，prompt=TRUE}">myFamilyNames&lt;-c(&quot;Dad&quot;,&quot;Mom&quot;,&quot;Sis&quot;,&quot;Bro&quot;,&quot;Dog&quot;)
myFamilyAges&lt;-c(43,42,12,8,5)
myFamilyGenders&lt;-c(&quot;Male&quot;,&quot;Female&quot;,&quot;Female&quot;,&quot;Male&quot;,&quot;Female&quot;)
myFamilyWeights&lt;-c(188,136,83,61,44)
myFamily&lt;-data.frame(myFamilyNames,myFamilyAges,myFamilyGenders,myFamilyWeights)
myFamily$myFamilyAges
</code></pre>
<p>如果你疑惑我们为什么需要输入如此长一大串，还需要<code>$</code>符号加在两个名字中间，我们可以像先前建立数据框一样直接输入”myFamilyAges”.接下来是值得指出的，当我们创建myFamily数据框时，我们从每个向量中都复制了所有信息存储到新的空间中。因此，现在我们创建了”myFamily”数据框，myFamily$myFamilyAges实际上指的是完全不同的向量值（虽然现在还是相同的）。你可以自己尝试一下，试着加上一些数据到原始的向量内，myFamilyAges：</p>
<pre><code class="{r,prompt=TRUE}">myFamilyAges&lt;-c(myFamilyAges,11)
myFamilyAges
myFamily$myFamilyAges
</code></pre>
<p>我们看一下上面五行信息。第一行中我们使用<code>c()</code>命令在原始的年龄数据中增加了一个数值11，存储在myFamilyAges中（我们或许领养了一只老猫到家中）。第二行，我们命令R输出myFamilyAges向量中的值。第三行，R输出了原先的五个数值和新加入的数值11。我们命令R输出myFamil$myFamilyAges,但是，R只输出了原先的五个数值。这个表明数据框内的列/向量数值已经与之前单独的向量数据完全不同了。所以我们要非常小心，如果我们建立新的数据框用于后续的分析，那在分析时避免因使用原始数据集而出错。</p>
<p>下面是继上面问题而引申的。我们现在有一个很好的数据框，包含了5个观测值和4个变量。这是一个矩形数据集，正如本章开头所述。如果我们在一个变量中新加入一个数值，如下：</p>
<pre><code class="{r,eval=FALSE，prompt=TRUE}">myFamily$myFamilyAges&lt;-c(myFamily$myFamilyAges,11)
</code></pre>
<p>如果运行这条命令，我会有一个很诡异的情况：数据框中的myFamilyAges变量会比其他变量多一个观测值，这不在是一个完美的矩形。试一试这条命令，看看会有什么发生。这个结果阐明了R是怎样处理类似情况的。</p>
<p>因此我们从这一章学到了哪些新技术新知识呢？下面是本章的总结：</p>
<h4 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://en.wikipedia.org/wiki/Central_tendency" target="_blank" rel="external">http://en.wikipedia.org/wiki/Central_tendency</a></p>
<p><a href="http://en.wikipedia.org/wiki/Median" target="_blank" rel="external">http://en.wikipedia.org/wiki/Median</a></p>
<p><a href="http://en.wikipedia.org/wiki/Relational_model" target="_blank" rel="external">http://en.wikipedia.org/wiki/Relational_model</a></p>
<p><a href="http://msenux.redwoods.edu/math/R/dataframe.php" target="_blank" rel="external">http://msenux.redwoods.edu/math/R/dataframe.php</a></p>
<p><a href="http://stat.ethz.ch/R-manual/R-devel/library/base/html/data.frame.html" target="_blank" rel="external">http://stat.ethz.ch/R-manual/R-devel/library/base/html/data.frame.html</a></p>
<p><a href="http://www.burns-stat.com/pages/Tutor/hints_R_begin.html" target="_blank" rel="external">http://www.burns-stat.com/pages/Tutor/hints_R_begin.html</a></p>
<p><a href="http://msenux.redwoods.edu/math/R/dataframe.php" target="_blank" rel="external">http://msenux.redwoods.edu/math/R/dataframe.php</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/数据科学/">数据科学</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Introduction-to-data-science/">Introduction to data science</a><a href="/tags/数据科学/">数据科学</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/08/17/2014-8-data-science-chp5-row-col-2/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/08/17/2014-8-data-science-chp5-row-col-2/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/08/17/2014-8-data-science-chp5-row-col-1/" title="数据科学(5)-行与列-1" itemprop="url">数据科学(5)-行与列-1</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="中继点" target="_blank" itemprop="author">中继点</a>
		
  <p class="article-time">
    <time datetime="2014-08-17T03:06:44.000Z" itemprop="datePublished"> 發表於 2014 Aug 17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本文为<strong>Introduction to Data Science</strong>一书的翻译，由网友义务完成，了解参加翻译的网友，请点击<a href="https://github.com/johnstart/data-science/blob/gh-pages/task.md" target="_blank" rel="external">这里</a>，如果要加入我们请加入qq群171546473,了解翻译规则点击<a href="https://github.com/johnstart/data-science/blob/gh-pages/index.md" target="_blank" rel="external">这里</a></p>
<h1 id="u7B2C_u4E94_u7AE0__u884C_u4E0E_u5217"><a href="#u7B2C_u4E94_u7AE0__u884C_u4E0E_u5217" class="headerlink" title="第五章     行与列"></a>第五章     行与列</h1><hr>
<center><img src="/img/datascience/f.png" alt="f"></center>

<hr>
<p>###表现数据的最基础和应用最广的方法之一就是使用行与列，每一行是一个案例或是实例，每一列是一个变量或是属性。尽管电子表格并不常常提到案例或变量的概念，但是大部分电子表格依然用行与列的形式来组织数据。R语言中行与列的的形式可以通过数据框这种对象来表现出来。</p>
<p>我们生活在一个三维的世界中，在这个世界里，麦片盒有着高度，宽度，深度。然而一个可悲的事实是，现实生活中也存在着诸如纸张，黑板，白色写字板和电脑屏幕这些只有二维的物体。其结果是，大部分统计学家，会计，计算机科学家和与大量数据打交道的工程师倾向于用行与列的形式来组织数据。</p>
<p>这种形式除了使得用数字填写一张矩形纸片的过程变得容易之外，再无更好的使用理由。行与列可以通过你想要的任意方式来组织数据。但是最常见的方式是，行表示案例或实例，列则表示属性或是变量。我们来看下这种的行与列的二维呈现形式。</p>
<center><img src="/img/datascience/table1.png" alt="table1"></center>

<p>一目了然，对吧？最上面粗体字那行并不是数据的一部分，它包含了属性或变量的名称。注意，计算机科学家喜欢叫它们为属性，而统计学家则喜欢叫它们为变量，这两种术语都行。比如说，年龄是每个活物都具有的一个属性，你可以用分，时，日，月，年，或者其它的时间计量单位来度量它。在上表中，我们用年来度量年龄这个属性。从技术上讲，在顶行的变量名称是元数据，或者你也可以把它当作数据的数据。试想一下，如果没有元数据，凭空去理解上面这张表中的数据是很难的。元数据有很多种不同的类型，变量名称只是元数据类型中的一种简单形式而已。</p>
<p>如果你无视包含有变量名称的顶行，那么剩下的每一行则是一个案例或实例。再次提醒一下，计算机学家可能会称它为实例，统计学家则可能会称它为案例，但是两种术语都行。重要的是，每一行对应着一个实际事物。在这个例子中，我们的所有的事物都是来自于同一个家庭的生物。你可以把NAME列看成一个案例标签列，每个标签对应着且只对应着我们数据中的唯一一行。当你在处理大型数据集的时候，大部分情况下，案例标签都是数字，每个案例的数字都是独一无二的（换句话说，相同的数字不会在两行或者两行以上中出现）。计算机学家有时把这列独一无二的数字称为键，键是一个很有用的东西，尤其是在从不同的数据源中匹配事物时，我们稍后再讨论这个问题。现在，只要关注这个信息，即虽然他们都是男性,但”Dad”行明显不同于”BRO”行。即使我们再加一个”Uncle”行，与”Dad”有着相同的年龄，性别，体重，我们仍然能够能把这两行分开，因为一行有着”Dad”的名称，而另一行的名称则为”Uncle”。</p>
<p>另一个重要的提示：每一列都包含着相同类型的数据。举例来说，年龄这列都是数字。这列中并没有诸如“老”或者“年轻”这样的词汇。这是一种使事物有组织的一种真正有价值的方式。毕竟，如果这列有一些诸如老或年轻之类的小段文本的话，我们在年龄这列不能运行mean()这个函数。作一个相关的提醒，每个元胞（行与列的交集处，举例说，姐姐的年龄）包含着一条信息。尽管电子表或者字处理程序可能允许我们将两个或两个以上事物放到元胞中，但实数处理程序却不会允许我们这样的行为。最后，我们可以看到每列有着相同的数字输入，以致于整体形成了一个漂亮的矩形。统计学家和处理大型数据库的那些人在处理数据集的时候，他们期望能见到这种矩形的组织结构。</p>
<p>现在我们来看下，怎样把数据以行与列的形式输入R中。你在R中很快就可以学到的一件事是，实现一个目标往往有多种方法。有时，最快或者最有效的方法并不是最容易理解的方法。在此例中，我们将逐列建立每列，然后将它们合并于一个数据框中。这种方法有一些费工费力，同时并不是我们处理一个数据集的常规方法，然而，这种方法易于理解。首先，我们运行下列命令来创建列的名称:</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myFamilyNames &lt;- c(<span class="string">"Dad"</span>,<span class="string">"Mom"</span>,<span class="string">"Sis"</span>,<span class="string">"Bro"</span>,<span class="string">"Dog"</span>)</span><br></pre></td></tr></table></figure>
<p>你可能要注意的一件事是每个名字都被放到双引号之中。这个双引号的意思是你给了R一个信号，表示你想要把双引号中的内容看作一个字符串，而非存储地点的名字。如果我们要求R使用Dad而非“Dad”,它将会寻找一个叫Dad的存储位置（即一个数据对象）。需要注意的另一件事情是双引号之外不同的值之间用逗号分隔开。如果你写了一个普通的句子，那么这件事无关紧要，但是对于计算机编程来说，逗号只有不在引号之间的时候，它才能分开不同的值。一旦你键入上面那行代码，随后要记得输入下面这行命令来检查myFamilyNames的内容</p>
<pre><code>&gt; myFamilyNames
</code></pre><p>输出应如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] &#34;Dad&#34; &#34;Mom&#34; &#34;Sis&#34; &#34;Bro&#34; &#34;Dog&#34;</span><br></pre></td></tr></table></figure>
<p>下一步，你可以建立一个关于家庭成员年龄的向量，就像这样：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myFamilyAges &lt;- c(<span class="number">43</span>, <span class="number">42</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>注意，这个命令同我们先前几章用到的命令是完全相同的。如果你一直在运行R的话，那么你现在无需再次输入这行命令。因为myFamilyAges一直都在。实际上，如果你关闭了R，当处理完先前几章的例子后，你关闭了R， 系统提示“保存工作区”。如果你这样做了，R会存储所有的你在先前几节使用的数据对象。你可以在一个空白的命令行上输入myFamilyAges来检查。输出应如下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myFamilyAges</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 43 42 12  8  5</span><br></pre></td></tr></table></figure>
<p>嘿，现在你已经使用c()函数和赋值箭头来为myFamilyNames和<br>myFamilyAges来赋值。如果你在这章的先前部分看到这张数据表。你应该能够想出创建myFamilyGenders和myFamilyWeights的命令语句。如果你遇到了困难，那么你也可以在下一页中找到相应的答案。但是你在翻到下一页之前，还是应该努力找出答案。在你键入命令来建立新的数据对象之后的每一个案例，你也应该在命令行中键入数据对象的名称以确保它看起来像那么回事。对于变量，每一个变量有五个值。两个变量是字符型数据，另两个变量则是整数型数据。以防你需要它们，下面给出这两个额外的命令语句：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myFamilyGenders &lt;- c(<span class="string">"Male"</span>,<span class="string">"Female"</span>,<span class="string">"Female"</span>,<span class="string">"Male"</span>,<span class="string">"Female"</span>)</span><br><span class="line"></span><br><span class="line">myFamilyWeights &lt;- c(<span class="number">188</span>,<span class="number">136</span>,<span class="number">83</span>,<span class="number">61</span>,<span class="number">44</span>)</span><br></pre></td></tr></table></figure>
<p>现在，我们来介绍一下数据框。在R中，数据框是一个列表(关于列的），列表中的每个元素都是一个向量。每个向量都具有相同的长度，这样我们才能让我们的漂亮矩形的行和列建立起来。一般每个向量也有它自己的名称。建立一个数据框的命令很简单：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myFamily &lt;- data.frame(myFamilyNames, + </span><br><span class="line">myFamilyAges, myFamilyGenders, myFamilyWeights)</span><br></pre></td></tr></table></figure>
<p>注意哦，上面这个命令有点略长，所以我们不得不把它断成两行<br>。第一行行尾的加号告诉R在处理命令前要等下一行的输入。当然了，如果你想的话，你可以把所有的命令都塞到一行中，但是这样做的话呢，就得把“+”去掉。无论如何，data.frame()函数可以把我们先前输入的四个向量变成一个数据框。当然我们也可以使用赋值箭头来生成一个新的储存位置来放入数据框。这种新的数据对象就是我们所说的数据框，它的名称叫做myFamily。一旦你输入了上述命令，可以在命令行中输入myFamily来得到一个数据框内容的回馈。你看到的输出应如下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myFamily</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##   myFamilyNames X.myFamilyAges myFamilyGenders myFamilyWeights&#10;## 1           Dad             43            Male             188&#10;## 2           Mom             42          Female             136&#10;## 3           Sis             12          Female              83&#10;## 4           Bro              8            Male              61&#10;## 5           Dog              5          Female              44</span><br></pre></td></tr></table></figure>
<p>看起来不错哈。注意哦，R把行数（也就是那1，2，3，4，5）放在了我们数据每一行的前面。这不同于我们先前在[]括号中看到的数字，因为这些数字是数据框中的实际“索引”。换句话来说，这些行号是R用来追踪某一特定的数据在哪一行。</p>
<p>像这样的小型数据集，只有五行，对所有的数据进行一览也很简单。但是当我们处理一个大型数据集的时候，这种方法也不实际。我们需要其他的方法来总结这些数据集。第一种方法是用来来显示结构的类型，结构就是是R用来存储数据对象的</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str(myFamily)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## &#39;data.frame&#39;:&#9;5 obs. of  4 variables:&#10;##  $ myFamilyNames  : Factor w/ 5 levels &#34;Bro&#34;,&#34;Dad&#34;,&#34;Dog&#34;,..: 2 4 5 1 3&#10;##  $ X.myFamilyAges : num  43 42 12 8 5&#10;##  $ myFamilyGenders: Factor w/ 2 levels &#34;Female&#34;,&#34;Male&#34;: 2 1 1 2 1&#10;##  $ myFamilyWeights: num  188 136 83 61 44</span><br></pre></td></tr></table></figure>
<p>在此献上首次提醒，这个例子表明，命令提示”&gt;”是用来区分命令与其后的输出结果的。你无需键入这个符号，当R准备接受新的输入时，它会自动产生这个符号。这本书从现在开始的例子中，R命令将与输出结果混合在一起，所以哦，要时刻注意”&gt;”这个符号，因为在这个符号之后的命令才是你所要键入的。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/数据科学/">数据科学</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Introduction-to-data-science/">Introduction to data science</a><a href="/tags/数据科学/">数据科学</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/08/17/2014-8-data-science-chp5-row-col-1/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/08/17/2014-8-data-science-chp5-row-col-1/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/08/16/2014-8-data-science-chp4-follow-the-data/" title="数据科学(4)-跟着数据走" itemprop="url">数据科学(4)-跟着数据走</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="中继点" target="_blank" itemprop="author">中继点</a>
		
  <p class="article-time">
    <time datetime="2014-08-16T12:39:34.000Z" itemprop="datePublished"> 發表於 2014 Aug 16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本文为<strong>Introduction to Data Science</strong>一书的翻译，由网友义务完成，了解参加翻译的网友，请点击<a href="https://github.com/johnstart/data-science/blob/gh-pages/task.md" target="_blank" rel="external">这里</a>，如果要加入我们请加入qq群171546473,了解翻译规则点击<a href="https://github.com/johnstart/data-science/blob/gh-pages/index.md" target="_blank" rel="external">这里</a></p>
<h1 id="u7B2C_u56DB_u7AE0__u8DDF_u7740_u6570_u636E_u8D70"><a href="#u7B2C_u56DB_u7AE0__u8DDF_u7740_u6570_u636E_u8D70" class="headerlink" title="第四章 跟着数据走"></a>第四章 跟着数据走</h1><h4 id="u4FA6_u63A2_u8FD9_u884C_u6709_u53E5_u8C1A_u8BED_u201C_u8DDF_u7740_u94B1_u8D70_u3002_u201D_u5728_u6570_u636E_u79D1_u5B66_uFF0C_u6210_u529F_u7684_u4E00_u4E2A_u5173_u952E_u662F_u201C_u8DDF_u7740_u6570_u636E_u8D70_u3002_u201D_u5728_u591A_u6570_u60C5_u5F62_uFF0C_u4E00_u4E2A_u6570_u636E_u79D1_u5B66_u5BB6_u4E0D_u4F1A_u53BB_u4ECE_u65E0_u5230_u6709_u7684_u8BBE_u8BA1_u4E00_u4E2A_u4FE1_u606F_u7CFB_u7EDF_u3002_u53CD_u800C_uFF0C_u5728_u4E00_u4E9B_u6216_u8005_u8BB8_u591A_u5DF2_u6709_u7684_u7CFB_u7EDF_u4E2D_uFF0C_u5C31_u6709_u6570_u636E_uFF1B_u6570_u636E_u79D1_u5B66_u5BB6_u9762_u4E34_u7684_u5F88_u5927_u4E00_u90E8_u5206_u6311_u6218_u5C31_u662F_u5982_u4F55_u6574_u5408_u8FD9_u4E9B_u7CFB_u7EDF_u3002"><a href="#u4FA6_u63A2_u8FD9_u884C_u6709_u53E5_u8C1A_u8BED_u201C_u8DDF_u7740_u94B1_u8D70_u3002_u201D_u5728_u6570_u636E_u79D1_u5B66_uFF0C_u6210_u529F_u7684_u4E00_u4E2A_u5173_u952E_u662F_u201C_u8DDF_u7740_u6570_u636E_u8D70_u3002_u201D_u5728_u591A_u6570_u60C5_u5F62_uFF0C_u4E00_u4E2A_u6570_u636E_u79D1_u5B66_u5BB6_u4E0D_u4F1A_u53BB_u4ECE_u65E0_u5230_u6709_u7684_u8BBE_u8BA1_u4E00_u4E2A_u4FE1_u606F_u7CFB_u7EDF_u3002_u53CD_u800C_uFF0C_u5728_u4E00_u4E9B_u6216_u8005_u8BB8_u591A_u5DF2_u6709_u7684_u7CFB_u7EDF_u4E2D_uFF0C_u5C31_u6709_u6570_u636E_uFF1B_u6570_u636E_u79D1_u5B66_u5BB6_u9762_u4E34_u7684_u5F88_u5927_u4E00_u90E8_u5206_u6311_u6218_u5C31_u662F_u5982_u4F55_u6574_u5408_u8FD9_u4E9B_u7CFB_u7EDF_u3002" class="headerlink" title="侦探这行有句谚语“跟着钱走。”在数据科学，成功的一个关键是“跟着数据走。”在多数情形，一个数据科学家不会去从无到有的设计一个信息系统。反而，在一些或者许多已有的系统中，就有数据；数据科学家面临的很大一部分挑战就是如何整合这些系统。"></a>侦探这行有句谚语“跟着钱走。”在数据科学，成功的一个关键是“跟着数据走。”在多数情形，一个数据科学家不会去从无到有的设计一个信息系统。反而，在一些或者许多已有的系统中，就有数据；数据科学家面临的很大一部分挑战就是如何整合这些系统。</h4><p>我讨厌唠叨，但是你最近做过体检吗？如果你去看过医生，不管是为什么原因，你可能会记得医生的办公室被数据湮没了。首先，医生有大量的数字传感器，从血压监测器到超声波机器应有尽有，所有这些都会产生大量的数据。也许，对于现在引起广泛关注的关于健康保险的争论，金融和保险数据的一个很重要的出发点就可以是医生的办公室。美国医疗保健体系有一个著名的“特点”，就是我们的医疗保健服务的普遍做法是：按照流程付钱。当你在医生的办公室经历一次“流程”时，不管是一次咨询，一次检查，一次化验，或者其它什么，这是一系列会产生深远结果的数据事件的开端。</p>
<p>如果你的医生是典型的医生，这些事件的起点是一张纸质的表格。你曾经详细的看过它们吗？这些表格上多半填的是由流程和代码组成的矩阵。虽然许多设备先进的地方可能会用平板电脑或者其它电脑将这些表格数字化，但是纸质表格仍然是普遍存在的。如果要进行保单赔付或者付款，纸质表格的数据会被输进一个系统，这个过程会在医生办公室或者在一个外包公司里进行。</p>
<p>这些流程数据去哪儿了呢？哪些其它种类的数据（比如病人账号信息）可以在接下来的流程中和它们连接？这些连在一起的数据形成了什么样的网络？或者它们的安全性如何？在这些数据到达保险公司之前，处理数据要多少步骤？保险公司在考虑理赔之前是怎样处理和分析数据的？当保险公司的系统同意理赔之后钱是怎么转账的？这些问题仅仅是从表面上考虑的：还有几十种上百种处理步骤我们连想都想不到。</p>
<p>我们很容易从这个例子中看到，根本不可能把已有的系统扔掉，然后去设计一个更好的或者至少更标准化的系统。但是如果你的工作是提高系统的效率，或者审查保险理赔以确保它们和保险记录相符，或者使用数据去探测和预测疾病的爆发和流行，或者给顾客提供反馈告诉他们一些流程的期望花费是多少，那么你该怎么办呢？</p>
<p>你的项目的关键的出发点在于要跟着数据走。你应该像一个侦探一样，充分的弄清楚细节，包括内容，格式，发送人，接收人，转账方法，仓库，还有过程中每一步数据的使用者以及进行数据处理和存储的组织。</p>
<p>幸运的是，已经有一个广泛的研究和实践领域叫做“数据模型”，它给出理论，策略和工具以帮助实现数据科学家“跟着数据走”的目标。这些想法开始于70年代早期，是由计算机科学家Ed Yourdon提出的称之为数据流程图方法。一个更现代的方法叫做实体关系模型，它和建立关系型数据库的方法有很强的关系。专家们使用这个模型发明了实体关系图（ERDs）来描述一个系统的结构和数据的移动。</p>
<p>实体关系模型在不同层面出现，从抽象概念侧面到实际存储层面。在概念层面一个实体是一个对象或者东西，通常是真实世界中存在的东西。在医生办公室的例子中，一个重要的“对象”是病人。另一个实体是医生。病人和医生通过一个关系相连：在现代医疗保健术语中这是“供应”关系。如果病人是X先生，医生是Y医生，供应关系提供一个双向的连接：</p>
<ul>
<li>Y医生是X先生的提供者</li>
<li>X先生的提供者是Y医生</li>
</ul>
<p>自然的，有一些数据可以描述X先生：名字，地址，年龄，等等。同样的，也有描述Y医生的数据：医龄，专业领域，资质证书，执照。重要的是，有一大块数据用来描述X和Y的联系，这就是关系。</p>
<p>建立一个ERD需要调查和枚举所有的实体，比如病人和医生，还有它们之间可能存在的所有的关系。就像本章的开始提到的，这可能发生在许多组织上（比如，医生办公室和保险公司），这取决于信息系统被设计出来的目标。最终，ERDs必须足够详细，这样它们才能被用作一个数据库的物理存储的说明书。</p>
<p>在医疗保健这样的应用领域中，如何设计数据有太多不同的选择了，以至于建立一个好用的系统要求一些经验和一些“艺术”。“艺术”一部分体现在理解用户的现有信息需求以及这些需求在未来预期的变化。如果一个组织在重新设计一个系统，补充一个系统，或者设计新系统，他们这样做是为了未来的利益。这个利益可能是更高的效益，错误/不精确的减少，或者增强的信息能力带来的做出新产品或新服务的可能性。</p>
<p>不管目标是什么，数据科学家现在在方法上面临重要且困难的挑战，包括纸质表格和手工数据录入，想象一下将来的方法。跟着数据走！</p>
<p>在下一章，我们介绍组织数据的最普遍也是最有用的方法，叫做矩形结构，它包含行和列。这种把数据布置成矩形的做法出现在电子表格和数据库，被很多应用所使用。理解这些行和列如何组织的，这是数据科学中多数任务的关键。</p>
<h4 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://en.wikipedia.org/wiki/Data_modeling" target="_blank" rel="external">http://en.wikipedia.org/wiki/Data_modeling</a></p>
<p><a href="http://en.wikipedia.org/wiki/Entity-relationship_diagram" target="_blank" rel="external">http://en.wikipedia.org/wiki/Entity-relationship_diagram</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/数据科学/">数据科学</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Introduction-to-data-science/">Introduction to data science</a><a href="/tags/数据科学/">数据科学</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/08/16/2014-8-data-science-chp4-follow-the-data/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/08/16/2014-8-data-science-chp4-follow-the-data/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/08/16/2014-8-data-science-chap3_GettingStartedWithR_full/" title="数据科学(3)-R入门" itemprop="url">数据科学(3)-R入门</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="中继点" target="_blank" itemprop="author">中继点</a>
		
  <p class="article-time">
    <time datetime="2014-08-16T12:35:03.000Z" itemprop="datePublished"> 發表於 2014 Aug 16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本文为<strong>Introduction to Data Science</strong>一书的翻译，由网友义务完成，了解参加翻译的网友，请点击<a href="https://github.com/johnstart/data-science/blob/gh-pages/task.md" target="_blank" rel="external">这里</a>，如果要加入我们请加入qq群171546473,了解翻译规则点击<a href="https://github.com/johnstart/data-science/blob/gh-pages/index.md" target="_blank" rel="external">这里</a></p>
<h1 id="u7B2C_u4E09_u7AE0_R_u5165_u95E8"><a href="#u7B2C_u4E09_u7AE0_R_u5165_u95E8" class="headerlink" title="第三章 R入门"></a>第三章 R入门</h1><center><img src="/img/datascience/chap3_01.JPG" alt="Alt text"></center><br>“R”是一个开源软件程序，由一群正在使用它的科学家，研究员和数据分析师们自愿服务来对它进行维护。“R”是免费下载和使用的，而且在线提供大量的建议和指导资源帮助用户学习R，这一点是非常好的，因为R是一个非常有力的和复杂的程序，现实中，它是一个专注于数据分析的功能全面的编程语言。<br><br><br>如果你对计算机，编程或者数据科学一无所知，那么欢迎来到这个令人兴奋的章节，这里能够帮你开启大门，认识到全宇宙中有史以来最有力的免费数据分析工具，不是说笑哦。反过来，如果你熟悉电子表格，统计分析或者会计软件，你可能会觉得这本书已经走向极端，永远不会恢复理智，而所有的这些对于用户接口设计来说都是有益的和正确的。这两个观点都是合理的。R这种开源的数据分析程序是非常有力的，灵活的和扩展性极强的（意味着人们可以很容易地为它创建新的性能）。同时，R是面向“命令行”的，就是说大量的工作和需求行为只需通过几个精心设计的命令便可以实现，其中的大部分命令是有技巧的（设计命令的标点和相关的规则是奏效的）。另外，当结果看起来有点奇怪时，R不能很正确地返回反馈或错误信息用以帮助用户修复错误或者找出问题所在。<br><br>但是还是有方法来对付这种疯狂的行为的。R作为一个教学工具的最大的一个优点是它透明度比较高。因为成功的学习者可定能够充分理解到“数据情况”是什么或者哪些R命令不能够工作。在电子表格当中，我们很容易键入大量的数和公式，比如 =FORECAST()，然后结果就会像魔法一般跳进格子里，无论这些数字或者公式有无意义。使用R，你必须理解你的数据，知道自己怎么利用这些数据，清楚这些数据时怎么被转化的，明白怎么查找问题。因为R是一门编程语言，它也会要求用户通过数据对象和能够应用到这些对象的方法，还有能够应用到这些方法的过程来思考问题。<br>在现代的编程语言当中有几个比较重要的隐喻，如果对软件编程，测试和集成到一个工作系统的过程没有一个基础的了解，没有数据科学家能够通往成功。R强大的扩展性能能够让志愿者们随时为它添加新的模块。R是首批集成直接从“推特”社交媒体平台提取数据的功能的分析程序。所以你可以确信下一代伟大的发展埋伏在数据的世界当中，在R社区当中的某个人开始为R所需要的模块开发新的“包”。最后，用R工作的人会慢慢体会到：R无所不能，它几乎能应用到任何其他语言和兼容其他平台。如果一个人掌握了R语言，那么他很容易就能掌握SAS(r);(统计编程语言)和SPSS(r);语法。（SAS和SPSS是两个目前最受欢迎的商业统计分析程序）。所以学校，老师和学生无需支付任何版权费便能学习到世上最强大的数据分析系统及其课程，无论你身处何地。但是它需要你有耐心，所以请你一定要坚持。<br><br>让我们开始吧。显然你需要一台计算机。如果你在使用平板电脑或智能手机，你可能想跳转到R-studio的章节，因为旧版R还没有支持在平板电脑上工作（但是有一个适合平板电脑的工作区叫做R-studio）。有少数人开始使用基于Web界面的R，像这个 <a href="http://dssm.unipa.it/R-php/R-php-1/R/" title="http://dssm.unipa.it/R-php/R-php-1/R/" target="_blank" rel="external">http://dssm.unipa.it/R-php/R-php-1/R/</a> -但是他们仍然在初始阶段。如果你的计算机装有Windows(r);, Mac-OSX(r);或者 Linux操作系统，你可以到这里下载R： <a href="http://cran.r-project.org/" title="http://cran.r-project.org/" target="_blank" rel="external">http://cran.r-project.org/</a>。下载并安装到你的电脑。如果在安装这个新软件的过程中你需要帮助，这里推荐一个非常有用的小册子，是Thomas P. Hogan著的，叫做：Bare Bones R: A Brief Introductory Guide，你可以自行购买或者从图书馆借阅。还有很多在线的网站能够给你提供帮助，虽然大多数都不是直接面向初学者的。我在谷歌输入“help installing R”，它返回了一些比较好的网站。在Windows下，一个对安装R有比较丰富的内容的网站是：&quot;readthedocs.org&quot;，你可以点击以下网址进入：<a href="http://tinyurl.com/872ngtt" title=" http://tinyurl.com/872ngtt" target="_blank" rel="external"> http://tinyurl.com/872ngtt</a>。<br><br><center><img src="/img/datascience/chap3_02.JPG" alt="Alt text"></center>

<p>对于Mac用户，可以看一下Jeremy Taylor在Vimeo.com的视频介绍：<a href="http://vimeo.com/36697971" title="http://vimeo.com/36697971" target="_blank" rel="external">http://vimeo.com/36697971</a>，这个视频既介绍了R在Mac上的初始化安装，也介绍了一些可选的步骤助于你的入门。Youtube上也提供了4个相关的视频教程，你课可以在搜索框输入“install R”试试。本章接下来的内容我们假设你已成功安装了R并且能像以上的截图一样运行在你的计算机上。（由于这个截图是在Mac上截下来的，所以如果你使用的是Windows或者Linux，那么截图看起来会有点不同的。）来玩一下吧，运行R你可以做的第一件事就是按一下颜色轮子来自定义R的面板颜色。以上截图中的R是使用了鲜艳的橙色作为背景色。截图上同时也展示了一些常用的命令，用于调出与R交互的一下比较基本的方法。注意到截图的底部的大于符号（“&gt;”），其实它是一个命令提示符&ndash;当R真正运行时，你在“&gt;”后面输入一些命令然后按回车建或返回键，这个命令就会被传递给R执行。当执行完成，返回的结果就会出现在“&gt;”之后，同时接着下一行另外一个命令提示符(“&gt;”)就会做好准备，接受你的下一个R命令。在截图当中，用户输入了1+1然后回车。世界各地的小学生都在利用1+1这条公式相互嘲笑各自的数学技巧，但R返回的结果并不是简单的2。如果你细心观察，你会发现在2之前还有一个括在中括号里的“1”，就是：[1]。这个[1]有什么作用呢？它是一个行标号，可以帮助追踪R显示的结果。仅仅显示一行结果是毫无意义的，但R就是喜欢做的更好，所以当我们深入学习R的时候，我们可以看到很多这样的行标号。</p>
<p>还记得在数据概述一章中关于家庭成员年龄的数据嘛？下面回顾一下：43,42，12，8,5，分别是爸爸，妈妈，姐姐，弟弟，以及宠物狗的年龄。我们曾经提到过，这组数据是一组形式相同的数据列表，即整数列。你可以确定这是一个整数列的原因是这些数字小数点后位数为零。在R中，我们可以通过”c()”这一命令来建立一个整数向量，如下图所示：</p>
<center><img src="/img/datascience/chap3_03.jpg" alt="Alt text"></center>


<p>上图是我们上次在R console中的操作截图。从现在开始,出于排版的考虑，我们仅列出相关命令及结果。上图中的第一行命令在前些章已经出现过：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c(<span class="number">43</span>, <span class="number">42</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>你可能已经注意到了，在命令的下面，R输出了相同的向量。行编号“[1]”之后，我们可以看到数列43,42,8,5。因为没有相应的存储命令，所以R会输出相同的信息.相比之下，请看另一条命令：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myFamilyAges &lt;- c(<span class="number">43</span>, <span class="number">42</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>但是，再次输入同一数列时，用“&lt;-”符号将其存储为“myFamilyAges”，R返回了一个空的命令提示符。这就是为什么第三行命令中要求显示“myFamilyAges”变量中包含哪些信息（黄色“&gt;”符号后面蓝色字体是需要键入的命令）。这是一个十分简单并且重要的命令。每当你想知道数据集的解构时，只要输入数据集名称，R便输出相应数据集。在下一条命令中，我们可以感受到R的用途：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(myFamilyAges)</span><br></pre></td></tr></table></figure>
<p>该命令使R对myFamilyAges变量中所有数字求和，即110（你可以用计算器检验）。虽然对家庭成员的年龄求和不是一个非常确切的例子，但是我们展示了你可以通过这样一条简短的命令减少计算量。在随后的一条命令中，我们想要知道所有年龄数据的均值（也就是非数据人员所说的平均数），结果显示为22岁。接下来的命令叫“range”，表示列表中的最低和最大年龄。最后，开个玩笑，我们来谈一下命令”fish(myFamilyAges).”几乎就像你期望的那样，R并没有fish()”函数，所以我们收到报错消息。这就提到了R的另一个重要原则：你可以随意进行尝试而不必担心造成破坏。如果R无法理解你想做的事情或者你没有写清楚自己想做的事情，R会提示出错并且在你输入新命令之前，它不会发生任何改变。本书在将来的章节会讨论的一些策略，使你可以解决这个问题并且懂得R如何明白你想做的事情</p>
<p>现在我们看一下存储单元。首先，你应该认真尝试一下电脑中记下的所有命令。你可以根据需要阅读相应的命令，但是全部尝试一下会学到更多。再者，如果你尝试了这些页面中的命令但是它们没有起作用，你应该找出原因。由于R对于命令的类型非常严格，所以从检查拼写开始。R语言是区分大小写的，“myFamily”与“myfamilyages”是有区别的。验证拼写后如果还是报错，尝试一下使用在线帮助： <a href="http://stackoverflow.com" target="_blank" rel="external">http://stackoverflow.com</a>, <a href="https://stat.ethz.ch" target="_blank" rel="external">https://stat.ethz.ch</a>,以及<a href="http://www.statmethods.net/" target="_blank" rel="external">http://www.statmethods.net/</a>.检查出错误的原因往往会让你对R的学习更有帮助。第三，你应该花一点时间试验一下学到的新的命令集。比如输入：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myRange &lt;- range(myFamilyAges)</span><br></pre></td></tr></table></figure>
<p>输入这个命令之后会发生什么呢？然后在另一个命令行里输入”myRange”来输出存储了什么内容？然后思考一下原因并且用同样的方法尝试一下别的试验。尝试越多，学到的知识越多。有些好东西就是试验得到的。在这一点上，即使只尝试了一些命令，你也已经知道关于R的如下事情：</p>
<p>-怎样在电脑上安装R并且运行。<br>-怎样在R控制台输入指令。<br>-“c()”函数的使用。记住”c()”代表连接，就是将事物联系到一起。可以在括号里输入一系列事情，用逗号隔开。<br>-向量可以通过使用分配箭头存储在已经命名的存储单元中（左箭头和破折号组成，比如”&lt;-“）。<br>-可以在命令行输入存储的数据对象的名字来生成报告。<br>-可以对一组数据运行函数，比如mean()，将它们转换成别的东西（mean()计算均值，这是最基础的数值）<br>-R中包括了sum(), mean(), 和range()，但是不包括fish()</p>
<p>本章将学习向前推进了一些，开始针对文本进行运算，学习如何将家庭年龄表与家庭成员名字以及他们的其他信息结合起来。</p>
<h2 id="u7AE0_u8282_u96BE_u70B9"><a href="#u7AE0_u8282_u96BE_u70B9" class="headerlink" title="章节难点"></a>章节难点</h2><p>========================================================</p>
<p>使用逻辑和在线资源帮助学习，学习使用c()函数将家庭成员年龄增加到“我的家庭年龄”向量后面。</p>
<h3 id="u8D44_u6E90"><a href="#u8D44_u6E90" class="headerlink" title="资源"></a>资源</h3><p>========================================================</p>
<p><a href="http://a-little-book-of-r-for-biomedical-statistics.readthedocs.org/en/latest/src/installr.html" target="_blank" rel="external">http://a-little-book-of-r-for-biomedical-statistics.readthedocs.org/en/latest/src/installr.html</a></p>
<p><a href="http://cran.r-project.org/" target="_blank" rel="external">http://cran.r-project.org/</a></p>
<p><a href="http://dssm.unipa.it/R-php/R-php-1/R/" target="_blank" rel="external">http://dssm.unipa.it/R-php/R-php-1/R/</a> (UNIPA experimental web interface to R)</p>
<p><a href="http://en.wikibooks.org/wiki/R_Programming" target="_blank" rel="external">http://en.wikibooks.org/wiki/R_Programming</a></p>
<p><a href="https://plus.google.com/u/0/104922476697914343874/posts" target="_blank" rel="external">https://plus.google.com/u/0/104922476697914343874/posts</a> (Jeremy Taylor’s blog: Stats Make Me Cry)</p>
<p><a href="http://stackoverflow.com" target="_blank" rel="external">http://stackoverflow.com</a></p>
<p><a href="https://stat.ethz.ch" target="_blank" rel="external">https://stat.ethz.ch</a> </p>
<p><a href="http://www.statmethods.net/" target="_blank" rel="external">http://www.statmethods.net/</a></p>
<h6 id="u81EA_u6211_u6D4B_u8BC4"><a href="#u81EA_u6211_u6D4B_u8BC4" class="headerlink" title="自我测评"></a>自我测评</h6><hr>
<h3 id="u56DE_u987E3-1_R_u5165_u95E8"><a href="#u56DE_u987E3-1_R_u5165_u95E8" class="headerlink" title="回顾3.1 R入门"></a>回顾3.1 R入门</h3><hr>
<ul>
<li>问题1 R的版权费是多少？</li>
<li><ul>
<li>A R是免费的  √</li>
<li>B 在iTunes商店中售价99美分  </li>
<li>C 10美元</li>
<li>D 100美元</li>
</ul>
</li>
</ul>
<hr>
<h6 id="u672C_u7AE0_u8282_u4E2D_u7528_u5230_u7684R_u51FD_u6570"><a href="#u672C_u7AE0_u8282_u4E2D_u7528_u5230_u7684R_u51FD_u6570" class="headerlink" title="本章节中用到的R函数"></a>本章节中用到的R函数</h6><pre><code>c()            连接数据元素

&lt;-             赋值箭头

sum()         求和

range()        求最值

mean()        求平均值
</code></pre>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/数据科学/">数据科学</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Introduction-to-data-science/">Introduction to data science</a><a href="/tags/数据科学/">数据科学</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/08/16/2014-8-data-science-chap3_GettingStartedWithR_full/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/08/16/2014-8-data-science-chap3_GettingStartedWithR_full/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/08/16/2014-8-data-science-chap2-Identifying-Data-Problems/" title="数据科学(2)-识别数据问题" itemprop="url">数据科学(2)-识别数据问题</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="中继点" target="_blank" itemprop="author">中继点</a>
		
  <p class="article-time">
    <time datetime="2014-08-16T12:32:58.000Z" itemprop="datePublished"> 發表於 2014 Aug 16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本文为<strong>Introduction to Data Science</strong>一书的翻译，由网友义务完成，了解参加翻译的网友，请点击<a href="https://github.com/johnstart/data-science/blob/gh-pages/task.md" target="_blank" rel="external">这里</a>，如果要加入我们请加入qq群171546473,了解翻译规则点击<a href="https://github.com/johnstart/data-science/blob/gh-pages/index.md" target="_blank" rel="external">这里</a></p>
<p>#2.第二章 识别数据问题</p>
<p><img src="/img/datascience/2-header.jpg" alt=""></p>
<p><strong>数据科学与其他领域诸如数学或统计学完全不同。数据科学是一种实用的活动，数据科学家提供需求，并且帮助数据使用者解决问题。在解决一个问题之前，首先需要明确该问题，而这个过程却并不总是看起来那么明显。在这一章中，我们将要讨论如何识别数据问题。</strong></p>
<hr>
<p>种植苹果的农民经常生活在担忧中：春天花开的时候，一场霜冻足以冻死这些美丽的花朵；夏天结果的时候，一场冰雹或是飓风则会让所有的果实覆灭。一般而言，农业耕种是物理世界中最重要的活动，受到诸如天气等极其复杂的、远远超出了人类控制范围的自然因素的影响。</p>
<p>在这物理世界中高度不可预测的自然力量面前，数据科学是否占有的一席之地呢？表面上看似乎没有，但能否就此盖棺定论？要做到非常敏锐地识别数据问题，你需要有开阔的思维，强烈的好奇心和蓬勃的创造力，并且总是乐意不断的提出问题。事实上，正如你在第一章中得到的印象那样，数据科学家们往往整天坐在电脑面前，处理一段让人抓狂的R编写的程序。每天，数据科学家们必须专注于他们要处理问题的领域。显然，你可不能让一个数据科学家去做农活，但是如果你想要认识到农民才会遇到的数据问题，那么你必须学会像农民一样去思考问题，至少在一定程度上如此。</p>
<p>你可以通过阅读和观看视频来获取一个领域的专业知识，但是最好的办法是询问“相关的专家”（比如上面例子中的农民）来了解他们都干什么。询问问题的流程应当因问题而异，但是通常都可以从以下三个方面考虑。首先，你可以让这些“相关的专家”把他们所做的事像故事一样告诉你；然后你可以询问他们一些反常现象：哪些异常的发生导致最终结果变得更好或是更差；最后，你可以询问风险和不确定因素：哪些情况是难以确定是否会发生的，哪些情况将会对结果产生极大的影响，无论是好的影响还是坏的影响。这三个方面的每一部分都体现了识别数据问题的方法，通过数据，信息以及在正确时间做出的正确决策，可以让事情变得更好。</p>
<p>为什么要像听故事一样来提问呢？这是因为人们往往习惯于讲故事的思维，无论是农民、教师还是经理人或是CEO，人们总是讲述或倾听他们领域中那些成功或失败的例子。故事是一种非常强力的交流智慧，无论是在同一专业领域的不同人之间交流的时候，或是不同领域的人要获得对别的领域的初步认识的时候。当然，唯一存在的问题就是故事有可能是错的。</p>
<p>如果你可以让一个专业人员像说故事一样讲述她如何管理她的工作，接下来你就应该考虑如何来核实这些故事。即使不直接向故事叙述者询问故事的真实性，你也可以想到很多方法并从不同方面来验证故事中发生的事情。最终证实（也可能是揭穿）这些故事。</p>
<p>举例说明，一个农民可能会告诉你，在5年前发生的那场非常严重的春季霜冻中，在山谷中的树木都幸免于难，而山脊上的树木则受到严重的毁坏。由于这个原因，在一个寒冷的夜晚，这个农民在山脊上布满了烟熏罐（一种存放燃料用以产生烟火的容器），他坚信这个策略能起到作用。但事实是否如此呢？我们可以从不同地理位置收集一系列温度数据，包括果园里寒冷夜晚和暖和夜晚的温度，放置烟熏罐和不放置烟熏罐的夜晚的温度等，这些都是可行的。有了这些数据，我们就可以建立一个果园里不同位置的温度变化模型，这个模型就可以支持、改善或揭穿这个故事。</p>
<p>另外一种识别问题的策略就是寻找异常的例子，不管是好的还是坏的。稍后我们将在这本书中了解到经典的统计推断方法的核心是如何来描述“中心”的。“中心”是指出现的大部分的典型情况，通过检查那些远离中心的例子，就可以获取到能帮助我们理解环境干预或异常结合等信息。识别异常例子对理解事情工作原理非常有用，但前提是要定义大部分典型情况发生的中心，这样才能对何为异常情况有个清楚的认识。</p>
<p>让我们再回到农民朋友的这个例子上来，在去年夏末的一场大雷雨来之前，果园中吹过了一阵强风，将一些水果从树上打落下来。大部分的树都只掉落了少量的水果，并且这些水果都掉落在树根附近。而有少部分的树掉落的水果数量却明显多很多，而且掉落的位置也离树较远。这是因为这风非常奇怪，故意在这个位置上造成这个结果的吗？或者这只是一个巧合而已？</p>
<p>如果按照树的随机样本来对掉落的水果进行系统的统计，也许可以回答这个问题。从这个统计结果中应该能看到，大部分的树掉落的水果数量是大致相同的，更重要的是，这些正常情况可以给我们一个清晰的界限用以区分正常和不正常的情况。当我们找出了明显超出了正常范围的反常的例子时，我们就可以专注于这些反常的例子；通过这些异常，更好的理解事情发生的原理。</p>
<p>还有第三种识别数据问题的方法，就是明确事情存在的风险和不确定性。前面章节提到过，信息的一个基本功能就是用来降低不确定性。风险极大的影响着我们所做的事情，因此考虑降低不确定性就显得非常重要了。无论在单位，学校，或是家里，生活总是充满了风险：一个决定或是未能完成某件事情都可能引发一连串事情，从而导致某些事变好或变坏，这都很难说。一般情况下，我们都希望尽可能的获得好的结果，尽量避免结果变坏，缩小事情变化范围。要实现这样的目的，我们必须做出更好的决策；而想要做出更好的决策，我们就需要降低不确定性。数据科学家就是通过询问事情的风险和不确定性（以及做出的决策）从而能将注意力集中到关键问题上。回顾前两个策略——询问包含专业知识的故事和询问异常例子，其潜在的目的都是为了降低风险和不确定性。</p>
<p>还是农民这个例子，其中主要的风险都是来自于天气，通常情况下，解决天气不确定性的对策都是很划算的。在烟熏炉消耗大量昂贵的燃油来使夜晚暖和是一种非常浪费资源的表现，这在盈利的年份和亏损的年份将产生明显的不同。因此，想通过数据来解决这个问题，那么关于这个地区气候条件更加精确、合适的信息将是一个非常关键的部分。如果农民的手机上有一个应用能及时的播报当地的天气情况会怎样呢？让我们来建立一个这样的应用……</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/数据科学/">数据科学</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Introduction-to-data-science/">Introduction to data science</a><a href="/tags/数据科学/">数据科学</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/08/16/2014-8-data-science-chap2-Identifying-Data-Problems/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/08/16/2014-8-data-science-chap2-Identifying-Data-Problems/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/08/16/2014-8-data-science-chp1-about-data/" title="数据科学(1)-关于数据" itemprop="url">数据科学(1)-关于数据</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="中继点" target="_blank" itemprop="author">中继点</a>
		
  <p class="article-time">
    <time datetime="2014-08-16T12:29:11.000Z" itemprop="datePublished"> 發表於 2014 Aug 16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本文为<strong>Introduction to Data Science</strong>一书的翻译，由网友义务完成，了解参加翻译的网友，请点击<a href="https://github.com/johnstart/data-science/blob/gh-pages/task.md" target="_blank" rel="external">这里</a>，如果要加入我们请加入qq群171546473,了解翻译规则点击<a href="https://github.com/johnstart/data-science/blob/gh-pages/index.md" target="_blank" rel="external">这里</a></p>
<p>第一章 关于数据</p>
<p>数据这个词来源于拉丁文“datum”，意思是“已知的东西”。虽然“数据”这个术语从1500年代就被使用了，但是现代的用法是在1940年代和1950年代随着电子计算机开始输入，处理和输出数据时才出现的。这一章讨论数据的本质，并对没有计算机科学背景的初学者介绍一些关键概念。  </p>
<p>万维网的发明者Tim Berners-Lee经常被引用的一句话是：“数据不是信息，信息不是知识，知识不是理解，理解不是智慧。”这有点像金字塔，  数据就是建筑下面用来做地基的原材料，而信息，知识，理解和智慧代表金字塔更高的层次。在某种意义下来说，数据科学家的主要目标是去帮助人们把数据转换成信息以及金字塔的更高层。但是在实现这个目标之前，我们应该清楚地知道数据究竟是什么。（注意到这本书把“数据”这个词处理成了名词复数——而在平常你可能经常听到人们把这个词作为单数。）如果你学过计算机科学或者数学，你可能会发现这一章的讨论有一点多余，所以跳过它们没问题。但如果你没有学过那些，可以接着读下面关于数据——数据科学家的工作中最基本的元素——的介绍。</p>
<p>关于数据，我们现在了解并且谈论的大部分内容来源于一个叫做Claude Shannon的美国数学家的工作。Shannon在第二次世界大战前后研究了很多关于数据和信息的数学和工程问题。Shannon说：“通信的最基本问题是如何在一点近似或完全的再现另一点的内容。”这句话概括了在本书中的至关重要的想法，即数据是从源传递到接收方的信息。想想最简单的，你可以用手机给别人发短信，甚至当面告知来传递信息。假如一个朋友问题你一个问题，你明天可不可以去他家吃晚饭。你可以回答去或者不去。你可以在电话里对她说去不去。但你可能信号不好，所以你的朋友可能听不到。你也可以发短信告诉他去不去，这样你就得指望她的电话是开着的，这样才能收到短信。你也可以当面告诉你的朋友，然后指望她没有把耳机声音开得很大以至于听不到你。在这三种情况中，你都有一个“比特”的信息想传达给你的朋友，去或者不去，而目标是减少她对于你明天去不去吃晚饭这件事的不确定性。假设信息没有混淆和丢失的传递过去了，那么你就成功的向她传递了一比特的信息。Claude Shannon发展了一些现在被称之为“信息论”的数学，用以量化从源到接收方传递的数据是如何通过提供信息而减少不确定性的。现在世界上大量的电脑网络设备和软件——还有互联网——都是在解决这个简单的工作：把信息的比特从源传输到目的地。</p>
<p>一旦我们熟悉“比特”作为信息的最基本单位——“是”或“不是”——之后，我们可以把比特组合到一起形成更复杂的结构。首先，让我们稍微转换一下标签。我们不用“不是”而改用0，再把“是”换成1。现在我们变成了一个数字，虽然只有一个数字但是有两个状态：0或者1（我们现在不允许任何更大的数字，比如3或者7）。这事是上是“比特”这个词的院士含义，也即“二进制数字”的简写。一个简单的二进制数字可以是0或1，但是这阻止不了在我们的信息中使用多个数字。看下表这个例子：</p>
<table>
<thead>
<tr>
<th>意义</th>
<th style="text-align:center">第二个数字</th>
<th style="text-align:right">第一个数字</th>
</tr>
</thead>
<tbody>
<tr>
<td>否</td>
<td style="text-align:center">0</td>
<td style="text-align:right">0</td>
</tr>
<tr>
<td>也许</td>
<td style="text-align:center">0</td>
<td style="text-align:right">1</td>
</tr>
<tr>
<td>可能</td>
<td style="text-align:center">1</td>
<td style="text-align:right">0</td>
</tr>
<tr>
<td>一定</td>
<td style="text-align:center">1</td>
<td style="text-align:right">1</td>
</tr>
</tbody>
</table>
<p>在这里我们开始使用2个二进制数字——2比特——建立了我们想传递给朋友关于晚饭的4个信息的“密码说明书”。如果我们很确定我们不参加，我们就给她发送信息 0 0。如果我们很确定参加，我们就给她发送 1 1。但我们还有两种可能性，“也许”由 0 1表示，“可能”由 1 0表示。我们可以比较一下用一个比特表示的“是或不是”和两个比特表示的4种信息。事实上，每次你加一个比特，你所能传递的信息个数就会加倍。所以3个比特就会有8个选择，4个比特就会有16个选择。如果有5个比特，你会有多少种选择呢？</p>
<p>当我们有8个比特——这提供了256种组合——我们终于得到了一个可以实际使用的大小了。8个比特通常被叫做一个“字节”——这个术语可能是衍生于比特这个词。（你可以在网上找一找“nybble”这个词！）一字节的组合个数足够给字母表中的所有字母编码，包括大写字母和小写字母。有一个旧标准叫做“ASCII”——美国信息交换标准码—— 它把8比特的模式对应到字母表中的字母，标点，和一些其他标记符号。比如比特模式0100 0001表示大写字母A，而下一个模式0100 0010表示大写字母B。你可以在网上找到ASCII表（比如<a href="http://www.asciitable.com/" target="_blank" rel="external">http://www.asciitable.com/</a>），那里有所有的组合。要注意编码可能实际上不是用二进制表示因为对人类来说，读很长的一串0和1是很麻烦的。所以你可能看到的是等价的16进制编码，8进制编码或者我们熟悉的10进制编码。虽然你可能还记得高中数学课上学过的进制转换，但是最好还是实际练习一下——尤其是二进制，十六进制和十进制的转换。你也可能喜欢可汗学院上的Vi Hart的“二进制手舞”视频（在<a href="http://www.khanacademy.org" target="_blank" rel="external">http://www.khanacademy.org</a>上搜索，或者点击本章末尾给出的链接）。我们这本书的大多数工作是在十进制下进行的，但是关于数据的更复杂的工作通常需要理解16进制并要知道一个16进制数字，比如0xA3，是怎么转换成一个比特模式。搜索“二进制转换教程”，你会找到很多有用的网站。</p>
<p><strong>把字节组合成更大的结构</strong></p>
<p>既然我们知道了字节是由一些比特（通常是8个）构成的，它可以用来存储和传输事物比如字母和标点符号，用这种想法我们可以开始构建更大的东西。首先容易看出，我们可以把字节组合成列表来构造一“串”字母，这就是经常被谈论的“字符串”。如果我们有一些文本，比如“this is a piece of text”，我们可以用一些字节表示它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0111010001101000011010010111001100100000011010010111001100100000011000010010000001110000011010010110010101100011011001010010000001101111011001100010000001110100011001010111100001110100</span><br></pre></td></tr></table></figure>
<p>没人想看这样的东西，更别说手动编码和解码了，幸运的是，我们现在用的电脑和软件可以自动转换和存储。比如，当我们让开源数据语言“R”去存储”this is a piece of text”时，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myText&#60;- &#34;this is a piece of text&#34;</span><br></pre></td></tr></table></figure>
<p>我们知道在电脑内部有很长一串0和1用来表示我们刚才存储的文本。顺便提一下，为了之后可以再次调用这段文本，我们可以为它建立一个存储标签（上面的“myText”）。每次我们想看看这段文本或者想用它干些其他事，我们可以使用标签“myText”去打开电脑中我们存放代表我们的文本那一长串二进制数字的那一块内存。由小于号（“&lt;”）和短横线（“-”）组成的向左指的箭头在R中的意思是把右边的东西（引文）赋值给左边（我们标记为“myText”的存储区域）。一些人把这个叫做赋值箭头，在一些计算机语言中，它用来告诉读或者写代码的人信息的流向。</p>
<p>从计算机的角度来看，存储，记忆和操作数字要比文本容易的多。我们记得一个8比特的字节可以容纳256种组合，所以只使用这么小的一个空间我们就可以存储数字0到255（当然，我们也可以存1到256，但是计算机中的多数计数是从0而不是1开始的）。但是255也不够我们使用。我们不能仅用255以下计数多数城市中的房子数量也不能计算一个大停车场里的车辆个数。如果我们把两个字节合在一起构成16比特，我们就可以计数从0到65535，但这对于如今世界上的一些大数字来说还是不够的（比如，仅仅美国就有超过2亿辆汽车）。多数时候，如果我们想自由的表示一个整数（没有小数的数字），我们把4个字节放在一起。4个字节放在一起是32比特，这允许我们最大存储到4294967295。</p>
<p>当我们开始存储负数或者有小数的数的时候事情就有些复杂了。如果你对此好奇，搜索“补码”可以知道一个带符号的数字是怎么存储的，搜索“浮点”可以知道带小数的数字是如何存储的。对于我们这本书而言，主要应该知道文本的存储方式和数字是不同的，而整数和浮点的存储方式也是不同的。之后我们会发现有时会要求我们把这两种表示法相互转化，所以知道一个数是如何表示的总是很重要的一件事。</p>
<p>到目前为止我们主要了解了如何在同一时间存储一个东西，比如一个数字或者一个字母，但是当我们处理数据时，我们经常需要同时存储一组相关的东西。最简单的方法就是用元素的列表存储，在列表中的元素的存储方式都相同。比如，我们可以有整数的列表，列表中的每一个元素是你的一个家人的年龄。列表可能看起来是这样的：43，42，12，8，5。前两个数字是父母的年龄，后三个数字是孩子的年龄。自然的，在电脑中每个数字都是用二进制存储，但幸运的是我们不需要用二进制打出它们，我们也不需要阅读二进制。因为没有小数，它们是纯整数，一个32比特的整数（4字节）足够存储它们了。这个列表包含的元素具有相同的“类型”。开源数据编程语言“R”中的一个列表中的所有元素的类型都是“向量”。我们在R中可以通过枚举数字来容易的建立一个向量，在一个括号里用逗号分隔：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c(43,42,12,8,5)</span><br></pre></td></tr></table></figure>
<p>括号前面的字母“c”代表联结。这有些晦涩，但是适当的练习之后就很容易掌握。我们也可以用类似之前我们学到的方法来给我们的向量用一个名字存储（记住一个向量是一个具有相同类型元素的列表）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myFamilyAges &#60;- c(43,42,12,8,5)</span><br></pre></td></tr></table></figure>
<p>我们刚刚建立了我们的第一个“数据集”。当然，它很小，只有5个元素，但用它可以展示数据的一些核心概念。下面是一个回顾：</p>
<ul>
<li><p>在计算机的内部，所有的数据都以二进制存储。一个二进制数字，或者说比特，是我们可以从一个地方传输到另一个地方的最小的数据块。</p>
</li>
<li><p>虽然所有的数据都用二进制存储，但是电脑和软件可以帮助我们用更方便的形式呈现数据。三种重要的表现方式是：“字符”用来表示文本，“整数”用来表示小数点后面没有小数的数字，“浮点”用来表示有小数的数。在我们的小数据中的数的列表是整数。</p>
</li>
<li><p>数字和文本可以放入列表，开源语言“R”中叫做向量。一个向量具有长度，意思是它里面元素的个数，还有一个“类型”代表数据在向量中的存储类型。我们刚才使用的向量的长度是5，类型是整数。</p>
</li>
<li><p>为了保存我们在哪里存储了数据，多数电脑语言，包括R，允许我们给一段电脑内存一个标签。我们给那个5个元素的向量一个名字“myFamiliAges”。一些人可能把具有名字的列表叫做“变量”，因为它的值可以变化，这取决于你在使用列表中的哪个成员。</p>
</li>
<li><p>如果我们把一个或多个变量集合起来变成一个有意义的群体，我们把它叫做“数据集”。通常来说，数据集只有一个变量是没有什么意义的，所以通常我们至少需要两个变量。但是，严格来说，即使是我们的很简单的“myFamilyAges”也算作是一个数据集，虽然是一个很小的数据集。</p>
</li>
</ul>
<p>在这本书的后面我们会安装并运行开源“R”数据语言，学习如何创建数据集，在这些数据集中整理信息，对数据集进行简单的计算和变换。</p>
<p><strong>章节挑战</strong></p>
<p>理解“布尔逻辑”的意义和“且”，“或”，“非”和“异或”的规则。你学完后，不要看，在一张纸上写下所有代表这些规则的二进制操作。</p>
<p><strong>资源</strong></p>
<p><a href="http://en.wikipedia.org/wiki/Claude_Shannon" target="_blank" rel="external">http://en.wikipedia.org/wiki/Claude_Shannon</a></p>
<p><a href="http://en.wikipedia.org/wiki/Information_theory" target="_blank" rel="external">http://en.wikipedia.org/wiki/Information_theory</a></p>
<p><a href="http://cran.r-project.org/doc/manuals/R-intro.pdf" target="_blank" rel="external">http://cran.r-project.org/doc/manuals/R-intro.pdf</a></p>
<p><a href="http://www.khanacademy.org/math/vi-hart/v/binary-hand-dance" target="_blank" rel="external">http://www.khanacademy.org/math/vi-hart/v/binary-hand-dance</a></p>
<p><a href="http://www.khanacademy.org/science/computer-science/v/introduction-to-programs-data-types-and-variables" target="_blank" rel="external">http://www.khanacademy.org/science/computer-science/v/introduction-to-programs-data-types-and-variables</a></p>
<p><a href="http://www.asciitable.com/" target="_blank" rel="external">http://www.asciitable.com/</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/数据科学/">数据科学</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Introduction-to-data-science/">Introduction to data science</a><a href="/tags/数据科学/">数据科学</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/08/16/2014-8-data-science-chp1-about-data/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/08/16/2014-8-data-science-chp1-about-data/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/08/16/2014-08-data-science-chp0-data-science-many-skills/" title="数据科学(0)-数据科学：多面技能" itemprop="url">数据科学(0)-数据科学：多面技能</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="中继点" target="_blank" itemprop="author">中继点</a>
		
  <p class="article-time">
    <time datetime="2014-08-16T12:20:49.000Z" itemprop="datePublished"> 發表於 2014 Aug 16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本文为<strong>Introduction to Data Science</strong>一书的翻译，由网友义务完成，了解参加翻译的网友，请点击<a href="https://github.com/johnstart/data-science/blob/gh-pages/task.md" target="_blank" rel="external">这里</a>，如果要加入我们请加入qq群171546473,了解翻译规则点击<a href="https://github.com/johnstart/data-science/blob/gh-pages/index.md" target="_blank" rel="external">这里</a></p>
<h1 id="u6570_u636E_u79D1_u5B66_uFF1A_u591A_u9762_u6280_u80FD"><a href="#u6570_u636E_u79D1_u5B66_uFF1A_u591A_u9762_u6280_u80FD" class="headerlink" title="数据科学：多面技能"></a>数据科学：多面技能</h1><p><strong>本节主要内容</strong></p>
<ol>
<li>数据科学需要很多其它工作都需要的一个重要技能-数据分析能力，但是这不是唯一需要的技能</li>
<li>通过超市自动收款系统（POS）案例来展示数据科学的各种挑战</li>
<li>数据科学家在数据架构，数据获取，数据分析，数据归档这四个与数据科学相关的设计与实施领域扮演积极角色</li>
<li>案例中突出强调了沟通技能，数据分析技能，伦理推理技能</li>
</ol>
<p><img src="/img/datascience/section1-1.png" alt="skills"></p>
<p>有人可能一提到“数据科学”这个词就会在脑海里浮现出统计学家穿着白色的实验服眼睛盯着闪烁的计算机屏幕输入一行行的数据的图片。真相远非如此，首先统计学家不是穿着白色的实验服，这一“时髦”是给生物学家，医生以及其他需要保证在充满非普通液体环境中保持服装干净的人预留的。其次，这个世界上大多数数据是非数字化，非结构化的。这里非结构化是说数据不是以整齐的行列存在的。想象一下网页中的各种图片，朋友间的短消息，这当中很少有数字。尽管公司，学校，政府使用比如产品销售，成绩平均绩点（GPA），税收评估等大量数字信息是事实，，不过在这个世界上还有大量的其他信息数学家和统计学家需要观测和处理。因此尽管优秀的数学知识很有用，但数据科学的世界中还有更多我们已经习惯了的字词，列表，图像声音等其它信息也需要处理。</p>
<p>此外数据科学不只是简单的分析数据。许多人喜欢分析数据，他们可以一整天查看直方图与均值，而另一些人则更喜欢其它的工作。数据科学需要各种角色，多面技能。下面让我们以购买一盒麦片中涉及到的数据为例来分析。</p>
<p>不管你喜欢的麦片是水果型，巧克力型，纤维或者是坚果类，首先你会在购物清单里面加入“麦片”这一项。尽管它只是你用铅笔潦草写在信封背面，此时这一计划的购物已经是一份数据，当你到达杂货店，数据会提醒你从货架上取下一大盒水果味麦片放到购物篮里面。在收银台，收银员会扫描盒子上的条码，收款机会记录下价格。而库房里面，计算机会告诉存货管理人员因为你买的是商店里面最后一盒麦片了，所以商店需要向经销商下一个新订单了。同时由于你有一张针对你买的麦片的优惠卷，收银员需要扫描它，给你一个之前预设的折扣。在周末，一份所有来自该麦片制造商的优惠卷信息报表会传给麦片公司，以便他们向杂货店偿付他们向顾客所发的优惠卷折扣。最后，月末的时候，商场经理会看到一组五颜六色的饼图，上面展示了各种不同麦片的销售信息，由于水果类麦片销量强劲，经理决定在商场的有限货架空间中摆放更多的不同种类水果麦片。</p>
<p>小小的一点信息从你在购物清单上潦草涂写开始，在不同地方结束，最重要是它来到经理的桌上帮助决策。在从你的笔尖到经理的桌上的旅程中，数据经历了各种转化。除了计算机会终结或者存储数据以便长期使用外，大量如条码扫描仪之类的其它硬件也会涉及数据的收集，处理，转换和存储。此外，各种不同软件也被用于组织，汇总数据，将数据进行可视化与展示。最后各种“人类系统”也会与数据工作相关。有人需要决定购买或者安装什么系统，谁有权访问什么数据，数据完成使命后如何处理。在前面描述的场景成真之前，连锁杂货店的人员与和合作方需要上千次的具体决策与协商。</p>
<p>显然数据科学家不会参与到上面的每一步中，比如数据科学家不会设计与生产计算机，条码扫描仪等。那么数据科学家最重要的角色是什么呢？一般而言，数据科学家最重要的工作是以下关于数据的四个A：数据架构（data architecture），数据获取（data acquisition），数据分析（data analysis），数据归档（data archiving）。让我们以麦片购买为例来逐一分析以上各点。首先，对于数据架构而言很重要的一点，是在设计自动收款系统（零售商称之为收银机或相关设备）时，提前思考不同的用户应如何利用系统中的数据。对于系统架构师而言，需要具有敏锐的目光，比如发现尽管出于不同的需要，但是店长和经理都需要使用收银机中得数据。数据科学家通过提供数据的查询和组织方案，来协助系统架构师为不同的人提合适的供数据分析、可视化与展示服务。</p>
<p>其次，数据的获取主要关注在如何收集数据，更重要的是关注在数据在分析和展示，以及如何表示上。比如说，条形码仅是一串数字，无法很好的描述商品信息。当被扫描后，是否应该将商品描述、价格、净重或包装类型与之相连？不同的条形码可用于相同的商品（比如不同包装大小的麦片）。何时我们该注意到购买X与购买Y其实是购买的同一种不同尺寸的产品了？在数据能够被有效的分析之前，我们应该做好所有的数据的表示、转换、分组以及关联工作。而这些都是需要数据科学家介入的工作。</p>
<p>分析阶段是数据科学家参与最多的阶段。在此阶段，我们汇总数据，或用抽样数据来推断整体数据，同时使用表格、图或动画来展现数据。虽然会涉及到很多技术、数学、统计的知识。但请牢记，数据的最终用户始终是人。人才是最终的数据用户，满足人们的需求才是数据科学家的主要工作。因此也要求数据科学家具有良好的沟通能力。如果不能将信息有效的传递给用户，即使具有熟练的统计技巧，也是无用的。</p>
<p>最后，数据科学家也会参与数据归档。将收集的数据以某种形式进行展现使得数据可高度复用。大家可以把它认为是“数据监护“的概念。这往往是个不小的挑战，因为往往很难预测未来数据的使用方式。比如当tweeter的开发者在考虑如何存储数据时，他们可能永远不会预料到这批数据会被用于精确寻找地震和海啸。不过开发者也能预见到显示用户所在位置的地理编码是有用的数据。</p>
<p>总而言之，燕麦和杂货店的例子让我们认识到数据科学家的职责和所需的技巧。通过这些例子，我们总结了如下的技巧：</p>
<ol>
<li>学习应用领域的知识。数据科学家必须快速的学习数据在不同的场景下如何使用。</li>
<li>与用户的良好沟通。数据科学家应够拥有足够的技巧来倾听和理解用户的需求且能够在技术、统计等专业术语与业务术语间不断的转换也是一项重要的能力。</li>
<li>能够全局的看待复杂的系统。在理解应用需求后，数据科学家必须能够预料到数据是如何在相关的系统和用户间流动的。</li>
<li>知道数据该被怎样表示。数据科学家必须清楚的理解元数据（描述数据是如何被组织的数据），理解数据是如何被存储和关联的。</li>
<li>数据转换和分析。当决策者需要使用数据时，数据科学家必须清楚的知道如何转换，汇总数据以及如何对数据进行推断。如上所述，将分析的结果很好的传达给用户也是一项十分重要的技巧。</li>
<li>可视化与展现。尽管数字具有精确性。但是良好的数据展示可以更有效的将分析结果传达给用户。</li>
<li>关注质量。无论数据集合的质量有多好，都不可能达到完美的程度。数据科学家必须知道数据的局限性,了解如何量化数据的精确性，并对提高数据在未来的使用中的质量提出建议</li>
<li>伦理推理。如果数据足够重要，使得人们想要收集这些数据。那么这些数据往往也重要到影响了人们的生活。数据科学家必须意识到可能存在的伦理问题，比如隐私问题。并将这些局限有效的交流给用户，并防止数据或分析的误用。</li>
</ol>
<p>以上提及的技巧和能力仅是冰山一角。同时，对数字和数学的敏锐理解也是十分重要的。特别是对数据分析而言，数据科学家需要具有良好的沟通能力，具有系统思维以及数据可视化的良好直觉。能够清楚的认识到决策者是如何使用数据，数据是如何影响人们生活的。当然，仅有少数的人能够同时具有这些能力，因此有些人可能对某个领域比较精通，而其他人可能对另一领域比较精通。因此团队的协作就变得十分重要。</p>
<p>本书通过一系列逐渐复杂的例子来阐述数据科学家应该具有的知识和能力。我们使用开源数据软件R以及R-STUDIO来演示真实的数据问题，阐述数据科学家面临的挑战以及解决问题所采用的一些技术。我们使用尽可能真实的数据来进行演示面临的问题。</p>
<p>没有任何一本书能够完全覆盖数据科学所涉及的领域。本书的最后列出了参考文献和资源，有兴趣的读者可以获得更多的知识。R和Rstudio所代表的开源精神告诉我们尽可能的使用基于互联网、自由免费得资料。实际上，本书使用最多的参考文献是维基，一个免费、在线并且有用户自己维护的百科全书。尽管一些人对维基百科的合法性存在疑问，并且维基百科也不是十分完美，但是维基百科仍然是十分有用的学习资源。因为它是免费、自由的，并且覆盖的主题超过任何一本纸质的百科全书不止50倍，并且随时在不断的更新中。因此维基百科是快入门某一主题的有用参考。尽管仅仅通过阅读维基百科，还不能使你成为专家，但是你可以得到很好的入门。</p>
<p>另外一个有用的资源是可汗学院。很多人认为可汗学院仅提供了很多视频给初中高中生来介绍一些数学概念。但是全球成千上万的成年人都通过可汗学院来复习或者快速入门某些学科。可汗学院所有的课程都是免费得，通过你得google或者facebook账户登录，你可以做各种习题，并且追踪你的学习历程。</p>
<p>每章的最后都列出了相关的维基百科的资源以及可汗学院的课程，以及其学习他资源。这些资源使得读者可以深入学习每章的主题以及没有涉及的细节。</p>
<p>当你阅读本书时，你可能需要在IPAD或者其他苹果的设备商访问某些阅读器软件，你可以通过如下网址获取本书，<a href="http://jsresearch.net/wiki/projects/teachdatascience/Teach_Data_Science.html" target="_blank" rel="external">http://jsresearch.net/wiki/projects/teachdatascience/Teach_Data_Science.html</a>. 阅读本书的同时，访问本书提供的各种interne链接是十分有用的。你也需要在你的电脑上实践本书涉及的一些R代码。</p>
<p>最后一点，本书提供的阅读顺序可以并不假设读者具有任何的计算机或统计学知识或经验。如果你具有一定的知识和经验，你可以任意的跳过相关章节。以下为大家提供了免费得学习资源：</p>
<p><a href="http://en.wikipedia.org/wiki/E-Science" target="_blank" rel="external">http://en.wikipedia.org/wiki/E-Science</a><br><a href="http://en.wikipedia.org/wiki/E-Science_librarianship" target="_blank" rel="external">http://en.wikipedia.org/wiki/E-Science_librarianship</a><br><a href="http://en.wikipedia.org/wiki/Wikipedia:Size_comparisons" target="_blank" rel="external">http://en.wikipedia.org/wiki/Wikipedia:Size_comparisons</a><br><a href="http://en.wikipedia.org/wiki/Statistician" target="_blank" rel="external">http://en.wikipedia.org/wiki/Statistician</a><br><a href="http://en.wikipedia.org/wiki/Visualization_(computer_graphics" target="_blank" rel="external">http://en.wikipedia.org/wiki/Visualization_(computer_graphics</a>)<br><a href="http://www.khanacademy.org/" target="_blank" rel="external">http://www.khanacademy.org/</a><br><a href="http://www.r-project.org/" target="_blank" rel="external">http://www.r-project.org/</a><br><a href="http://www.readwriteweb.com/hack/2011/09/unlocking-big-data-with-r.php" target="_blank" rel="external">http://www.readwriteweb.com/hack/2011/09/unlocking-big-data-with-r.php</a><br><a href="http://rstudio.org/" target="_blank" rel="external">http://rstudio.org/</a>  </p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/数据科学/">数据科学</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Introduction-to-data-science/">Introduction to data science</a><a href="/tags/数据科学/">数据科学</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/08/16/2014-08-data-science-chp0-data-science-many-skills/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/08/16/2014-08-data-science-chp0-data-science-many-skills/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/page/2/"><span></span>Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="顯示側邊欄"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隱藏側邊欄"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分類</p>
		<ul>
		
		  
			<li><a href="/categories/数据科学/" title="数据科学">数据科学<sup>38</sup></a></li>
		  
		
		  
			<li><a href="/categories/杂记/" title="杂记">杂记<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/笔记/" title="笔记">笔记<sup>19</sup></a></li>
		  
		
		  
			<li><a href="/categories/行业观察/" title="行业观察">行业观察<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/软件定价/" title="软件定价">软件定价<sup>12</sup></a></li>
		  
		
		  
			<li><a href="/categories/软件技术/" title="软件技术">软件技术<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">標簽</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/数据科学/" title="数据科学">数据科学<sup>33</sup></a></li>
			
		
			
				<li><a href="/tags/R/" title="R">R<sup>26</sup></a></li>
			
		
			
				<li><a href="/tags/笔记/" title="笔记">笔记<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/经济学/" title="经济学">经济学<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/凯恩斯/" title="凯恩斯">凯恩斯<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/软件定价/" title="软件定价">软件定价<sup>12</sup></a></li>
			
		
			
				<li><a href="/tags/机器学习/" title="机器学习">机器学习<sup>11</sup></a></li>
			
		
			
				<li><a href="/tags/Introduction-to-data-science/" title="Introduction to data science">Introduction to data science<sup>11</sup></a></li>
			
		
			
				<li><a href="/tags/机器学习与R/" title="机器学习与R">机器学习与R<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/data-science/" title="data science">data science<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/可视化/" title="可视化">可视化<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/企业成长/" title="企业成长">企业成长<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/创业/" title="创业">创业<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/培训/" title="培训">培训<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/R培训/" title="R培训">R培训<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/TED/" title="TED">TED<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/markdown/" title="markdown">markdown<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/数据分析/" title="数据分析">数据分析<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Kaggle/" title="Kaggle">Kaggle<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/软件项目管理/" title="软件项目管理">软件项目管理<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=1543589403&verifier=996dff3a&dpc=1"></iframe>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情鏈接</p>
    <ul>
        
    </ul>
</div>

  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 訂閱</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> life long leaner <br/>
			关注大数据,R,移动互联,研发管理,lean startup,lifelong learning</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/1543589403" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="中继点">中继点</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-37263323-2', 'auto');  
ga('send', 'pageview');
</script>





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回頂部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
