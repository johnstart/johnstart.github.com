
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>中继点</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="中继点">
    

    
    <meta name="description" content="大数据，R，研发管理，移动互联，Lean Startup">
<meta property="og:type" content="website">
<meta property="og:title" content="中继点">
<meta property="og:url" content="http://www.zjdian.com/page/2/index.html">
<meta property="og:site_name" content="中继点">
<meta property="og:description" content="大数据，R，研发管理，移动互联，Lean Startup">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="中继点">
<meta name="twitter:description" content="大数据，R，研发管理，移动互联，Lean Startup">

    
    <link rel="alternative" href="/atom.xml" title="中继点" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="中继点" title="中继点"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="中继点">中继点</a></h1>
				<h2 class="blog-motto">大数据，R，研发管理，移动互联，Lean Startup</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜單">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:www.zjdian.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/10/09/2014-10-09-hurricane/" title="2010~2014 飓风可视化尝试" itemprop="url">2010~2014 飓风可视化尝试</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="中继点" target="_blank" itemprop="author">中继点</a>
		
  <p class="article-time">
    <time datetime="2014-10-09T14:35:37.000Z" itemprop="datePublished"> 發表於 2014 Oct 9</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>最近对数据可视化进行了一些研究学习，下面是参考<a href="http://www.gastonsanchez.com" target="_blank" rel="external">Gaston Sanchez</a>之前对2009～2010年飓风的可视化方法对2010~2014发生的飓风进行了一个可视化尝试，采用R实现。</p>
<h1 id="u6570_u636E_u83B7_u53D6"><a href="#u6570_u636E_u83B7_u53D6" class="headerlink" title="数据获取"></a>数据获取</h1><p><a href="http://www.ncdc.noaa.gov/oa/ibtracs/index.php?name=wmo-data" target="_blank" rel="external">International Best Track Archive for Climate Stewardship</a>网站会收集飓风信息数据，我们这里选择下载csv格式数据。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">setwd(<span class="string">"d:/project/datascience/hurricane/"</span>)</span><br><span class="line">row.names=c(<span class="string">"Serial_Num"</span>,<span class="string">"Season"</span>,<span class="string">"Num"</span>,<span class="string">"Basin"</span>,<span class="string">"Sub_basin"</span>,<span class="string">"Name"</span>,</span><br><span class="line">            <span class="string">"ISO_time"</span>,<span class="string">"Nature"</span>,<span class="string">"Latitude"</span>,<span class="string">"Longitude"</span>,<span class="string">"Wind.WMO"</span>,<span class="string">"Pres.WMO"</span>,</span><br><span class="line">            <span class="string">"Center"</span>,<span class="string">"Wind.WMO.Percentile"</span>,<span class="string">"Pres.WMO.Percentile"</span>,<span class="string">"Track_type"</span>)</span><br><span class="line">hurricane=read.csv(<span class="string">"Allstorms.ibtracs_wmo.v03r06.csv"</span>,skip=<span class="number">3</span>,</span><br><span class="line">                   header=<span class="literal">F</span>,stringsAsFactors=<span class="literal">F</span>)</span><br><span class="line">names(hurricane)=row.names</span><br><span class="line">head(hurricane)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##      Serial_Num Season Num Basin Sub_basin       Name            ISO_time&#10;## 1 1848011S09080   1848   2    SI        MM XXXX848003 1848-01-11 06:00:00&#10;## 2 1848011S09080   1848   2    SI        MM XXXX848003 1848-01-12 06:00:00&#10;## 3 1848011S09080   1848   2    SI        MM XXXX848003 1848-01-13 06:00:00&#10;## 4 1848011S09080   1848   2    SI        MM XXXX848003 1848-01-14 06:00:00&#10;## 5 1848011S09080   1848   2    SI        MM XXXX848003 1848-01-15 06:00:00&#10;## 6 1848011S09080   1848   2    SI        MM XXXX848003 1848-01-16 06:00:00&#10;##   Nature Latitude Longitude Wind.WMO Pres.WMO  Center Wind.WMO.Percentile&#10;## 1     NR     -8.6      79.8        0        0 reunion                -100&#10;## 2     NR     -9.0      78.9        0        0 reunion                -100&#10;## 3     NR    -10.4      73.2        0        0 reunion                -100&#10;## 4     NR    -12.8      69.9        0        0 reunion                -100&#10;## 5     NR    -13.9      68.9        0        0 reunion                -100&#10;## 6     NR    -15.3      67.7        0        0 reunion                -100&#10;##   Pres.WMO.Percentile Track_type&#10;## 1                -100       main&#10;## 2                -100       main&#10;## 3                -100       main&#10;## 4                -100       main&#10;## 5                -100       main&#10;## 6                -100       main</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str(hurricane)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## &#39;data.frame&#39;:&#9;189855 obs. of  16 variables:&#10;##  $ Serial_Num         : chr  &#34;1848011S09080&#34; &#34;1848011S09080&#34; &#34;1848011S09080&#34; &#34;1848011S09080&#34; ...&#10;##  $ Season             : int  1848 1848 1848 1848 1848 1848 1848 1848 1848 1848 ...&#10;##  $ Num                : int  2 2 2 2 2 2 2 2 2 2 ...&#10;##  $ Basin              : chr  &#34; SI&#34; &#34; SI&#34; &#34; SI&#34; &#34; SI&#34; ...&#10;##  $ Sub_basin          : chr  &#34; MM&#34; &#34; MM&#34; &#34; MM&#34; &#34; MM&#34; ...&#10;##  $ Name               : chr  &#34;XXXX848003&#34; &#34;XXXX848003&#34; &#34;XXXX848003&#34; &#34;XXXX848003&#34; ...&#10;##  $ ISO_time           : chr  &#34;1848-01-11 06:00:00&#34; &#34;1848-01-12 06:00:00&#34; &#34;1848-01-13 06:00:00&#34; &#34;1848-01-14 06:00:00&#34; ...&#10;##  $ Nature             : chr  &#34; NR&#34; &#34; NR&#34; &#34; NR&#34; &#34; NR&#34; ...&#10;##  $ Latitude           : num  -8.6 -9 -10.4 -12.8 -13.9 -15.3 -16.5 -18 -20.6 -22.8 ...&#10;##  $ Longitude          : num  79.8 78.9 73.2 69.9 68.9 67.7 67 67.4 69.8 72 ...&#10;##  $ Wind.WMO           : num  0 0 0 0 0 0 0 0 0 0 ...&#10;##  $ Pres.WMO           : num  0 0 0 0 0 0 0 0 0 0 ...&#10;##  $ Center             : chr  &#34;reunion&#34; &#34;reunion&#34; &#34;reunion&#34; &#34;reunion&#34; ...&#10;##  $ Wind.WMO.Percentile: num  -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 ...&#10;##  $ Pres.WMO.Percentile: num  -100 -100 -100 -100 -100 -100 -100 -100 -100 -100 ...&#10;##  $ Track_type         : chr  &#34;main&#34; &#34;main&#34; &#34;main&#34; &#34;main&#34; ...</span><br></pre></td></tr></table></figure>
<h1 id="u9884_u5904_u7406_u6570_u636E"><a href="#u9884_u5904_u7406_u6570_u636E" class="headerlink" title="预处理数据"></a>预处理数据</h1><p>通过对数据大致了解，我们知道Season实际也对应于年，即Season为1848就代表了该行对应1848。这里取2010年以后数据进行分析</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span>(dplyr)</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hurricane.df=tbl_df(hurricane)</span><br><span class="line">hurricane.after.2010=hurricane.df%&gt;%filter(Season&gt;=<span class="number">2010</span>)</span><br><span class="line">hurricane.after.2010</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Source: local data frame [12,324 x 16]&#10;## &#10;##       Serial_Num Season Num Basin Sub_basin Name            ISO_time&#10;## 1  2009317S10073   2010   1    SI        MM ANJA 2009-11-13 06:00:00&#10;## 2  2009317S10073   2010   1    SI        MM ANJA 2009-11-13 12:00:00&#10;## 3  2009317S10073   2010   1    SI        MM ANJA 2009-11-13 18:00:00&#10;## 4  2009317S10073   2010   1    SI        MM ANJA 2009-11-14 00:00:00&#10;## 5  2009317S10073   2010   1    SI        MM ANJA 2009-11-14 06:00:00&#10;## 6  2009317S10073   2010   1    SI        MM ANJA 2009-11-14 12:00:00&#10;## 7  2009317S10073   2010   1    SI        MM ANJA 2009-11-14 18:00:00&#10;## 8  2009317S10073   2010   1    SI        MM ANJA 2009-11-15 00:00:00&#10;## 9  2009317S10073   2010   1    SI        MM ANJA 2009-11-15 06:00:00&#10;## 10 2009317S10073   2010   1    SI        MM ANJA 2009-11-15 12:00:00&#10;## ..           ...    ... ...   ...       ...  ...                 ...&#10;## Variables not shown: Nature (chr), Latitude (dbl), Longitude (dbl),&#10;##   Wind.WMO (dbl), Pres.WMO (dbl), Center (chr), Wind.WMO.Percentile (dbl),&#10;##   Pres.WMO.Percentile (dbl), Track_type (chr)</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dim(hurricane.after.2010)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 12324    16</span><br></pre></td></tr></table></figure>
<p>这里的ISO_time同时包含了年月日以及时间，我们这里先把月份给单独取出来。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#拆分</span></span><br><span class="line">date.time=strsplit(hurricane.after.2010$ISO_time,<span class="string">" "</span>)</span><br><span class="line"><span class="comment">#只取日期</span></span><br><span class="line">iso.date=unlist(lapply(date.time,<span class="keyword">function</span>(x) x[<span class="number">1</span>]))</span><br><span class="line"><span class="comment">#取月份</span></span><br><span class="line">iso.month=substr(iso.date,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">hurricane.after.2010$Month=iso.month</span><br></pre></td></tr></table></figure>
<p>对于没有命名的飓风一般都不是特别厉害，这里就不考虑了</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hurricane.after.2010=hurricane.after.2010%&gt;%filter(Name!=<span class="string">"NAMED"</span> &amp; Name!=<span class="string">"NOT NAMED"</span>)</span><br></pre></td></tr></table></figure>
<h1 id="u51C6_u5907_u7ED8_u56FE"><a href="#u51C6_u5907_u7ED8_u56FE" class="headerlink" title="准备绘图"></a>准备绘图</h1><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span>(ggplot2)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Loading required package: ggplot2</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span>(ggthemes)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Loading required package: ggthemes</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Warning: package &#39;ggthemes&#39; was built under R version 3.1.1</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们再给飓风加上一个ID，以飓风的Name+Season来命名</span></span><br><span class="line"><span class="comment"># 这样后面我们可以获得飓风的路径用来绘图</span></span><br><span class="line">hurricane.after.2010$ID = as.factor(paste(hurricane.after.2010$Name, </span><br><span class="line">                                          hurricane.after.2010$Season, sep = <span class="string">"."</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将飓风Name转换为factor</span></span><br><span class="line">hurricane.after.2010$Name = as.factor(hurricane.after.2010$Name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 经过试验发现其他地区数据有些错误，所以只使用NA与EP区域</span></span><br><span class="line">hurricane.after.2010$Basin=gsub(<span class="string">"^ "</span>, <span class="string">""</span>, hurricane.after.2010$Basin)</span><br><span class="line">hurricane.after.2010=hurricane.after.2010%&gt;%filter(Basin==<span class="string">"NA"</span>|Basin==<span class="string">"EP"</span>)</span><br></pre></td></tr></table></figure>
<p>现在一切就绪开始绘图</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">x.range=range(hurricane.after.2010$Longitude)</span><br><span class="line">y.range=range(hurricane.after.2010$Latitude)</span><br><span class="line">hurricane.map = ggplot(hurricane.after.2010, </span><br><span class="line">                       aes(x = Longitude, y = Latitude, group = ID)) + </span><br><span class="line">  geom_polygon(data = map_data(<span class="string">"world"</span>), aes(x = long, y = lat, group = group), </span><br><span class="line">               fill = <span class="string">"gray25"</span>, colour = <span class="string">"gray10"</span>, size = <span class="number">0.2</span>) + </span><br><span class="line">  geom_path(data = hurricane.after.2010, aes(group = ID, colour = Wind.WMO), </span><br><span class="line">            alpha = <span class="number">0.5</span>, size = <span class="number">0.8</span>) + </span><br><span class="line">  xlim(x.range) + </span><br><span class="line">  ylim(y.range) + </span><br><span class="line">  labs(x = <span class="string">""</span>, y = <span class="string">""</span>)+</span><br><span class="line">  theme(panel.background = element_rect(fill = <span class="string">"gray10"</span>, colour = <span class="string">"gray30"</span>),      </span><br><span class="line">       axis.text.x = element_blank(), </span><br><span class="line">       axis.text.y = element_blank(),</span><br><span class="line">       axis.ticks = element_blank(), </span><br><span class="line">       panel.grid.major = element_blank(), </span><br><span class="line">       panel.grid.minor = element_blank())+</span><br><span class="line">  ggtitle(label = <span class="string">"飓风 2010 - 2014"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hurricane.map</span><br></pre></td></tr></table></figure>
<p><img src="/img/project/hurricane/hurricane.png" alt="飓风2010～2014"></p>
<p>按月绘制</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">hurricane.map.month = ggplot(hurricane.after.2010, </span><br><span class="line">                       aes(x = Longitude, y = Latitude, group = ID)) + </span><br><span class="line">  geom_polygon(data = map_data(<span class="string">"world"</span>), aes(x = long, y = lat, group = group), </span><br><span class="line">               fill = <span class="string">"gray25"</span>, colour = <span class="string">"gray10"</span>, size = <span class="number">0.2</span>) + </span><br><span class="line">  geom_path(data = hurricane.after.2010, aes(group = ID, colour = Wind.WMO), </span><br><span class="line">            alpha = <span class="number">0.5</span>, size = <span class="number">0.8</span>) + </span><br><span class="line">  xlim(x.range) + </span><br><span class="line">  ylim(y.range) + </span><br><span class="line">  labs(x = <span class="string">""</span>, y = <span class="string">""</span>)+</span><br><span class="line">  facet_wrap(~Month)+</span><br><span class="line">  theme(panel.background = element_rect(fill = <span class="string">"gray10"</span>, colour = <span class="string">"gray30"</span>),      </span><br><span class="line">       axis.text.x = element_blank(), </span><br><span class="line">       axis.text.y = element_blank(),</span><br><span class="line">       axis.ticks = element_blank(), </span><br><span class="line">       panel.grid.major = element_blank(), </span><br><span class="line">       panel.grid.minor = element_blank())+</span><br><span class="line">  ggtitle(label = <span class="string">"飓风 2010 - 2014/月"</span>)</span><br><span class="line"></span><br><span class="line">hurricane.map.month</span><br></pre></td></tr></table></figure>
<p><img src="/img/project/hurricane/hurricane-month.png" alt="飓风2010～2014 月度趋势图"></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/数据科学/">数据科学</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/R/">R</a><a href="/tags/data-science/">data science</a><a href="/tags/可视化/">可视化</a><a href="/tags/数据科学/">数据科学</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/10/09/2014-10-09-hurricane/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/10/09/2014-10-09-hurricane/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/10/07/2014-10-07-SF-crime/" title="San Francisco过去3月的犯罪案件可视化分析" itemprop="url">San Francisco过去3月的犯罪案件可视化分析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="中继点" target="_blank" itemprop="author">中继点</a>
		
  <p class="article-time">
    <time datetime="2014-10-07T11:55:37.000Z" itemprop="datePublished"> 發表於 2014 Oct 7</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="u76EE_u6807"><a href="#u76EE_u6807" class="headerlink" title="目标"></a>目标</h1><p>分析San Francisco的犯罪案件的模式。数据来自:<br><a href="https://data.sfgov.org/Public-Safety/SFPD-Incidents-Previous-Three-Months/tmnf-yvry?" target="_blank" rel="external">https://data.sfgov.org/Public-Safety/SFPD-Incidents-Previous-Three-Months/tmnf-yvry?</a></p>
<p>希望回答以下问题:</p>
<ul>
<li>在哪里停车最危险?</li>
<li>SF最安全的地方是哪里? 每周的哪天/哪个时间最危险?</li>
<li>某种特定偷窃案件是否在某个区域更普遍?</li>
</ul>
<h1 id="u51C6_u5907_u5206_u6790_u7528_u7684_u5305"><a href="#u51C6_u5907_u5206_u6790_u7528_u7684_u5305" class="headerlink" title="准备分析用的包"></a>准备分析用的包</h1><p>我们用dplyr来整理数据，ggplot2以及ggmap来进行数据可视化</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span>(dplyr)</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span>(ggplot2)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Loading required package: ggplot2</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span>(ggmap)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Loading required package: ggmap</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span>(ggthemes)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Loading required package: ggthemes</span><br></pre></td></tr></table></figure>
<h1 id="u51C6_u5907_u6570_u636E"><a href="#u51C6_u5907_u6570_u636E" class="headerlink" title="准备数据"></a>准备数据</h1><p>先设置工作目录，读入数据。然后呢把日期格式化，同时呢我们把时间按照小时来分，不考虑分钟。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setwd(<span class="string">"d:/project/datascience/teamleada"</span>)</span><br><span class="line"><span class="comment">#read in the data</span></span><br><span class="line">crime=read.csv(<span class="string">"./SFPD_Incidents_-_Previous_Three_Months.csv"</span>)</span><br><span class="line"><span class="comment"># format the data</span></span><br><span class="line">crime$Location=<span class="literal">NULL</span></span><br><span class="line">crime$IncidntNum=<span class="literal">NULL</span></span><br><span class="line">crime$Date=as.Date(crime$Date,format=<span class="string">"%m/%d/%Y"</span>)</span><br><span class="line">crime$Hour=as.factor(substr(as.character(crime$Time),<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"><span class="comment"># we will use dplyr package to do the work</span></span><br><span class="line">crime.df=tbl_df(crime)</span><br><span class="line">crime.df</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Source: local data frame [30,760 x 11]&#10;## &#10;##         Category                                   Descript DayOfWeek&#10;## 1  LARCENY/THEFT             GRAND THEFT FROM UNLOCKED AUTO    Sunday&#10;## 2  LARCENY/THEFT               GRAND THEFT FROM LOCKED AUTO    Sunday&#10;## 3  LARCENY/THEFT               GRAND THEFT FROM LOCKED AUTO    Sunday&#10;## 4  DRUG/NARCOTIC             POSSESSION OF METH-AMPHETAMINE    Sunday&#10;## 5  DRUG/NARCOTIC                      POSSESSION OF COCAINE    Sunday&#10;## 6  LARCENY/THEFT               GRAND THEFT FROM LOCKED AUTO    Sunday&#10;## 7       WARRANTS                             WARRANT ARREST    Sunday&#10;## 8  VEHICLE THEFT                          STOLEN AUTOMOBILE    Sunday&#10;## 9  LARCENY/THEFT                    PETTY THEFT OF PROPERTY    Sunday&#10;## 10       ROBBERY ROBBERY OF A CHAIN STORE WITH BODILY FORCE    Sunday&#10;## ..           ...                                        ...       ...&#10;## Variables not shown: Date (date), Time (fctr), PdDistrict (fctr),&#10;##   Resolution (fctr), Address (fctr), X (dbl), Y (dbl), Hour (fctr)</span><br></pre></td></tr></table></figure>
<h1 id="u8F85_u52A9_u51FD_u6570"><a href="#u8F85_u52A9_u51FD_u6570" class="headerlink" title="辅助函数"></a>辅助函数</h1><p>这里主要有两个，因为在画直方图的时候，我们希望按count大小来排序，而不是按照数据中的factor变量的level来排序，所以写了一个辅助函数来对factor的lvel重新排序</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">order.level=<span class="keyword">function</span>(level.var,count) &#123;</span><br><span class="line">  level.var=factor(level.var,levels = </span><br><span class="line">                     levels(level.var)[order(count,decreasing=<span class="literal">T</span>)])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个函数就是控制多个图形绘制时的排版，这个直接使用的R cookbook提供了函数</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Multiple plot function</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)</span></span><br><span class="line"><span class="comment"># - cols:   Number of columns in layout</span></span><br><span class="line"><span class="comment"># - layout: A matrix specifying the layout. If present, 'cols' is ignored.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),</span></span><br><span class="line"><span class="comment"># then plot 1 will go in the upper left, 2 will go in the upper right, and</span></span><br><span class="line"><span class="comment"># 3 will go all the way across the bottom.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">multiplot &lt;- <span class="keyword">function</span>(<span class="keyword">...</span>, plotlist=<span class="literal">NULL</span>, file, cols=<span class="number">1</span>, layout=<span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="keyword">require</span>(grid)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># Make a list from the ... arguments and plotlist</span></span><br><span class="line">  plots &lt;- c(list(<span class="keyword">...</span>), plotlist)</span><br><span class="line">  </span><br><span class="line">  numPlots = length(plots)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># If layout is NULL, then use 'cols' to determine layout</span></span><br><span class="line">  <span class="keyword">if</span> (is.null(layout)) &#123;</span><br><span class="line">    <span class="comment"># Make the panel</span></span><br><span class="line">    <span class="comment"># ncol: Number of columns of plots</span></span><br><span class="line">    <span class="comment"># nrow: Number of rows needed, calculated from # of cols</span></span><br><span class="line">    layout &lt;- matrix(seq(<span class="number">1</span>, cols * ceiling(numPlots/cols)),</span><br><span class="line">                     ncol = cols, nrow = ceiling(numPlots/cols))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (numPlots==<span class="number">1</span>) &#123;</span><br><span class="line">    print(plots[[<span class="number">1</span>]])</span><br><span class="line">    </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment"># Set up the page</span></span><br><span class="line">    grid.newpage()</span><br><span class="line">    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Make each plot, in the correct location</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>:numPlots) &#123;</span><br><span class="line">      <span class="comment"># Get the i,j matrix positions of the regions that contain this subplot</span></span><br><span class="line">      matchidx &lt;- as.data.frame(which(layout == i, arr.ind = <span class="literal">TRUE</span>))</span><br><span class="line">      </span><br><span class="line">      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,</span><br><span class="line">                                      layout.pos.col = matchidx$col))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="u5728_u54EA_u91CC_u505C_u8F66_3F"><a href="#u5728_u54EA_u91CC_u505C_u8F66_3F" class="headerlink" title="在哪里停车?"></a>在哪里停车?</h1><p>这里我们先只取VEHICLE THEFT进行分析，之后按照案件发生的区域分组统计</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">crime.df.vehicle=filter(crime.df,Category==<span class="string">"VEHICLE THEFT"</span>)</span><br><span class="line">crime.vehicle.district=crime.df.vehicle %&gt;% </span><br><span class="line">  group_by(PdDistrict)%&gt;% </span><br><span class="line">  summarise(count=n())</span><br><span class="line"></span><br><span class="line"><span class="comment"># PdDistrict变量按照count进行排序</span></span><br><span class="line">crime.vehicle.district$PdDistrict=order.level(crime.vehicle.district$PdDistrict,</span><br><span class="line">                                              crime.vehicle.district$count)</span><br><span class="line">p1=qplot(crime.vehicle.district$PdDistrict,data=crime.vehicle.district,</span><br><span class="line">      weight=crime.vehicle.district$count,geom=<span class="string">"histogram"</span>,</span><br><span class="line">      xlab=<span class="string">"District"</span>,ylab=<span class="string">"Vehicle Theft Count"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 经纬度</span></span><br><span class="line">crime.df$lon=crime.df$X</span><br><span class="line">crime.df$lat=crime.df$Y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得San Francisco地图</span></span><br><span class="line">SFMap &lt;- qmap(<span class="string">'San Francisco'</span>, zoom = <span class="number">13</span>, color = <span class="string">'bw'</span>, legend = <span class="string">'topleft'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Map from URL : http://maps.googleapis.com/maps/api/staticmap?center=San+Francisco&#38;zoom=13&#38;size=%20640x640&#38;scale=%202&#38;maptype=terrain&#38;sensor=false&#10;## Google Maps API Terms of Service : http://developers.google.com/maps/terms&#10;## Information from URL : http://maps.googleapis.com/maps/api/geocode/json?address=San+Francisco&#38;sensor=false&#10;## Google Maps API Terms of Service : http://developers.google.com/maps/terms</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制密度图</span></span><br><span class="line">p2=SFMap+</span><br><span class="line">  geom_density2d(data=crime.df.vehicle,aes(group=<span class="number">1</span>))+</span><br><span class="line">  stat_density2d(data=crime.df.vehicle,aes(group=<span class="number">1</span>,fill=..level..,</span><br><span class="line">                                           alpha=..level..),</span><br><span class="line">                 size=<span class="number">0.01</span>,bins=<span class="number">16</span>,geom=<span class="string">'polygon'</span>)+</span><br><span class="line">  scale_fill_gradient(low=<span class="string">"green"</span>,high=<span class="string">"red"</span>)+</span><br><span class="line">  scale_alpha(range=c(<span class="number">0.00</span>,<span class="number">0.25</span>),guide=<span class="literal">FALSE</span>)+</span><br><span class="line">  theme(legend.position=<span class="string">"none"</span>,axis.title=element_blank(),</span><br><span class="line">        text=element_text(size=<span class="number">12</span>))+</span><br><span class="line">  ggtitle(<span class="string">"Vehicle Theft"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">multiplot(p1, p2,  cols=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Loading required package: grid</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Error: object &#39;lon&#39; not found</span><br></pre></td></tr></table></figure>
<p><img src="/img/project/SF/vehicle-theft-map.png" alt="VEHICLE THEFT"> </p>
<p>显然Ingleside,Mission,Bayview去案件更多，密度图也反映了相同信息</p>
<h1 id="SF_u6700_u5B89_u5168_u7684_u5730_u65B9_u662F_u54EA_u91CC_3F__u6BCF_u5468_u7684_u54EA_u5929/_u54EA_u4E2A_u65F6_u95F4_u6700_u5371_u9669_3F"><a href="#SF_u6700_u5B89_u5168_u7684_u5730_u65B9_u662F_u54EA_u91CC_3F__u6BCF_u5468_u7684_u54EA_u5929/_u54EA_u4E2A_u65F6_u95F4_u6700_u5371_u9669_3F" class="headerlink" title="SF最安全的地方是哪里? 每周的哪天/哪个时间最危险?"></a>SF最安全的地方是哪里? 每周的哪天/哪个时间最危险?</h1><p>先按照每个区计算案件数目</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">crime.by.district=crime.df %&gt;% group_by(PdDistrict)%&gt;%summarise(count=n())</span><br><span class="line">crime.by.district$PdDistrict=order.level(crime.by.district$PdDistrict,</span><br><span class="line">                                         crime.by.district$count)</span><br><span class="line">p1=qplot(crime.by.district$PdDistrict,data=crime.by.district,</span><br><span class="line">      weight=crime.by.district$count,geom=<span class="string">"histogram"</span>,</span><br><span class="line">      xlab=<span class="string">"District"</span>,ylab=<span class="string">"# of Crimes"</span>,main=<span class="string">"# of Crimes by District"</span>)</span><br></pre></td></tr></table></figure>
<p>根据每天来统计</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">crime.by.day=crime.df %&gt;% group_by(DayOfWeek)%&gt;%summarise(count=n())</span><br><span class="line">crime.by.day$DayOfWeek=order.level(crime.by.day$DayOfWeek,</span><br><span class="line">                                   crime.by.day$count)</span><br><span class="line">p2=qplot(crime.by.day$DayOfWeek,data=crime.by.day,</span><br><span class="line">      weight=crime.by.day$count,geom=<span class="string">"histogram"</span>,</span><br><span class="line">      xlab=<span class="string">"Day of Week"</span>,ylab=<span class="string">"# of Crimes"</span>,main=<span class="string">"# of Crimes by Day"</span>)</span><br></pre></td></tr></table></figure>
<p>按照犯罪时间统计</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">crime.by.time=crime.df %&gt;% group_by(Hour)%&gt;%summarise(count=n())</span><br><span class="line">crime.by.time$Hour=order.level(crime.by.time$Hour,</span><br><span class="line">                               crime.by.time$count)</span><br><span class="line">p3=qplot(crime.by.time$Hour,data=crime.by.time,</span><br><span class="line">      weight=crime.by.time$count,geom=<span class="string">"histogram"</span>,</span><br><span class="line">      xlab=<span class="string">"Time"</span>,ylab=<span class="string">"# of Crimes"</span>,main=<span class="string">"# of Crimes by Time"</span>)</span><br><span class="line"></span><br><span class="line">multiplot(p1, p2,p3  ,cols=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/project/SF/crime-dist-day-time.png" alt="犯罪区域，日期，时间分析"> </p>
<p>Richmond和Park区域是最安全的地方，案件什么少于了200.而案件发生的日期显然没有太明显规律，周一到周日基本都在4000左右。相反案件发生时间有高峰期和低点，18:00pm~19:00pm(2087),17:00~18:00pm(2022),19:00pm~20:00pm(1838)是典型的高峰，而04:00am~06:00am(&lt;400)则是低点.</p>
<h1 id="u67D0_u79CD_u7279_u5B9A_u5077_u7A83_u6848_u4EF6_u662F_u5426_u5728_u67D0_u4E2A_u533A_u57DF_u66F4_u666E_u904D_3F"><a href="#u67D0_u79CD_u7279_u5B9A_u5077_u7A83_u6848_u4EF6_u662F_u5426_u5728_u67D0_u4E2A_u533A_u57DF_u66F4_u666E_u904D_3F" class="headerlink" title="某种特定偷窃案件是否在某个区域更普遍?"></a>某种特定偷窃案件是否在某个区域更普遍?</h1><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">theft.filter=grep(<span class="string">"THEFT"</span>,as.character(crime.df$Category))</span><br><span class="line">crime.by.theft=crime.df[theft.filter,]</span><br><span class="line"></span><br><span class="line"><span class="comment"># get the crime by district and category</span></span><br><span class="line">crime.by.group=crime.by.theft %&gt;% group_by(PdDistrict,Category)%&gt;%summarise(count=n())%&gt;%arrange(Category,desc(count))</span><br><span class="line"><span class="comment"># sum the count by crime category</span></span><br><span class="line">crime.by.number=crime.by.theft%&gt;%group_by(Category)%&gt;%summarise(count=n())%&gt;%arrange(desc(count))</span><br><span class="line"></span><br><span class="line">ggplot(crime.by.group,</span><br><span class="line">       aes(x=Category,fill=PdDistrict,weight=count))+</span><br><span class="line">  geom_histogram(position=<span class="string">"fill"</span>,col=gray(<span class="number">0.2</span>))+</span><br><span class="line">  ylab(label=<span class="string">"Ratio by District"</span>)+</span><br><span class="line">  theme_tufte()</span><br></pre></td></tr></table></figure>
<p><img src="/img/project/SF/crime-type-district.png" alt="不同偷窃案件发生区域对比"> </p>
<p>larcen/theft 在Southern和 Central 区域更普遍，而vehicle theft则在Ingleside,Misson 和 Tenderloin区域更普遍。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/数据科学/">数据科学</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/R/">R</a><a href="/tags/data-science/">data science</a><a href="/tags/可视化/">可视化</a><a href="/tags/数据科学/">数据科学</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/10/07/2014-10-07-SF-crime/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/10/07/2014-10-07-SF-crime/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/09/28/2014-09-28-R语言数据挖掘与机器学习实战/" title="R语言数据挖掘与机器学习实战培训(计划中)" itemprop="url">R语言数据挖掘与机器学习实战培训(计划中)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="中继点" target="_blank" itemprop="author">中继点</a>
		
  <p class="article-time">
    <time datetime="2014-09-28T08:05:35.000Z" itemprop="datePublished"> 發表於 2014 Sep 28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>计划整理一个R语言数据挖掘与机器学习实战的培训，大致规划内容如下：</p>
<h1 id="u673A_u5668_u5B66_u4E60_u7B80_u4ECB"><a href="#u673A_u5668_u5B66_u4E60_u7B80_u4ECB" class="headerlink" title="机器学习简介"></a>机器学习简介</h1><ul>
<li>机器学习起源</li>
<li>什么是机器学习</li>
<li>机器学习的分类</li>
<li>R提供的机器学习工具</li>
</ul>
<h1 id="u5229_u7528R_u7BA1_u7406_u4E0E_u7EDF_u8BA1_u6570_u636E"><a href="#u5229_u7528R_u7BA1_u7406_u4E0E_u7EDF_u8BA1_u6570_u636E" class="headerlink" title="利用R管理与统计数据"></a>利用R管理与统计数据</h1><ul>
<li>R数据类型：Vector,Factor,List,Data Frame</li>
<li>R数据管理：数据读入，存储，R访问数据库</li>
<li>探索与理解数据<ul>
<li>数据结构</li>
<li>中心趋势，分布</li>
<li>可视化：boxplot,histogram</li>
<li>分组变量</li>
<li>变量关系</li>
</ul>
</li>
<li>dplyr/tidyR</li>
</ul>
<h1 id="u56DE_u5F52"><a href="#u56DE_u5F52" class="headerlink" title="回归"></a>回归</h1><ul>
<li>线性回归简介</li>
<li>实战：预测房价，预测酒的质量</li>
<li>作业：UCI机器学习库中选择一个数据集利用回归方法进行预测，提交报告以及代码</li>
</ul>
<h1 id="kNN__u6700_u8FD1_u90BB_u5C45_u5206_u7C7B"><a href="#kNN__u6700_u8FD1_u90BB_u5C45_u5206_u7C7B" class="headerlink" title="kNN 最近邻居分类"></a>kNN 最近邻居分类</h1><ul>
<li>kNN原理介绍</li>
<li>实战讲解：利用kNN诊断乳腺癌</li>
<li>作业：UCI机器学习库中选择一个分类数据集利用kNN进行分类，提交报告以及代码</li>
</ul>
<h1 id="u6734_u7D20_u8D1D_u53F6_u65AF_u5206_u7C7B"><a href="#u6734_u7D20_u8D1D_u53F6_u65AF_u5206_u7C7B" class="headerlink" title="朴素贝叶斯分类"></a>朴素贝叶斯分类</h1><ul>
<li>贝叶斯算法简介</li>
<li>实战讲解：利用朴素贝叶斯进行垃圾短信判断</li>
<li>作业：UCI机器学习库中选择一个分类数据集利用朴素贝叶斯进行分类，提交报告以及代码</li>
</ul>
<h1 id="u51B3_u7B56_u6811"><a href="#u51B3_u7B56_u6811" class="headerlink" title="决策树"></a>决策树</h1><ul>
<li>决策树原理介绍</li>
<li>实战讲解：信用卡坏账判断</li>
<li>作业：UCI机器学习库中选择一个数据集利用决策树进行分类，提交报告以及代码</li>
</ul>
<h1 id="Classification_Rules"><a href="#Classification_Rules" class="headerlink" title="Classification Rules"></a>Classification Rules</h1><ul>
<li>Classification Rule原理</li>
<li>实战：判断哪些蘑菇是毒蘑菇</li>
<li>作业：UCI机器学习库中选择一个数据集利用classification rule进行分类，提交报告以及代码</li>
</ul>
<h1 id="u903B_u8F91_u56DE_u5F52"><a href="#u903B_u8F91_u56DE_u5F52" class="headerlink" title="逻辑回归"></a>逻辑回归</h1><ul>
<li>逻辑回归原理</li>
<li>实战：不同法官，人种死刑判断</li>
<li>作业：UCI机器学习库选择一个数据集利用逻辑回归进行预测，提交报告以及代码</li>
</ul>
<h1 id="u5206_u7C7B_u6A21_u578B_u8BC4_u4F30"><a href="#u5206_u7C7B_u6A21_u578B_u8BC4_u4F30" class="headerlink" title="分类模型评估"></a>分类模型评估</h1><ul>
<li>confusion矩阵</li>
<li>Kappa统计</li>
<li>Sensitivity/Specificity</li>
<li>ROC曲线</li>
<li>CV以及Bootstrap</li>
</ul>
<h1 id="u795E_u7ECF_u7F51_u7EDC"><a href="#u795E_u7ECF_u7F51_u7EDC" class="headerlink" title="神经网络"></a>神经网络</h1><ul>
<li>神经网络原理简介</li>
<li>实战：利用神经网络判断水泥强度</li>
<li>作业：UCI机器学习库中选择一个数据集利用神经网络进行预测，提交报告以及代码</li>
</ul>
<h1 id="u652F_u6301_u5411_u91CF_u673A_uFF08SVM_uFF09"><a href="#u652F_u6301_u5411_u91CF_u673A_uFF08SVM_uFF09" class="headerlink" title="支持向量机（SVM）"></a>支持向量机（SVM）</h1><ul>
<li>支持向量机简介</li>
<li>实战：利用SVM识别手写字母</li>
<li>作业：UCI机器学习库中选择一个数据集利用SVM进行预测，提交报告以及代码</li>
</ul>
<h1 id="u5173_u8054_28association_rule_29"><a href="#u5173_u8054_28association_rule_29" class="headerlink" title="关联(association rule)"></a>关联(association rule)</h1><ul>
<li>Apriori简介</li>
<li>实战：利用商场销售记录来获得用户购买模式</li>
<li>作业：UCI机器学习库中选择一个数据集进行market basket分析，提交报告以及代码</li>
</ul>
<h1 id="u805A_u7C7B_uFF08k-means_29"><a href="#u805A_u7C7B_uFF08k-means_29" class="headerlink" title="聚类（k-means)"></a>聚类（k-means)</h1><ul>
<li>k-means简介</li>
<li>实战：对社交用户进行聚类分析</li>
<li>作业：UCI机器学习库中选择一个数据集进行clustering分析，提交报告以及代码</li>
</ul>
<h1 id="u6587_u672C_u5206_u6790"><a href="#u6587_u672C_u5206_u6790" class="headerlink" title="文本分析"></a>文本分析</h1><ul>
<li>tm包介绍</li>
<li>实战：这是谁的发言，奥巴马还是罗姆尼</li>
<li>作业：微博文本分析</li>
</ul>
<h1 id="u6A21_u578B_u4F18_u5316"><a href="#u6A21_u578B_u4F18_u5316" class="headerlink" title="模型优化"></a>模型优化</h1><ul>
<li>模型参数调优</li>
<li>背包(Bagging)</li>
<li>Boosting</li>
<li>随机森林(random forest)</li>
<li>作业: Kaggle上的自行车租用预测竞赛</li>
</ul>
<h1 id="u51E0_u70B9_u8BF4_u660E"><a href="#u51E0_u70B9_u8BF4_u660E" class="headerlink" title="几点说明"></a>几点说明</h1><p>问：什么时候开始？  </p>
<p>目前不确定，如果有兴趣的人能达到50人就考虑吧。  </p>
<p>问：收费吗？</p>
<p>或者您可以考虑来做一个免费的？</p>
<p>目前的打算：也许会考虑预收点，39～49待定（已经够低了吧，呜呜），或者最后会退，如果你完成作业很好的话。原因：</p>
<ul>
<li>之前做免费R数据分析培训的教训，大家报名的时候积极，讲了4～5次，交作业之类就不积极了，所以可能会考虑一个措施来解决这个问题，因为作业比较多，都自己动手才能真的学有所得</li>
<li>如果真准备这个培训，花的准备时间肯定不少，算是劳动的一点点回报吧。而且收这点费用&lt;&lt;&lt;我干别的事情获得的收入。</li>
<li>你可以先听2～3次后，再做决定是否继续听</li>
</ul>
<p>问：MOOC上有很多免费课程，为何还要准备这个课程</p>
<p>这个与MOOC上的课有些地方有相似，不过目标稍有不同。主要目标是保证R的初学者能较快的掌握利用R来进行机器学习，会比Coursera上的机器学习课更偏向实际应用，同时比约翰霍普金斯的数据科学系列课程中的R编程，以及机器学习更详细，深入一些。如果你的自学能力还好，个人觉得可以直接听免费的MOOC课。</p>
<p>问：如何组织</p>
<p>打算考虑采用QQ群视频方式进行。计划每周1次课，每次课完了后有作业，安排一次作业讨论。</p>
<p>问：如果我有兴趣，怎么报名</p>
<p>目前还没有确定会进行，可以先加入群 397066090，如果感兴趣的人多再说。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/数据科学/">数据科学</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/R/">R</a><a href="/tags/培训/">培训</a><a href="/tags/机器学习/">机器学习</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/09/28/2014-09-28-R语言数据挖掘与机器学习实战/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/09/28/2014-09-28-R语言数据挖掘与机器学习实战/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/09/17/2014-09-17-kaggle-titanic/" title="Kaggle上的泰坦尼克生还数据分析" itemprop="url">Kaggle上的泰坦尼克生还数据分析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="中继点" target="_blank" itemprop="author">中继点</a>
		
  <p class="article-time">
    <time datetime="2014-09-17T03:28:30.000Z" itemprop="datePublished"> 發表於 2014 Sep 17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="u6570_u636E_u51C6_u5907"><a href="#u6570_u636E_u51C6_u5907" class="headerlink" title="数据准备"></a>数据准备</h1><p>先根据数据的codebook来给每列命名，同时预先设定类型</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">setwd(<span class="string">"d:/course/kaggle/titanic/"</span>)</span><br><span class="line">train.col.types &lt;- c(<span class="string">'integer'</span>, <span class="comment"># PassengerId</span></span><br><span class="line">  <span class="string">'factor'</span>, <span class="comment"># Survived</span></span><br><span class="line">  <span class="string">'factor'</span>, <span class="comment"># Pclass</span></span><br><span class="line">  <span class="string">'character'</span>, <span class="comment"># Name</span></span><br><span class="line">  <span class="string">'factor'</span>, <span class="comment"># Sex</span></span><br><span class="line">  <span class="string">'numeric'</span>, <span class="comment"># Age</span></span><br><span class="line">  <span class="string">'integer'</span>, <span class="comment"># SibSp</span></span><br><span class="line">  <span class="string">'integer'</span>, <span class="comment"># Parch</span></span><br><span class="line">  <span class="string">'character'</span>, <span class="comment"># Ticket</span></span><br><span class="line">  <span class="string">'numeric'</span>, <span class="comment"># Fare</span></span><br><span class="line">  <span class="string">'character'</span>, <span class="comment"># Cabin</span></span><br><span class="line">  <span class="string">'factor'</span> <span class="comment"># Embarked</span></span><br><span class="line">)</span><br><span class="line">test.col.types=train.col.types[-<span class="number">2</span>]</span><br><span class="line">train.raw=read.csv(<span class="string">"./train.csv"</span>,colClasses=train.col.types,na.strings=c(<span class="string">"NA"</span>,<span class="string">""</span>))</span><br><span class="line">test.raw=read.csv(<span class="string">"./test.csv"</span>,colClasses=test.col.types,na.strings=c(<span class="string">"NA"</span>,<span class="string">""</span>))</span><br><span class="line">dim(train.raw)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 891  12</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dim(test.raw)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 418  11</span><br></pre></td></tr></table></figure>
<p>这里预先设定了每列的class，之后读入数据。train数据集为891行12列大小矩阵，测试数据集418行，11列（没有了是否生还的列）</p>
<h1 id="u6570_u636E_u63A2_u7D22"><a href="#u6570_u636E_u63A2_u7D22" class="headerlink" title="数据探索"></a>数据探索</h1><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">summary(train.raw)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##   PassengerId  Survived Pclass      Name               Sex     &#10;##  Min.   :  1   0:549    1:216   Length:891         female:314  &#10;##  1st Qu.:224   1:342    2:184   Class :character   male  :577  &#10;##  Median :446            3:491   Mode  :character               &#10;##  Mean   :446                                                   &#10;##  3rd Qu.:668                                                   &#10;##  Max.   :891                                                   &#10;##                                                                &#10;##       Age            SibSp           Parch          Ticket         &#10;##  Min.   : 0.42   Min.   :0.000   Min.   :0.000   Length:891        &#10;##  1st Qu.:20.12   1st Qu.:0.000   1st Qu.:0.000   Class :character  &#10;##  Median :28.00   Median :0.000   Median :0.000   Mode  :character  &#10;##  Mean   :29.70   Mean   :0.523   Mean   :0.382                     &#10;##  3rd Qu.:38.00   3rd Qu.:1.000   3rd Qu.:0.000                     &#10;##  Max.   :80.00   Max.   :8.000   Max.   :6.000                     &#10;##  NA&#39;s   :177                                                       &#10;##       Fare          Cabin           Embarked  &#10;##  Min.   :  0.0   Length:891         C   :168  &#10;##  1st Qu.:  7.9   Class :character   Q   : 77  &#10;##  Median : 14.5   Mode  :character   S   :644  &#10;##  Mean   : 32.2                      NA&#39;s:  2  &#10;##  3rd Qu.: 31.0                                &#10;##  Max.   :512.3                                &#10;##</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">summary(test.raw)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##   PassengerId   Pclass      Name               Sex           Age       &#10;##  Min.   : 892   1:107   Length:418         female:152   Min.   : 0.17  &#10;##  1st Qu.: 996   2: 93   Class :character   male  :266   1st Qu.:21.00  &#10;##  Median :1100   3:218   Mode  :character                Median :27.00  &#10;##  Mean   :1100                                           Mean   :30.27  &#10;##  3rd Qu.:1205                                           3rd Qu.:39.00  &#10;##  Max.   :1309                                           Max.   :76.00  &#10;##                                                         NA&#39;s   :86     &#10;##      SibSp           Parch          Ticket               Fare      &#10;##  Min.   :0.000   Min.   :0.000   Length:418         Min.   :  0.0  &#10;##  1st Qu.:0.000   1st Qu.:0.000   Class :character   1st Qu.:  7.9  &#10;##  Median :0.000   Median :0.000   Mode  :character   Median : 14.5  &#10;##  Mean   :0.447   Mean   :0.392                      Mean   : 35.6  &#10;##  3rd Qu.:1.000   3rd Qu.:0.000                      3rd Qu.: 31.5  &#10;##  Max.   :8.000   Max.   :9.000                      Max.   :512.3  &#10;##                                                     NA&#39;s   :1      &#10;##     Cabin           Embarked&#10;##  Length:418         C:102   &#10;##  Class :character   Q: 46   &#10;##  Mode  :character   S:270   &#10;##                             &#10;##                             &#10;##                             &#10;##</span><br></pre></td></tr></table></figure>
<p>这里看出Age有177个缺失，占比比较大，而对于character变量Cabin，Name等没有相关信息，一个简单的查看缺失数据的方法就是采用missamp()函数</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span>(Amelia)</span><br><span class="line">missmap(train.raw, main=<span class="string">"Titanic缺失数据图"</span>,</span><br><span class="line">        col=c(<span class="string">"yellow"</span>, <span class="string">"black"</span>), legend=<span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/kaggle/titanic/unnamed-chunk-3.png" alt=""> </p>
<p>这里看出Cabin，Age有较多缺失数据，而Embark只有两个缺失数据。</p>
<p>接下来先简单分析一下数据，比如生还与死亡的比例，不同等级(Pclass)对生还有无影响，我们知道老人，妇女，小孩会优先所以看看性别，年龄是否有影响，此外票的价钱有关吗（fare）？当然可能还有其它的变量，这里我们就不一一列举…</p>
<h2 id="u751F_u8FD8_u4E0E_u6B7B_u4EA1_u5BF9_u6BD4"><a href="#u751F_u8FD8_u4E0E_u6B7B_u4EA1_u5BF9_u6BD4" class="headerlink" title="生还与死亡对比"></a>生还与死亡对比</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">barplot(table(train.raw$Survived),names.arg=c(<span class="string">"死亡"</span>,<span class="string">"生还"</span>),</span><br><span class="line">        main=<span class="string">"生还 vs 死亡"</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/kaggle/titanic/unnamed-chunk-4.png" alt=""> </p>
<h2 id="u4E0D_u540C_u8231_u4F4D_u7B49_u7EA7_u7684_u5F71_u54CD"><a href="#u4E0D_u540C_u8231_u4F4D_u7B49_u7EA7_u7684_u5F71_u54CD" class="headerlink" title="不同舱位等级的影响"></a>不同舱位等级的影响</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">survive.rate.class=table(train.raw$Survived,train.raw$Pclass)</span><br><span class="line">barplot(survive.rate.class,names.arg=c(<span class="string">"一等"</span>,<span class="string">"二等"</span>,<span class="string">"三等"</span>),</span><br><span class="line">        main=<span class="string">"不同舱位生还 vs 死亡"</span>,</span><br><span class="line">        legend.text=c(<span class="string">"死亡"</span>,<span class="string">"生还"</span>),</span><br><span class="line">        args.legend=list(x=<span class="string">"topleft"</span>))</span><br></pre></td></tr></table></figure>
<p><img src="/img/kaggle/titanic/unnamed-chunk-5.png" alt=""> </p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">round((survive.rate.class[<span class="number">2</span>,]/colSums(survive.rate.class))*<span class="number">100</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##     1     2     3 &#10;## 62.96 47.28 24.24</span><br></pre></td></tr></table></figure>
<p>看起来一等舱，二等舱显然比三等舱要高。如果按照比例来看各舱位生还的比例依次为：62.96%,47.28,24.24%。除了舱位等级好的在越上面，跑得快，下面的先被淹外，估计这个也和当时发生事故的时间在睡觉有关系。</p>
<h2 id="u4E0D_u540C_u6027_u522B_u7684_u751F_u8FD8_u7387_u5BF9_u6BD4"><a href="#u4E0D_u540C_u6027_u522B_u7684_u751F_u8FD8_u7387_u5BF9_u6BD4" class="headerlink" title="不同性别的生还率对比"></a>不同性别的生还率对比</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">survive.rate.sex=table(train.raw$Survived,train.raw$Sex)</span><br><span class="line">barplot(survive.rate.sex,names.arg=c(<span class="string">"女"</span>,<span class="string">"男"</span>),</span><br><span class="line">        main=<span class="string">"不同性别生还 vs 死亡"</span>,</span><br><span class="line">        legend.text=c(<span class="string">"死亡"</span>,<span class="string">"生还"</span>),</span><br><span class="line">        args.legend=list(x=<span class="string">"topleft"</span>))</span><br></pre></td></tr></table></figure>
<p><img src="/img/kaggle/titanic/unnamed-chunk-6.png" alt=""> </p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">round((survive.rate.sex[<span class="number">2</span>,]/colSums(survive.rate.sex))*<span class="number">100</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## female   male &#10;##  74.20  18.89</span><br></pre></td></tr></table></figure>
<p>看来在生与死的选择时男人们还是发扬了高风亮节！女性生还率达到了74.2%，男性只有18.89%</p>
<h2 id="u4E0D_u540C_u5E74_u9F84_u7684_u751F_u8FD8_u7387"><a href="#u4E0D_u540C_u5E74_u9F84_u7684_u751F_u8FD8_u7387" class="headerlink" title="不同年龄的生还率"></a>不同年龄的生还率</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">age.breaker=c(<span class="number">0</span>,<span class="number">18</span>,<span class="number">50</span>,<span class="number">100</span>)</span><br><span class="line">age.cut= cut(train.raw$Age,breaks=age.breaker,,labels=c(<span class="string">"小孩"</span>,<span class="string">"成年人"</span>,<span class="string">"老人"</span>))</span><br><span class="line">train.raw$age.cut=age.cut</span><br><span class="line">survive.rate.age=table(train.raw$Survived,train.raw$age.cut)</span><br><span class="line">barplot(survive.rate.age,</span><br><span class="line">        main=<span class="string">"不同年龄生还 vs 死亡"</span>,</span><br><span class="line">        legend.text=c(<span class="string">"死亡"</span>,<span class="string">"生还"</span>),</span><br><span class="line">        args.legend=list(x=<span class="string">"topleft"</span>))</span><br></pre></td></tr></table></figure>
<p><img src="/img/kaggle/titanic/unnamed-chunk-71.png" alt=""> </p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">round((survive.rate.age[<span class="number">2</span>,]/colSums(survive.rate.age))*<span class="number">100</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##   &#23567;&#23401; &#25104;&#24180;&#20154;   &#32769;&#20154; &#10;##  50.36  38.75  34.38</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">age.breaker=c(<span class="number">0</span>,<span class="number">15</span>,<span class="number">55</span>,<span class="number">100</span>)</span><br><span class="line">age.cut= cut(train.raw$Age,breaks=age.breaker,,labels=c(<span class="string">"小孩"</span>,<span class="string">"成年人"</span>,<span class="string">"老人"</span>))</span><br><span class="line">train.raw$age.cut=age.cut</span><br><span class="line">survive.rate.age=table(train.raw$Survived,train.raw$age.cut)</span><br><span class="line">barplot(survive.rate.age,</span><br><span class="line">        main=<span class="string">"不同年龄生还 vs 死亡"</span>,</span><br><span class="line">        legend.text=c(<span class="string">"死亡"</span>,<span class="string">"生还"</span>),</span><br><span class="line">        args.legend=list(x=<span class="string">"topleft"</span>))</span><br></pre></td></tr></table></figure>
<p><img src="/img/kaggle/titanic/unnamed-chunk-72.png" alt=""> </p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">round((survive.rate.age[<span class="number">2</span>,]/colSums(survive.rate.age))*<span class="number">100</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##   &#23567;&#23401; &#25104;&#24180;&#20154;   &#32769;&#20154; &#10;##  59.04  38.75  30.00</span><br></pre></td></tr></table></figure>
<p>这里分别用15和18来作为小孩的判断标准，50，55分别作为老人判断标准。可以看出小孩的生还率分别为59.04%与50.36%，生还率最高。而老人的生还率却比成年人低，也许是年龄大了的影响？</p>
<h2 id="u9A6C_u8D5B_u514B_u56FE"><a href="#u9A6C_u8D5B_u514B_u56FE" class="headerlink" title="马赛克图"></a>马赛克图</h2><p>还有一种更好的方法就是利用mosaicplot图</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mosaicplot(train.raw$Pclass ~ train.raw$Survived,</span><br><span class="line">           main=<span class="string">"不同舱位等级生还 vs 死亡 "</span>, shade=<span class="literal">FALSE</span>,</span><br><span class="line">           color=<span class="literal">TRUE</span>, xlab=<span class="string">"舱位"</span>, ylab=<span class="string">"生还"</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/kaggle/titanic/unnamed-chunk-81.png" alt=""> </p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mosaicplot(train.raw$Sex ~ train.raw$Survived,</span><br><span class="line">           main=<span class="string">"不同性别生还 vs 死亡 "</span>, shade=<span class="literal">FALSE</span>,</span><br><span class="line">           color=<span class="literal">TRUE</span>, xlab=<span class="string">"性别"</span>, ylab=<span class="string">"生还"</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/kaggle/titanic/unnamed-chunk-82.png" alt=""> </p>
<h2 id="u76F8_u5173_u6027_u5206_u6790"><a href="#u76F8_u5173_u6027_u5206_u6790" class="headerlink" title="相关性分析"></a>相关性分析</h2><p>前面大致可以得出性别，年龄，舱位对生还率有很大影响，那么其他的票价，上船的港口，在那个cabin等等变量对生还率有影响吗？这里用相关性分析来观察一下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">train.corrgram = train.raw</span><br><span class="line"><span class="comment"># 相关性分析要求全部为数字</span></span><br><span class="line">train.corrgram$Survived &lt;- as.numeric(train.corrgram$Survived)</span><br><span class="line">train.corrgram$Pclass &lt;- as.numeric(train.corrgram$Pclass)</span><br><span class="line">train.corrgram$Embarked &lt;- as.numeric(train.corrgram$Embarked)</span><br><span class="line">train.corrgram$Sex &lt;- as.numeric(train.corrgram$Sex)</span><br><span class="line">train.corrgram[which(is.na(train.corrgram$Embarked)),]$Embarked=<span class="number">3</span></span><br><span class="line">cor(train.corrgram[,corrgram.vars])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Error: object &#39;corrgram.vars&#39; not found</span><br></pre></td></tr></table></figure>
<p>这里大致可以看出除了Pclass,Sex,Age以为，Fare还和生还率有关，而Embarked似乎也有一定关系（虽然理论上来讲登船地点应该与这个无关？）而Age由于有大量缺失值这里相关性为NA,下一步的目标似乎应该是在于如何处理这些缺失的数据上面。</p>
<p>图形分析也许更简单快捷，直接使用<code>corrgram</code>来分析。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span>(corrgram)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Loading required package: corrgram&#10;## Loading required package: seriation</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符变量这里不考虑</span></span><br><span class="line">corrgram.vars = c(<span class="string">"Survived"</span>, <span class="string">"Pclass"</span>, <span class="string">"Sex"</span>, <span class="string">"Age"</span>,</span><br><span class="line">                   <span class="string">"SibSp"</span>, <span class="string">"Parch"</span>, <span class="string">"Fare"</span>, <span class="string">"Embarked"</span>)</span><br><span class="line">corrgram(train.corrgram[,corrgram.vars], lower.panel=panel.ellipse, </span><br><span class="line">         upper.panel=panel.pie,text.panel=panel.txt, main=<span class="string">"泰坦尼克生还率相关性分析"</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/kaggle/titanic/unnamed-chunk-10.png" alt="0"> </p>
<h1 id="u521D_u6B21_u5EFA_u6A21"><a href="#u521D_u6B21_u5EFA_u6A21" class="headerlink" title="初次建模"></a>初次建模</h1><p>有了前面的探索性分析，大致我们对数据有了一定了解，考虑先建立一个模型来进行一次初步预测。显然我们需要处理的问题是一个分类为题，首先想到的方法有逻辑回归，决策树，classification rule，更高级的可以考虑采用boost，随机森林。这里我们先考虑从简单的逻辑回归开始。</p>
<h2 id="u6784_u5EFA_u8BAD_u7EC3_u96C6_u4E0E_u6D4B_u8BD5_u96C6"><a href="#u6784_u5EFA_u8BAD_u7EC3_u96C6_u4E0E_u6D4B_u8BD5_u96C6" class="headerlink" title="构建训练集与测试集"></a>构建训练集与测试集</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span>(caret)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Loading required package: caret&#10;## Loading required package: lattice&#10;## &#10;## Attaching package: &#39;lattice&#39;&#10;## &#10;## The following object is masked from &#39;package:seriation&#39;:&#10;## &#10;##     panel.lines&#10;## &#10;## Loading required package: ggplot2</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set.seed(<span class="number">201409</span>)</span><br><span class="line">inTrain = createDataPartition(train.raw$Survived,</span><br><span class="line">                                     p = <span class="number">0.8</span>, list = <span class="literal">FALSE</span>)</span><br><span class="line">training = train.raw[inTrain, ]</span><br><span class="line">test = train.raw[-inTrain, ]</span><br></pre></td></tr></table></figure>
<h2 id="u7B2C_u4E00_u4E2A_u6A21_u578B"><a href="#u7B2C_u4E00_u4E2A_u6A21_u578B" class="headerlink" title="第一个模型"></a>第一个模型</h2><p>互联网时代来临之前，人们的收入通常和年龄相关，因此对缺失数据较多的年龄我们先根据不同等级来填充一个估计值。这里直接使用median。</p>
<p>另外这里还计算了3等舱的价格的median，因为我们发现测试集里面有一个记录的Fare值缺失。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">first.class.age=median(training[training$Pclass==<span class="string">"1"</span>,]$Age,na.rm=<span class="literal">T</span>)</span><br><span class="line">second.class.age=median(training[training$Pclass==<span class="string">"2"</span>,]$Age,na.rm=<span class="literal">T</span>)</span><br><span class="line">third.class.age=median(training[training$Pclass==<span class="string">"1"</span>,]$Age,na.rm=<span class="literal">T</span>)</span><br><span class="line">training[is.na(training$Age)&amp;training$Pclass==<span class="string">"1"</span>,]$Age=first.class.age</span><br><span class="line">training[is.na(training$Age)&amp;training$Pclass==<span class="string">"2"</span>,]$Age=second.class.age</span><br><span class="line">training[is.na(training$Age)&amp;training$Pclass==<span class="string">"3"</span>,]$Age=third.class.age</span><br><span class="line">third.class.fare=median(training[training$Pclass==<span class="string">"3"</span>,]$Fare,na.rm=<span class="literal">T</span>)</span><br><span class="line">model.logit.1 &lt;- train(Survived ~ Sex + Pclass + Age + Embarked + Fare,</span><br><span class="line">                     data = training, method=<span class="string">"glm"</span>)</span><br><span class="line"></span><br><span class="line">model.logit.1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Generalized Linear Model &#10;## &#10;## 714 samples&#10;##  12 predictors&#10;##   2 classes: &#39;0&#39;, &#39;1&#39; &#10;## &#10;## No pre-processing&#10;## Resampling: Bootstrapped (25 reps) &#10;## &#10;## Summary of sample sizes: 712, 712, 712, 712, 712, 712, ... &#10;## &#10;## Resampling results&#10;## &#10;##   Accuracy  Kappa  Accuracy SD  Kappa SD&#10;##   0.8       0.6    0.02         0.05    &#10;## &#10;##</span><br></pre></td></tr></table></figure>
<p>模型accuracy为0.8,kappa 为0.6，采用了bootstrap 采样方式。作为我们的第一个模型看起来还不错</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">first.class.age=median(test[test$Pclass==<span class="string">"1"</span>,]$Age,na.rm=<span class="literal">T</span>)</span><br><span class="line">second.class.age=median(test[test$Pclass==<span class="string">"2"</span>,]$Age,na.rm=<span class="literal">T</span>)</span><br><span class="line">third.class.age=median(test[test$Pclass==<span class="string">"1"</span>,]$Age,na.rm=<span class="literal">T</span>)</span><br><span class="line">test[is.na(test$Age)&amp;test$Pclass==<span class="string">"1"</span>,]$Age=first.class.age</span><br><span class="line">test[is.na(test$Age)&amp;test$Pclass==<span class="string">"2"</span>,]$Age=second.class.age</span><br><span class="line">test[is.na(test$Age)&amp;test$Pclass==<span class="string">"3"</span>,]$Age=third.class.age</span><br><span class="line"></span><br><span class="line">predict.model.1=predict(model.logit.1,test)</span><br><span class="line">table(test$Survived,predict.model.1)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##    predict.model.1&#10;##      0  1&#10;##   0 91 18&#10;##   1 22 46</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sensitivity(test$Survived,predict.model.1)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 0.8053</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">specificity(test$Survived,predict.model.1)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 0.7188</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#require(gmodels)</span></span><br><span class="line"><span class="comment">#CrossTable(test$Survived,predict.model.1)</span></span><br></pre></td></tr></table></figure>
<p>相对我们自己构建的测试集sensitivity,specificity分别为0.8,0.71也还行。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span>(ROCR)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Loading required package: ROCR&#10;## Loading required package: gplots&#10;## KernSmooth 2.23 loaded&#10;## Copyright M. P. Wand 1997-2009&#10;## &#10;## Attaching package: &#39;gplots&#39;&#10;## &#10;## The following object is masked from &#39;package:stats&#39;:&#10;## &#10;##     lowess</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">predictions.model.1=prediction(c(predict.model.1),labels=test$Survived)</span><br><span class="line">perf = performance(predictions.model.1, measure = <span class="string">"tpr"</span>, x.measure = <span class="string">"fpr"</span>)</span><br><span class="line">plot(perf, main = <span class="string">"ROC curve"</span>,col = <span class="string">"blue"</span>, lwd = <span class="number">2</span>)</span><br><span class="line">abline(a = <span class="number">0</span>, b = <span class="number">1</span>, lwd = <span class="number">2</span>, lty = <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/kaggle/titanic/unnamed-chunk-14.png" alt="4"> </p>
<h2 id="u9884_u6D4B"><a href="#u9884_u6D4B" class="headerlink" title="预测"></a>预测</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">first.class.age=median(test.raw[test.raw$Pclass==<span class="string">"1"</span>,]$Age,na.rm=<span class="literal">T</span>)</span><br><span class="line">second.class.age=median(test.raw[test.raw$Pclass==<span class="string">"2"</span>,]$Age,na.rm=<span class="literal">T</span>)</span><br><span class="line">third.class.age=median(test.raw[test.raw$Pclass==<span class="string">"1"</span>,]$Age,na.rm=<span class="literal">T</span>)</span><br><span class="line">test.raw[is.na(test.raw$Age)&amp;test.raw$Pclass==<span class="string">"1"</span>,]$Age=first.class.age</span><br><span class="line">test.raw[is.na(test.raw$Age)&amp;test.raw$Pclass==<span class="string">"2"</span>,]$Age=second.class.age</span><br><span class="line">test.raw[is.na(test.raw$Age)&amp;test.raw$Pclass==<span class="string">"3"</span>,]$Age=third.class.age</span><br><span class="line">test.raw[<span class="number">153</span>,]$Fare=third.class.fare</span><br><span class="line">predict.final.model.1=predict(model.logit.1,newdata=test.raw)</span><br><span class="line">predictions=data.frame(PassengerId=test.raw$PassengerId, Survived=predict.final.model.1)</span><br><span class="line">write.csv(predictions,file=<span class="string">"Titanic_predictions_1.csv"</span>, row.names=<span class="literal">FALSE</span>, quote=<span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure>
<p>提交到Kaggle上，模型accuracy显示为0.77左右，排在了2000名左右的位置，显然这不是一个好的结果。不过到此为止我们还有很多事情没有做：</p>
<ul>
<li>有4个特征没有使用分别是sibsp,parch,Cabin,names。<ul>
<li>也许家人的数目会影响生还率，比如需要照顾家人或者上救生船的时候会让别的家庭成员上等等</li>
<li>Cabin这个变量虽然有很多缺失但是理论上应该也是一个关键特征，因为不同舱位对逃生影响很大</li>
<li>names看似没有用但是似乎它们都满足了 xx Title, xx xx这样一种模式，而西方人的title可以反映年龄。因此可能我们需要利用names来构建一个新变量Title</li>
</ul>
</li>
<li>对Age的插值之前我们采用了直接取不同等级舱位年龄median的方式完成，这是否是最佳，可否有更好方法？比如可以考虑根据姓名的Title来判断</li>
<li>前面的模型参数我们没有进行任何的优化，也许优化参数可以取得更好结果？</li>
<li>除了逻辑回归，我们还可以采用决策树，随机森林，boosting方法，是否这些模型会带来更好结果？</li>
</ul>
<p>这些就是下一步我们可以考虑的地方了。</p>
<h1 id="u6A21_u578B_u4F18_u5316"><a href="#u6A21_u578B_u4F18_u5316" class="headerlink" title="模型优化"></a>模型优化</h1><p>先重新读入一次数据：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">train.col.types &lt;- c(<span class="string">'integer'</span>, <span class="comment"># PassengerId</span></span><br><span class="line">  <span class="string">'factor'</span>, <span class="comment"># Survived</span></span><br><span class="line">  <span class="string">'factor'</span>, <span class="comment"># Pclass</span></span><br><span class="line">  <span class="string">'character'</span>, <span class="comment"># Name</span></span><br><span class="line">  <span class="string">'factor'</span>, <span class="comment"># Sex</span></span><br><span class="line">  <span class="string">'numeric'</span>, <span class="comment"># Age</span></span><br><span class="line">  <span class="string">'integer'</span>, <span class="comment"># SibSp</span></span><br><span class="line">  <span class="string">'integer'</span>, <span class="comment"># Parch</span></span><br><span class="line">  <span class="string">'character'</span>, <span class="comment"># Ticket</span></span><br><span class="line">  <span class="string">'numeric'</span>, <span class="comment"># Fare</span></span><br><span class="line">  <span class="string">'character'</span>, <span class="comment"># Cabin</span></span><br><span class="line">  <span class="string">'factor'</span> <span class="comment"># Embarked</span></span><br><span class="line">)</span><br><span class="line">test.col.types=train.col.types[-<span class="number">2</span>]</span><br><span class="line">train.raw=read.csv(<span class="string">"./train.csv"</span>,colClasses=train.col.types,na.strings=c(<span class="string">"NA"</span>,<span class="string">""</span>))</span><br><span class="line">test.raw=read.csv(<span class="string">"./test.csv"</span>,colClasses=test.col.types,na.strings=c(<span class="string">"NA"</span>,<span class="string">""</span>))</span><br></pre></td></tr></table></figure>
<h2 id="u6570_u636E_u6574_u7406_u4E0E_u6E05_u6D17"><a href="#u6570_u636E_u6574_u7406_u4E0E_u6E05_u6D17" class="headerlink" title="数据整理与清洗"></a>数据整理与清洗</h2><p>首先考虑前面提到的Names中的title.西方人的命名都有一定规则，首先关于Title：</p>
<ul>
<li>Mr. 更个年龄的先生</li>
<li>Miss. 未婚女士（不过女权解放的现代，好像也有已婚的用？）</li>
<li>Mrs. (已婚女士)</li>
<li>Master. (男孩，早期使用，现在应该不用了。不过泰坦尼克灾难发生时适用)</li>
<li>Rev., Col. Sir. Dr.  etc… 等大多与职业相关，应该都是男士</li>
</ul>
<p>而对西方的名字，比如：</p>
<p>Baclini, Mrs. Solomon (Latifa Qurban)</p>
<ul>
<li>Mrs. 已婚</li>
<li>Solomon ：丈夫的名字,比如Jane Smith与John Smith结婚后，她就是Mrs. John Smith.</li>
<li>Latifa : 他自己的名字</li>
<li>Qurban ：”maiden” ，结婚前的姓</li>
<li>Baclini:她丈夫的姓，也就是他丈夫Solomon的姓.</li>
</ul>
<p>有了这些基础那么我们可以想法把中间的那个Title给取出来：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这里格式是xx, Title . xx xx</span></span><br><span class="line">getTitle = <span class="keyword">function</span>(data) &#123;</span><br><span class="line">  title.start = regexpr(<span class="string">"\\,[A-Z ]&#123;1,20&#125;\\."</span>, data$Name, <span class="literal">TRUE</span>)</span><br><span class="line">  title.end = title.start+attr(title.start, <span class="string">"match.length"</span>)-<span class="number">1</span></span><br><span class="line">  data$Title = substr(data$Name, title.start+<span class="number">2</span>, title.end-<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> (data$Title)</span><br><span class="line">&#125;</span><br><span class="line">train.raw$Title=getTitle(train.raw)</span><br><span class="line"><span class="keyword">require</span>(dplyr)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Loading required package: dplyr&#10;## &#10;## Attaching package: &#39;dplyr&#39;&#10;## &#10;## The following objects are masked from &#39;package:stats&#39;:&#10;## &#10;##     filter, lag&#10;## &#10;## The following objects are masked from &#39;package:base&#39;:&#10;## &#10;##     intersect, setdiff, setequal, union</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head(train.raw %&gt;% group_by(Title) %&gt;% summarise(count=n())%&gt;%arrange(desc(count)))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Source: local data frame [6 x 2]&#10;## &#10;##    Title count&#10;## 1     Mr   517&#10;## 2   Miss   182&#10;## 3    Mrs   125&#10;## 4 Master    40&#10;## 5     Dr     7&#10;## 6    Rev     6</span><br></pre></td></tr></table></figure>
<p>主要的称呼为Mr,Miss,Mrs,Master，剩余的类型都比较少，可以归入professional一类。因此我们增加一列Title，分为Mr,Miss,Mrs,Master,Professional 5种类型。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">title.filter=c(<span class="string">"Mr"</span>,<span class="string">"Mrs"</span>,<span class="string">"Miss"</span>,<span class="string">"Master"</span>,<span class="string">"Professional"</span>)</span><br><span class="line">recodeTitle = <span class="keyword">function</span>(data,title.filter) &#123;</span><br><span class="line">  <span class="keyword">if</span>(!(data %<span class="keyword">in</span>% title.filter))</span><br><span class="line">    data = <span class="string">"Professional"</span></span><br><span class="line">  <span class="keyword">return</span> (data)</span><br><span class="line">&#125;</span><br><span class="line">train.raw$Title=sapply(train.raw$Title,recodeTitle,title.filter)</span><br></pre></td></tr></table></figure>
<p>简单利用median来对年龄进行插值,Embarked的NA直接使用“S”,fare根据class的median来计算</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">imputeAge = <span class="keyword">function</span>(Age,Title,title.filter) &#123;</span><br><span class="line">  <span class="keyword">for</span>(v <span class="keyword">in</span> title.filter) &#123;</span><br><span class="line">    Age[is.na(Age)]=median(Age[Title==v],na.rm=<span class="literal">T</span>)    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>(Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">title.filter=c(<span class="string">"Mr"</span>,<span class="string">"Mrs"</span>,<span class="string">"Miss"</span>,<span class="string">"Master"</span>,<span class="string">"Professional"</span>)</span><br><span class="line">train.raw$Age=imputeAge(train.raw$Age,train.raw$Title,title.filter)</span><br><span class="line"></span><br><span class="line">imputeEmbarked=<span class="keyword">function</span>(Embarked) &#123;</span><br><span class="line">  Embarked[is.na(Embarked)]=<span class="string">"S"</span></span><br><span class="line">  <span class="keyword">return</span>(Embarked)</span><br><span class="line">&#125;</span><br><span class="line">train.raw$Embarked=imputeEmbarked(train.raw$Embarked)</span><br><span class="line"></span><br><span class="line">imputeFare = <span class="keyword">function</span>(fare,pclass,pclass.filter) &#123;</span><br><span class="line">  <span class="keyword">for</span>(v <span class="keyword">in</span> pclass.filter) &#123;</span><br><span class="line">    fare[is.na(fare)]=median(fare[pclass==v],na.rm=<span class="literal">T</span>)    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>(fare)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pclass.filter=c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">train.raw$fare=imputeFare(train.raw$Fare,train.raw$Pclass,pclass.filter)</span><br></pre></td></tr></table></figure>
<h2 id="u7B2C_u4E8C_u4E2A_u6A21_u578B"><a href="#u7B2C_u4E8C_u4E2A_u6A21_u578B" class="headerlink" title="第二个模型"></a>第二个模型</h2><p>现在使用了新的计算确实年龄的方法，同时加上SibSp以及Parch变量建立一个新模型</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span>(caret)</span><br><span class="line">set.seed(<span class="number">201409</span>)</span><br><span class="line">inTrain = createDataPartition(train.raw$Survived,</span><br><span class="line">                                     p = <span class="number">0.8</span>, list = <span class="literal">FALSE</span>)</span><br><span class="line">training = train.raw[inTrain, ]</span><br><span class="line">test = train.raw[-inTrain, ]</span><br><span class="line">model.logit.2 &lt;- train(Survived ~ Sex + Pclass + Age + Embarked + Fare+Title+SibSp+Parch,data = training, method=<span class="string">"glm"</span>)</span><br><span class="line">model.logit.2</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Generalized Linear Model &#10;## &#10;## 714 samples&#10;##  13 predictors&#10;##   2 classes: &#39;0&#39;, &#39;1&#39; &#10;## &#10;## No pre-processing&#10;## Resampling: Bootstrapped (25 reps) &#10;## &#10;## Summary of sample sizes: 714, 714, 714, 714, 714, 714, ... &#10;## &#10;## Resampling results&#10;## &#10;##   Accuracy  Kappa  Accuracy SD  Kappa SD&#10;##   0.8       0.6    0.02         0.05    &#10;## &#10;##</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">predict.model.2=predict(model.logit.2,test)</span><br><span class="line">table(test$Survived,predict.model.2)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##    predict.model.2&#10;##      0  1&#10;##   0 93 16&#10;##   1 17 51</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sensitivity(test$Survived,predict.model.2)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 0.8455</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">specificity(test$Survived,predict.model.2)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 0.7612</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predict(model.logit.2,test)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##   [1] 0 1 1 0 1 0 0 0 0 1 0 0 1 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 1 0 1 0 1 0 0&#10;##  [36] 1 0 0 0 1 1 0 1 0 0 1 0 0 0 0 0 0 1 0 0 1 0 0 1 1 0 1 0 1 1 1 0 1 1 0&#10;##  [71] 0 1 0 1 0 1 1 1 0 0 1 0 0 0 1 1 0 0 0 0 1 0 0 0 1 0 0 0 1 1 1 0 0 0 1&#10;## [106] 1 0 0 1 1 0 0 0 0 0 0 1 0 1 0 1 0 1 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0&#10;## [141] 1 0 0 1 0 1 1 0 1 1 0 0 0 1 0 0 1 1 1 0 1 0 1 1 0 0 1 0 0 1 0 1 1 1 0&#10;## [176] 0 0&#10;## Levels: 0 1</span><br></pre></td></tr></table></figure>
<p>训练集accuracy达到0.82，对于测试集sensitivity,specificity都达到了有提高</p>
<h2 id="u9884_u6D4B-1"><a href="#u9884_u6D4B-1" class="headerlink" title="预测"></a>预测</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">title.filter=c(<span class="string">"Mr"</span>,<span class="string">"Mrs"</span>,<span class="string">"Miss"</span>,<span class="string">"Master"</span>,<span class="string">"Professional"</span>)</span><br><span class="line">test.raw$Title=getTitle(test.raw)</span><br><span class="line">test.raw$Title=sapply(test.raw$Title,recodeTitle,title.filter)</span><br><span class="line">test.raw$Age=imputeAge(test.raw$Age,test.raw$Title,title.filter)</span><br><span class="line">test.raw$Embarked=imputeEmbarked(test.raw$Embarked)</span><br><span class="line">test.raw$Fare=imputeFare(test.raw$Fare,test.raw$Pclass,pclass.filter)</span><br><span class="line">predict.final.model.2=predict(model.logit.2,newdata=test.raw)</span><br><span class="line">predictions=data.frame(PassengerId=test.raw$PassengerId, Survived=predict.final.model.2)</span><br><span class="line">write.csv(predictions,file=<span class="string">"Titanic_predictions_2.csv"</span>, row.names=<span class="literal">FALSE</span>, quote=<span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure>
<p>提交到kaggle，新的排名一下提高的了800多位，一下子比之前提高了1600多位。回到之前我们提到的可能优化方向：</p>
<ul>
<li>有4个特征没有使用分别是sibsp,parch,Cabin,names。<ul>
<li>也许家人的数目会影响生还率，比如需要照顾家人或者上救生船的时候会让别的家庭成员上等等</li>
<li>Cabin这个变量虽然有很多缺失但是理论上应该也是一个关键特征，因为不同舱位对逃生影响很大</li>
<li>names看似没有用但是似乎它们都满足了 xx Title, xx xx这样一种模式，而西方人的title可以反映年龄。因此可能我们需要利用names来构建一个新变量Title</li>
</ul>
</li>
<li>对Age的插值之前我们采用了直接取不同等级舱位年龄median的方式完成，这是否是最佳，可否有更好方法？比如可以考虑根据姓名的Title来判断</li>
<li>前面的模型参数我们没有进行任何的优化，也许优化参数可以取得更好结果？</li>
<li>除了逻辑回归，我们还可以采用决策树，随机森林，boosting方法，是否这些模型会带来更好结果？</li>
</ul>
<p>现在还可以做的有:</p>
<ul>
<li>Cabin这个变量虽然有很多缺失但是理论上应该也是一个关键特征，因为不同舱位对逃生影响很大</li>
<li>前面的模型参数我们没有进行任何的优化，也许优化参数可以取得更好结果？</li>
<li>除了逻辑回归，我们还可以采用决策树，随机森林，boosting方法，是否这些模型会带来更好结果？</li>
</ul>
<p>此外前面的代码中的插值函数显然可以重构成一个通用函数就不用每个特征写一个函数了，不过今天先到这里下一步的优化我们就下次再写了。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/数据科学/">数据科学</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Kaggle/">Kaggle</a><a href="/tags/R/">R</a><a href="/tags/数据科学/">数据科学</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/09/17/2014-09-17-kaggle-titanic/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/09/17/2014-09-17-kaggle-titanic/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/09/08/2014-9-data-science-chp9-Rstudio/" title="数据科学(9)-第九章：Rstudio" itemprop="url">数据科学(9)-第九章：Rstudio</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="中继点" target="_blank" itemprop="author">中继点</a>
		
  <p class="article-time">
    <time datetime="2014-09-08T02:34:44.000Z" itemprop="datePublished"> 發表於 2014 Sep 8</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本文为<strong>Introduction to Data Science</strong>一书的翻译，由网友义务完成，了解参加翻译的网友，请点击<a href="https://github.com/johnstart/data-science/blob/gh-pages/task.md" target="_blank" rel="external">这里</a>，如果要加入我们请加入qq群171546473,了解翻译规则点击<a href="https://github.com/johnstart/data-science/blob/gh-pages/index.md" target="_blank" rel="external">这里</a></p>
<p>#第九章 开始R-Studio</p>
<p><img src="/img/datascience/9-head.jpg" alt=""></p>
<p><strong>作为一个拥有活跃的用户社区的开源软件，R之所以能不断创新发展离不开社区志愿者无私贡献。其中一个非常重要的创新就能完美支持R语言副本的R-Studio框架。本章从R-Studio的安装开始，然后再详细介绍了“包”——扩展R的关键。</strong></p>
<p>Joseph J. Allaire 作为一个连续创业家和软件工程师，开发了一系列著名软件，包括ColdFusion和微软博客工具Windows Live Writer，其中ColdFusion后来被卖给了网络媒体工具巨头Macromedia。从2009年开始，Allaire和一个小团队开始开发一款开源软件，用来提高R的可用性和效率。</p>
<p>如同前面章节所述，作为一门开源语言，R可以创建Mac，Windows，或者Linux平台下的副本，并且允许所有人检查和修改。同其它开源项目一样，社区里有大量活跃的志愿者致力于R语言的改善，包括语言本身，以及为R添加新的内容。其中一个新添加的内容就是R-Studio。R-Studio是一种集成开发环境（IDE，Integrated Development Environment）。每一个软件工程师都知道IDE在软件开发过程中的重要性。你可以把R想象成地板上卷起的一块帆布，而R-Studio则像一个优美的相框。当你把R放在R-Studio中后，就像任何好的相框一样，R-Studio能让R显得更加优美，具有鉴赏性。</p>
<p>你可以在任何时候登陆R-Studio官网 <a href="http://www.rstudio.org" target="_blank" rel="external">http://www.rstudio.org</a> 来查看有关信息。在本章剩下的部分中，你需要一台装有Mac、或Windows、或Linux系统的电脑来跟着学习R-Studio的安装和使用。</p>
<p>在开始学习R-Studio之前，我们先来了解为什么我们在使用R的时候需要一个IDE。在前面的章节中，我们都是通过总所周知的“R控制台”来输入各种各样的R命令。控制台是一个非常古老的技术术语，可以追溯到电脑大得还需要单独的空调室的时代。当时控制台作为“主控台”，接受各种操作命令，完成对整个巨大的计算机的控制。如今，控制台这个术语在很多场合都是指可以直接输入命令的界面。我们之前学习R语言以及一些数据结构和统计学基本原理的时候，就是通过在R控制台中输入命令来完成的。</p>
<p>而要想真正搞数据科学，我们也不可能整天坐在电脑面前敲命令。首先，这样很快就会变得非常枯燥乏味。其次，如果老板发现我们在重复输入昨天输过的命令，他就会开始怀疑我们的工作。最后，也是非常重要的一点，如果实现所有的小任务必须通过手动输入一些命令来完成的话，这会非常容易出错，产生计算机科学家所谓的“bug”。考虑到这些原因，我们这本书的一个目标就是要创造一些可以重复使用的东西，这样我们就可以简单点几下鼠标或是输入一些简单的东西就可以完成需要很多处理步骤的任务。使用IDE，我们就可以轻松建立这样的可以重复使用的部分。IDE整合了各个功能，用的时候打开对应部分，不用的时候将其隐藏或者关闭即可。由于我们和数据打交道，我们需要非常细致的检测这些数据，包括数据内容及其结构。你可能也已经注意到了，通过R控制台来完成这些内容非常无聊的，其输出的一大段的文字并且有的文字在你看清之前就被挤出了屏幕。作为R语言的IDE，R-Studio就允许我们控制和监视代码和文字，这样在某种程度上可以支持我们创造可重复使用的内容。</p>
<p>在做这些之前，首先必须在电脑上安装R-Studio。安装R-Studio之前，必须先安装R。如果你已经在第二章中完成了R的安装，剩下的R-Studio的安装就是小菜一碟。在安装R-Studio之前，你必须确保安装的R是最新的版本。R-Studio官网 <a href="http://www.rstudio.org/" target="_blank" rel="external">http://www.rstudio.org/</a> 上有丰富的文档，只要跟着这些文档的说明来安装，问题应该不大。如果安装过程中要求你选择安装“R-Studio服务器版”还是“桌面应用版”，选择后者即可。稍后我们会对R-Studio服务器版本进行介绍，但是现在选择桌面版本即可。如果你还想了解额外的关于R-Studio的信息，可以参考John Verzani（2011，Sebastopol，CA：O’Reilly Media)写的书：<em>Getting Started with R-studio。</em>该书第一章就对R和R-Studio进行了大体介绍，也介绍了如何安装和更新R-studio。YouTube的一段视频 <a href="http://www.youtube.com/watch?v=7sAmqkZ3Be8" target="_blank" rel="external">http://www.youtube.com/watch?v=7sAmqkZ3Be8</a> 也对R-Studio进行了详细介绍。需要注意的是，YouTube上有一个磁盘恢复程序和一个音乐组织也都叫R-Studio，因此如果你仅仅用“R-Studio”搜索而不加其他关键词的话，你将会搜到大量和这两者有关的视频。</p>
<p>安装好R-Studio后，你就可以直接运行它来进行本章后面的内容。本书不会像其他学习材料一样把R-Studio界面上的每个部分都介绍一遍，而是在使用到一个特性的时候就将其突出显示出来。当你运行R-Studio时，你将会看到三到四个子窗口。点击“File”菜单下的“New”项，并在“New”的子菜单中选择“R Script”，这样你就能看到类似如下的界面：</p>
<p><img src="/img/datascience/9-1.jpg" alt=""></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyMode &lt;- <span class="keyword">function</span>(myVector)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span>(myVector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>恭喜你刚刚用R写了第一个函数。一个函数是一组可以重复使用的R代码，每次使用时就不必重新输入相同的代码，其它编程语言里也都有函数这个概念。函数也有“过程”和“子程序”的意思，这在不同编程语言里有轻微的不同。我们给刚定义的函数命名为“MyMode”。从前面多个章节可以看出，除了基本的函数mean()和median（），R的基本安装里面并没有统计学模块的函数。这需要我们自己创建统计模块函数来解决这个问题。回想那个统计一个列表里每个值出现的次数并返回出现次数最多的值的函数，那就是一个统计模块的定义：列表中出现频率最高的项。</p>
<p>关于函数，有几点需要注意。首先、第一行中圆括号括起来的（myVector）表示函数的“参数”，或者说输入。之前当我们调用类似mean（）和median（）等函数时就遇到过“参数”这个概念。其次、注意第二行和最后一行的大括号，在函数中，这些大括号都是成对出现的。最后、注意函数接近末尾的return（）语句，这是将函数完成结果返回的地方。一会当我们在R控制台中调用这个函数时就能看到，返回结果就是return（）语句中括号里的东西。</p>
<p>基于这些说明，你现在知道前面的这个MyMode（）函数做了什么了吗？这个函数其实对我们传入的参数myVector未做任何改动。顺便说一下，写代码时一种常用的方式就是这么一点一点的实现代码。这样我们可以测试每一步都能得到什么样的结果。我们现在就可以测试一下目前的函数能干什么。首先，我们创建一个小的向量。在R-studio的左下角可以看到一个常规的R控制台正在运行。像前面几章一样，在里面输入R命令：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tinyData &lt;- c(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">tinyData</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##  [1] 1 2 1 2 3 3 3 4 5 4 5</span><br></pre></td></tr></table></figure>
<p>然后我们就可以试试我们写的MyMode（）函数：</p>
<p>> MyMode(tinyData)</p>
<p>   Error: could not find function “MyMode”</p>
<p>噢，出错了！R还不知道我们的新函数呢。我们虽然在代码窗口输入了MyMode（）函数，但是还没有告诉R呢。查看左上角的窗口，你可以看到MyMode（）函数的代码，以及在代码上方的工具栏中有一些小的按钮，其中有一个旁边写着“Run”的向右的箭头。选中MyMode()函数的所有代码（从字面“M”到最后的大括号），然后点击Run按钮，你就会立即看到下方的R控制台中出现了相同的代码。如果所有的代码都是正确的，控制台就不会报错或者警告。点击Run按钮后，R编译器就知道了MyMode（）函数，并且准备使用了。再在控制台中输入：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyMode(tinyData)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##  [1] 1 2 1 2 3 3 3 4 5 4 5</span><br></pre></td></tr></table></figure>
<p>程序将返回我们所期望的tinyData的内容。这个例子中，tinyData就是函数的输入参数，从这个例子我们就可以看出函数的参数是如何工作的。当函数运行时，其将tinyData的内容复制到myVector中，以方便函数中使用。现在，我们在函数中新添加一条语句：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyMode &lt;- <span class="keyword">function</span>(myVector)</span><br><span class="line">&#123;</span><br><span class="line">  uniqueValues &lt;- unique(myVector)</span><br><span class="line">  <span class="keyword">return</span>(uniqueValues)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将原来的MyMode函数进行了轻微的改动，结果如上所述。我们只在原函数中加了一行代码，避免函数变得过于复杂。我们先来看看这段代码都干些什么。首先不要忘了选中代码然后点击“Run”按钮，然后在R控制台中再次输入MyMode（）命令：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyMode(tinyData)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 1 2 3 4 5</span><br></pre></td></tr></table></figure>
<p>代码的作用非常明显，我们调用了unique()函数，其返回在tinyData中出现的数值的列表，这个列表中每个数值只出现一次。简单的说，unique()函数就是将输入向量中多余的数值去掉。接下来我们让代码更复杂一点：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyMode &lt;- <span class="keyword">function</span>(myVector)</span><br><span class="line">&#123;</span><br><span class="line">  uniqueValues &lt;- unique(myVector)</span><br><span class="line">  uniqueCounts &lt;- tabulate(myVector)</span><br><span class="line">  <span class="keyword">return</span>(uniqueCounts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仍然别忘了在使用这个函数前要选中代码然后点击“Run”。这次我们将tinyData作为输入参数传给函数，得到的返回值也是一个有5个元素的列表，但是列表的元素表示的是输入参数中每个数值出现的次数：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyMode(tinyData)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 2 2 3 2 2</span><br></pre></td></tr></table></figure>
<p>现在差不多该结束我们的MyMode()函数了，但是我们得确保理解了uniqueValues和uniqueCounts中的内容：</p>
<p>下面的表中列出了uniqueValues中的元素以及其对应的个数。</p>
<p><img src="/img/datascience/9-2.jpg" alt=""></p>
<p>首行显示“index”的标号行仅仅是出于说明的目的。这些索引数字用来定位列表中对应的元素的。比如，uniqueValues列表中下标为4的位置值为4，其对应的uniqueCounts的值为2。这样一来，如果我们要寻找出现次数最多的数字，我们只需在最后一行中找到最大的数的下标，然后在uniqueValues列表中找到该下标对应的值即可。在R语言中，我们只需一行代码就可以实现前面描述的过程：</p>
<p>uniqueValues[which.max(uniqueCounts)]</p>
<p>其中，whicn.max()函数用来找到uniqueCounts中最大数在数组中的下标，然后在uniqueValues中通过一对方括号就能访问方括号中下标对应的元素。例如uniqueValues[5]就能得到uniqueValues中的第5个数。我们把这条语句加到return语句中，来完成我们的函数：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyMode &lt;- <span class="keyword">function</span>(myVector)</span><br><span class="line">&#123;</span><br><span class="line">  uniqueValues &lt;- unique(myVector)</span><br><span class="line">  uniqueCounts &lt;- tabulate(myVector)</span><br><span class="line">  <span class="keyword">return</span>(uniqueValues[which.max(uniqueCounts)])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们准备再次测试这个函数，注意不要忘了选中所有代码然后运行一下，否则编译器记住的只是旧的那个函数。我们先回忆一下tinyData中都有些什么元素，然后再把tinyData作为参赛传给函数：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tinyData</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##  [1] 1 2 1 2 3 3 3 4 5 4 5</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyMode(tinyData)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 3</span><br></pre></td></tr></table></figure>
<p>可以看出，函数工作正常。tinyData数组中出现最多的数是3。我们继续测试看看函数还会发生什么：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tinyData &lt;- c(tinyData,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">tinyData</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##  [1] 1 2 1 2 3 3 3 4 5 4 5 5 5 5</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyMode(tinyData)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 5</span><br></pre></td></tr></table></figure>
<p>我们向tinyData数组末尾中添加了三个5，现在tinyData中有五个5，MyMode()函数也执行成功。我们在继续测试：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tinyData &lt;- c(tinyData,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">tinyData</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##  [1] 1 2 1 2 3 3 3 4 5 4 5 5 5 5 1 1 1</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyMode(tinyData)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 1</span><br></pre></td></tr></table></figure>
<p>你会发现这很奇怪，现在tinyData中明明是1和5都有五个，但是函数返回的的确是1。其实你完全不必惊讶，which.max()函数的说明文档里已经写清楚了，这个函数会返回其找到的第一个最大值。所以出现上面的结果是情理之中的事。事实上，这也总是统计学中常见的一个问题：数据集中不止一个模式。我们的MyMode()函数还无法实现这样的功能，也不能给出任何警告说明数据中出现次数最多的数不止一个，而只是简单的返回其中找到的第一个。<br>这函数中还有另一个问题：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tinyData &lt;- c(tinyData,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">9</span>)</span><br><span class="line">MyMode(tinyData)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] NA</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tabulate(tinyData)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 5 2 3 2 5 0 0 0 7</span><br></pre></td></tr></table></figure>
<p>第一行代码中，我们在tinyData后面加了一连串“9”，注意tinyData中没有6,7,8。而我们运行MyMode()却返回“NA”，这在R中表示某处出错了，你得到了一个空的值。如果我们不输入最后的“tabulate(tinyData)”语句，很难看出程序为什么会出现这么怪异的行为。我们先来看看都发生了什么：在MyMode()函数中运行的时候，tabulate()产生的数组的长度不是我们想的那样———有多少个不同的数，数组就多长。这是因为tabulate()函数会将6,7,8等这些不存在的数都置为0。tabulate()返回的结果中，最大数7（代表tinyData中9出现的次数）出现在末尾；而再查看unique()函数的返回结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique(tinyData)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 1 2 3 4 5 9</span><br></pre></td></tr></table></figure>
<p>可以看到unique()函数的返回结果中只有6个元素，这和tabulate()的返回结果不匹配（你可以想象一下前面一页那个表中最后两行长度不一样的情况）。我们可以添加额外的match()函数来解决这个问题：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MyMode &lt;- <span class="keyword">function</span>(myVector)</span><br><span class="line">&#123;</span><br><span class="line">  uniqueValues &lt;- unique(myVector)</span><br><span class="line">  uniqueCounts &lt;- tabulate(match(myVector,uniqueValues))</span><br><span class="line">  <span class="keyword">return</span>(uniqueValues[which.max(uniqueCounts)])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新添加match(myVector,uniqueValues)保证了传入tabulate()的参数是myVector和uniquValues数组“match”的结果，而不再是uniqueValues中所有可能的，即使myVector中没有的结果。现在我们在调用MyMode()函数就能得到正确的结果：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyMode(tinyData)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 9</span><br></pre></td></tr></table></figure>
<p>可以看到，程序输出了我们期望的结果。当我们在tinyData数组后面加了七个9之后，函数输出也输出正确结果：9。</p>
<p>在退出R-Studio之前千万不要忘了将你所做的工作保存下来，点击“File”菜单中的“Save”选项，根据提示选择合适的储存位置，然后输入任何你喜欢的文件名即可，比如MyMode。程序会自动为保存的文件加上“R”后缀，因此最终的文件名应为“MyMode.R”。你可以随时在你的当前工作中打开此文件，然后重复使用MyMode()函数。</p>
<p>有几点需要特别注意。第一，当创建自己的函数时，一定要做测试和修改，保证函数始终能正确运行。这在处理和计算机相关的工作的时候通常遇到的情况，诸如电子数据表，宏命令和其他很多要求准确性和精度的地方都必须保证其正确运行。第二，在前面的例子中我们介绍了四个函数：unique(),tabulate(),match()和which.max()。R中还有其他很多类似的函数，要想全部知道或者记住这些函数是非常困难的。而完成某个目的的方法往往不止一种。因此，当你不知道这些基本函数的时候，你也往往很难创建新的函数来解决特定的问题。这就是为什么社区兴起的原因，在网上随便一搜，你就会发现很多人都试图解决你所面临的类似的问题，而你也会发现很多人也把他们解决方法的R代码发布出来了。这些代码片段都是免费拿来使用和测试的。事实上，通过别人的例子来学习是非常好的拓展见识、学习新技术的方式。</p>
<p>最后一点需要注意的也是我们接下来要讨论的关键主题。为了创建这个MyMode函数，我们做了非常多的工作，但是仍然不能保证其对于所有可能遇到的输入参数都能完美运行。也行别人已经解决了我们遇到的问题，这样我们就可以直接将别人写的“包（package）”添加到R编译器中，来拓展R的函数。事实上，对于统计模式，现有的一个包几乎可以完成你能想到的所有工作。这个包叫“modees”，是“mode-estimator”的一个不太好的缩写。查看R-studio的右下角窗口，上面有很多标签，其中一个标签是“Package”，点击这个标签你就能看到所有已经安装的包的列表，选中包前面的勾选框就可以在你的R程序中使用这个包了。“modeest”包应该不在这个列表中，因此你需要点击“Install”按钮来安装包。点击“Install”后，会弹出一个如下图的界面：</p>
<p><img src="/img/datascience/9-3.jpg" alt=""></p>
<p>在“Packages”编辑框中输入想安装的包的名字就可以开始安装这个包了。或许你记不清包的完整的名称，你只需输入前几个字母，R-studio就会自动列出所有匹配的包，从列表中选择你需要的即可。安装过程中可能会弹出“Install Dependencies”的勾选框，如果弹出来了，选上即可。这是因为在有些情况下，安装R的包需要依赖其他包，R-studio会自动按照正确的顺序将所有必需的包都安装上。点击“Install”后，你会发现R控制台（左下角窗口）中运行了一些命令。通常情况下，这个安装过程不会出现问题，你也看不到任何警告信息。安装完成后，再次查看右下角的窗口（注意选择“Packages”标签），你就会发现modeest包已经在列表中了。然后选中旁边的勾选框，这会自动调用library()函数，然后你就可以使用modeest这个包了。</p>
<p>我们先来试试mfv()函数，这个函数返回一个向量中出现次数最多的数，这个功能也是我们在函数中经常用到的：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mfv(tinyData)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 9</span><br></pre></td></tr></table></figure>
<p>到目前为止一切都很顺利，这个函数似乎和我们的MyMode()函数做了一样的事，尽管其方法可能不一样。事实上，想知道这个函数是怎么实现的也非常简单，只需在R命令行中输入函数名字即可：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mfv</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## function (x, ...) &#10;## &#123;&#10;##     f &#60;- factor(x)&#10;##     tf &#60;- tabulate(f)&#10;##     return(as.numeric(levels(f)[tf == max(tf)]))&#10;## &#125;&#10;## &#60;environment: namespace:modeest&#62;</span><br></pre></td></tr></table></figure>
<p>这是开源程序最棒的一件事：你可以轻松的查看底层的具体实现。注意到尽管这个函数也是用了tabulate()函数，但其方法和和我们的MyMode()函数完全不同。最后一行以“environment”开头的信息在更加复杂的编程中非常重要，因为其指明了函数mfv()是来自哪里。这个函数的其他方面就不是特别明显了，其中还有一个特点是当你输入的参数列表中出现次数最多的数不止一个时，函数会正确返回所有出现次数最多的数，比如输入以下向量：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">multiData &lt;- c(<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line">mfv(multiData)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 7 9</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyMode(multiData)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 7</span><br></pre></td></tr></table></figure>
<p>上面第一语句中，我们输入了一个新的向量，其中数字7和9出现次数最多，都为两次，而其他数则只出现了一次。当我们调用mfv()函数来处理这个向量是，mfv()函数能正确返回7和9这两个数，而是用MyMode()函数，则只能返回第一次找到的出现最多的数，也就是7。</p>
<p>回顾一下，这一章介绍了R的一个集成开发环境(IDE)——R-studio。在处理数据和进行数据分析的时候，IDE能非常方便的构造可重复使用的模块。从这一点考虑，我们就会选择使用R-studio和不是旧的R，这样我们就可以保存和重复使用我们所做的工作。另一方面，使用R-studio也会非常便于管理R的包，这对于拓展R非常关键。这之后的章节中我们仍然会使用R包来实现专门的功能。</p>
<p>这些具有专门功能的函数是由R社区的贡献者们创造的，以额外函数的形式出现。通过创建自己的函数，我们知道了函数接受“参数”作为其输入，然后给出一个返回值。返回值是一个数据对象，因此可以是一个单一的数字（从技术上将就是一个元素个数为1的向量），或者返回一串值（即一个向量），或者更负责的数据对象。在本书后面的章节中，我们会经常自己写函数，然后重复使用。也会经常使用别人的函数，这时只需按照他们的包然后用library()函数载入即可。将包载入后，在R命令行中输入函数的名字，就可以查看函数是如何实现的。（注意对一小部分用其他编程语言，比如C，编写的函数就不能用这种方法查看函数的实现了）</p>
<p><strong>本章挑战</strong></p>
<p>编写并测试一个MySamplingDistribution(),根据输入的数值向量，创建其均值构成的抽样分布。你需要将这章所学的创建函数的知识和前面所学的创造抽样分布的知识结合到一起，来写出一个可用的函数。写之前一定好仔细考虑函数的输入参数和返回的数据对象。</p>
<p><strong>资源</strong></p>
<p><a href="http://en.wikipedia.org/wiki/R_(programming_language)" target="_blank" rel="external">http://en.wikipedia.org/wiki/R_(programming_language)</a></p>
<p><a href="http://en.wikipedia.org/wiki/Joseph_J._Allaire" target="_blank" rel="external">http://en.wikipedia.org/wiki/Joseph_J._Allaire</a></p>
<p><a href="http://stats.lse.ac.uk/penzer/ST419materials/CSchpt3.pdf" target="_blank" rel="external">http://stats.lse.ac.uk/penzer/ST419materials/CSchpt3.pdf</a></p>
<p><a href="http://www.use-r.org/downloads/Getting_Started_with_RStudio.pdf" target="_blank" rel="external">http://www.use-r.org/downloads/Getting_Started_with_RStudio.pdf</a></p>
<p><a href="http://www.statmethods.net/interface/packages.html" target="_blank" rel="external">http://www.statmethods.net/interface/packages.html</a></p>
<p><a href="http://www.youtube.com/watch?v=7sAmqkZ3Be8" target="_blank" rel="external">http://www.youtube.com/watch?v=7sAmqkZ3Be8</a></p>
<p><strong>本章用到的R命令</strong></p>
<p>function()——创建一个新的函数</p>
<p>return()——返回一个值来结束函数</p>
<p>tabulate()——统计一个向量中每个数出现的次数</p>
<p>unique()——取输入向量中的不重复元素构成新的向量</p>
<p>match()——返回两个向量中都存在的元素</p>
<p>mfv()——出现次数最多的元素（来自modeest包）</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/数据科学/">数据科学</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Introduction-to-data-science/">Introduction to data science</a><a href="/tags/数据科学/">数据科学</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/09/08/2014-9-data-science-chp9-Rstudio/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/09/08/2014-9-data-science-chp9-Rstudio/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/09/08/2014-9-8-data-science-chp8-big-data/" title="数据科学(8)-第八章：大数据" itemprop="url">数据科学(8)-第八章：大数据</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="中继点" target="_blank" itemprop="author">中继点</a>
		
  <p class="article-time">
    <time datetime="2014-09-08T02:29:56.000Z" itemprop="datePublished"> 發表於 2014 Sep 8</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>本文为<strong>Introduction to Data Science</strong>一书的翻译，由网友义务完成，了解参加翻译的网友，请点击<a href="https://github.com/johnstart/data-science/blob/gh-pages/task.md" target="_blank" rel="external">这里</a>，如果要加入我们请加入qq群171546473,了解翻译规则点击<a href="https://github.com/johnstart/data-science/blob/gh-pages/index.md" target="_blank" rel="external">这里</a></p>
<p>#第八章 大数据？了不起！</p>
<p>在2012年，许多科技媒体的头条关注了大数据。是什么让数据变大，为什么“大”重要？在这一章，我们讨论这些问题后面的争议。掌握了前一章的知识后，对于数据的规模如何影响我们的数据工作，我们可以有更多的思考。</p>
<p>市场观察（一个华尔街期刊）最近发表了一篇文章标题为“谷歌IT和商务专业人士指出大数据等于大回报”，副标题“根据新的全球调查，70%的组织正在考虑、计划或者运行大数据项目”。相似的技术新闻在这几年屡见不鲜。如此大量这样的文章让人不由得认为“大数据”是一种给这个世界掀起信息和技术浪潮的革命。但这是真的的？“大数据”真的改变了一切吗？</p>
<p>商业分析师Doug Laney指出三个特征让大数据跟以往的技术革命不同：海量，速度、多样性。海量指的是庞大的数据量。速度则是数据的快速生成和更新。最后，多样性指的是会包含多种不同类型的数据。这三个特性经常指代大数据的“3V”模型。但是，即使在计算机时代的破晓，我们就已经拥有多样的数据，有的数据产生非常快，而且经过时间的推移，这些产生的数据能装满大量的存储器（试想，从18世纪开始，美国国会图书馆每年产生的多种的大量的数据）。所以，光凭某人说他们面临海量的、高速的、多样性的数据问题，是不足以证明大数据是一个崭新的事物。</p>
<p>有这样的说法，和几年前相比，许多进行中的改变让今天的数据问题有了质的不同。让我们列下几个准确的例子： </p>
<ol>
<li>传感器（比如条形码阅读器）价格的下降和最近几年是它价格下降并且更容易收集更多数据的技术</li>
<li>相似的，存储器价格的下降使不管质量和使用地保存大量无关紧要的数据变得现实了。</li>
<li>许多人对隐私的态度不再像以前那样严格，他们似乎已经适应了使用Facebook和其他会透露许多个人信息的平台。</li>
<li>研究者已经在机器学习算法中取得了重大进步，它是构建许多数据挖掘的基础。</li>
<li>当一个数据集达到一定规模（几千行），传统的统计显著性检验已经没有意义了，因为即使最小最微不足道的结果（或者效应量，按照统计学家的说法）也是统计上显著的</li>
</ol>
<p>出了以上这几点，我们能然有许多需要做出的改变：  </p>
<p>A.垃圾进，垃圾出：数据的用处非常依赖它是如何收集的。数据收集后，它的质量非常依赖我们如何对它做预处理：数据清理和数据筛选。<br>B.大等于怪异：如果你寻找异常现象——违反规则的罕见事件——那么数据量越大越好。低频率事件经常不会出现直到数据收集持续很长一段时间，或者包含一个足够大的样例组来专门记录一个奇特案例。<br>C.连接增加可能：单个数据集不管提供什么变量都有内在的限制。但是如果这些数据能连接到别的数据，新的分析途径也许会突然出现。虽然不能保证，但是你连接越多的数据，你就越有可能有新的发现。   </p>
<p>以上两个列表的观点都是老生常谈毫无争议的。但是他们进一步解释了大数据可能会有多重要的问题。历史上已经有许多成功应用传统统计检验适当规（比如1000行或更少）模数据集的统计规律。每个人都喜欢的基础统计，学生t检验，是检验两组数据中心趋势异同的工具。如果数据包含某种规律，一组数据显著不同于另一组数据，一个t检验会告诉我们同样的结果。</p>
<p>大数据没办法用这样的检验帮助我们。我们甚至不需要一千条数据来做传统统计比较，而且上百万上千万的数据并不会让我们的工作更简单（它只会占用更多的电脑内存和磁盘）。想想我们前一张读到的：我们可以开始用基本的统计推断处理有51条记录的数据。实际上，大部分经常使用的统计技术，比如学生t检验，是专门设计处理小样本的。</p>
<p>另一方面，如果我们是在草堆里找一根针，尽量在最大的草堆里找就讲得通了。因为大的草堆更有可能包含至少一根针。随着机器学习近几年的进步，我们开始意识到好的工具、大量数据和有趣的问题确实能为我们提供新的更深刻的见解。  </p>
<p>让我们结合这个这样的乐观主义和三个非常重要的注意事项。第一条是当这个数据越复杂，就越难确定数据是否“干净”和适合我们的要求。一个脏数据集在某方面比没有数据还糟，因为我们也许会花很多时间精力在上面而得不到任何结果。更严重的是我们花时间精力最后只能得到错误的结果！很多分析师认为清理数据——让数据适合分析，清楚异常数据，组织适合的数据结构——事实上是数据分析过程中最耗时间精力的。</p>
<p>第二条注意事项是稀少和异常事件或模式一直伴随这他们不可预测的本质。甚至面对我们能想象的最好的数据和大量变量，我们几乎一直都会有准确性的问题。数据挖掘工具也许能给我们呈现数据的模式，我们甚至可以在新数据中重现这种模式，但是我们永远不敢保证我们已经对这种模式理解到能分离，控制或明白它的原因。预测飓风的路径就是一个很好的例子：尽管气象仪器，预测和数字捣弄已经有了几十年的发展，气象学家在预测飓风是否会登陆或风速会多大都面对非常大的困难。工作中的复杂性和不可预测性使得任务异常艰难。</p>
<p>第三条注意事项是有关连接数据集的。上文的C条目提出连接能提供格外的价值。但是每一条到新数据集的连接也增加了数据的复杂性，同时也增加了出现脏数据和假结果的可能性。而且，虽然很多公司都越来越不在乎这一点，我们连接越多个人的数据（如消费者，病人，投票者等），我们就越可能造成隐私泄露的灾难。即使你不在乎隐私问题，但是你不得不承认安全和隐私丑闻会给公司带来巨大的金钱和名誉损失。现在有价值和可接受的数据革新领域也许就是犯罪和欺诈数据。越多数据集的连接就越容易暴露那些人的恶行。</p>
<p>总的来说，我们可以认为丰富的大量的数据结合适合的分析工具在有保障的环境下可以为商业部门、教育部门、政府部门和其他领域带来益处。但是，数据科学家关注的不应该是取得尽可能多的可用数据，而是根据目的使用对的数据和对的规模。拥有大量不适当的数据并不会有任何好处。就好像，简单快速取得的数据并不能保证与要研究的问题相关。虽然说多样性是生活的调味品，但是过于复杂经常会损害可靠性和可信性：我们连接的数据集越复杂，我们越可能在使用和保存它们的时候出现意外问题。</p>
<p>##数据科学的工具</p>
<p>经过前面几章，我们对于上千数据分析师使用的分析工具——数据分析和数据可视化的开源软件R——已经有了一个快速的了解。尽管R功能十分强大，但是数据分析师根据研究的不同领域仍然使用了上百种其他分析工具。</p>
<p>出了R之外，一个非常流行和强大的工具是SAS（读“sass”），它是一个一个有专利的统计系统。SAS包含了强大的编程语言，覆盖了许多数据类型，功能和语言特点。跟R相比，学习SAS可以说难（或简单，根据你的预期），但是许多大企业使用SAS，因为不像R，SAS提供了大量的技术和产品服务。当然，这样的服务价格不便宜，所以大部分SAS使用者都是有能力购买许可证书和售后支持的大企业。</p>
<p>另一个在统计领域的工具是SPSS，一个许多研究者使用的工具包（全名是统计产品与服务解决方案）。对许多分析师来说，SPSS比SAS更容易上手，但是没有那么灵活和强大。</p>
<p>R、SPSS、SAS作为统计工具包，但数据分析师在某些方面仍然使用了其他一般编程语言做数据分析。一个令人激动的发展中的语言有一个奇怪的名字“Processing”。Processing是一个专门用来做数据可视化的编程语言。像R一样，Processing是一个开源项目，它免费提供在<a href="http://processing.org/" target="_blank" rel="external">http://processing.org/</a>。而且跟R一样，processing是一个跨平台语言，它可以在Mac、Windows、Linux上完美运行。有许多书提供processing的学习（不幸的是还没有开源书），许多网站为初学者提供了大量实例。在R之外，processing也许是数据科学家工具箱中最重要的工具之一。</p>
<p>##本章练习</p>
<p>查看各种与“Data.gov”相关的网站，尽可能找到最大或者最复杂的数据集。试思考（或写下来）一种或多种这些数据可能在分析中被误用的情况。下载一个你感兴趣的数据集，将它载入R中看你能做点什么。</p>
<p>下面是一个格外挑战，打开下面这个网页：<br><a href="heep://teamwpc.co.uk/products/wps" target="_blank" rel="external">heep://teamwpc.co.uk/products/wps</a><br>下载试用版的“World Programming System”（WPS）。WPS能读取SAS代码，你能很方便的找到你要的代码用来读取Data.gov数据集。</p>
<p>##参考资料</p>
<p><a href="http://aqua.nasa.gov/doc/pubs/Wx_Forecasting.pdf" target="_blank" rel="external">http://aqua.nasa.gov/doc/pubs/Wx_Forecasting.pdf</a><br><a href="http://en.wikipedia.org/wiki/Big_data" target="_blank" rel="external">http://en.wikipedia.org/wiki/Big_data</a><br><a href="http://en.wikipedia.org/wiki/Data.gov" target="_blank" rel="external">http://en.wikipedia.org/wiki/Data.gov</a><br><a href="http://www.marketwatch.com/story/big-data-equals-big-busines
s-opportunity-say-global-it-and-business-professionals-2012-05-14" target="_blank" rel="external">http://www.marketwatch.com/story/big-data-equals-big-busines<br>s-opportunity-say-global-it-and-business-professionals-2012-05-14</a></p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/数据科学/">数据科学</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Introduction-to-data-science/">Introduction to data science</a><a href="/tags/数据科学/">数据科学</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/09/08/2014-9-8-data-science-chp8-big-data/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/09/08/2014-9-8-data-science-chp8-big-data/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/08/22/2014-8-22-naive-bayes/" title="机器学习与R(10)-朴素贝叶斯" itemprop="url">机器学习与R(10)-朴素贝叶斯</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="中继点" target="_blank" itemprop="author">中继点</a>
		
  <p class="article-time">
    <time datetime="2014-08-22T11:49:24.000Z" itemprop="datePublished"> 發表於 2014 Aug 22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="Naive_Bayes"><a href="#Naive_Bayes" class="headerlink" title="Naive Bayes"></a>Naive Bayes</h2><p>关于贝叶斯定理阮一峰的博客已经写得相当好了，我就不献丑了，要了解看这里：</p>
<p><a href="http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html" target="_blank" rel="external">贝叶斯推断及其互联网应用（一）：定理简介</a><br><a href="http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html" target="_blank" rel="external">贝叶斯推断及其互联网应用（二）：过滤垃圾邮件</a>  </p>
<p>朴素贝叶斯则是利用贝叶斯定理来进行分类的方法。它具有以下优点：</p>
<ul>
<li>简单，快速，有效</li>
<li>能很好处理噪声，缺失数据</li>
<li>对小和大样本都可以</li>
<li>比较容易获得预测的概率估计</li>
</ul>
<p>不过它也存在：</p>
<ul>
<li>要求特征间平等及重要性相同，特征相互独立（通常不会存在，这也是为什么要叫naive的原因）</li>
<li>对主要是大量数字特征的数据集不太适合</li>
<li>估计概率不如分类可靠（所以一般用它来分类）</li>
</ul>
<h2 id="u62C9_u666E_u62C9_u65AF_u4F30_u8BA1_u503C"><a href="#u62C9_u666E_u62C9_u65AF_u4F30_u8BA1_u503C" class="headerlink" title="拉普拉斯估计值"></a>拉普拉斯估计值</h2><p>朴素贝叶斯用来进行文本分类通常存在一个问题，如果训练的数据中某个词没有出现过，那么该词的概率就变成了0，从而如公式所示，整个计算的垃圾邮件概率就变成了0，这显然不合理，于是就有了拉普拉斯估计的应用，我们给它预估一个值这样就可以避免问题的出现了。</p>
<p><img src="/img/rmachine/bayes-laplace.png" alt="垃圾邮件计算示例"></p>
<h2 id="u6570_u5B57_u7279_u5F81_u7684_u5904_u7406"><a href="#u6570_u5B57_u7279_u5F81_u7684_u5904_u7406" class="headerlink" title="数字特征的处理"></a>数字特征的处理</h2><p>贝叶斯是通过计算频数来进行学习，这显然只能用于分类数据，对于连续数据这时可以考虑把它进行分区（bin）处理，比如利用<code>cut</code>函数。不过需要注意的是这样会导致信息的丢失。</p>
<h1 id="u5229_u7528_u6734_u7D20_u8D1D_u53F6_u65AF_u6765_u5224_u65AD_u5783_u573E_u77ED_u4FE1"><a href="#u5229_u7528_u6734_u7D20_u8D1D_u53F6_u65AF_u6765_u5224_u65AD_u5783_u573E_u77ED_u4FE1" class="headerlink" title="利用朴素贝叶斯来判断垃圾短信"></a>利用朴素贝叶斯来判断垃圾短信</h1><p>这里我们以判断垃圾短信为例，数据来自<a href="http://www.dt.fee.unicamp.br/~tiago/smsspamcollection/" target="_blank" rel="external">sms spam</a>数据集</p>
<h2 id="u6570_u636E_u51C6_u5907"><a href="#u6570_u636E_u51C6_u5907" class="headerlink" title="数据准备"></a>数据准备</h2><p>把数据下载后读入：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sms_raw &lt;- read.table(<span class="string">"SMSSpamCollection"</span>, stringsAsFactors = <span class="literal">FALSE</span>, sep = <span class="string">"\t"</span>, </span><br><span class="line">    header = <span class="literal">F</span>, comment = <span class="string">""</span>, quote = <span class="literal">NULL</span>)</span><br><span class="line">names(sms_raw) = c(<span class="string">"type"</span>, <span class="string">"text"</span>)</span><br><span class="line">str(sms_raw)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## &#39;data.frame&#39;:&#9;5574 obs. of  2 variables:&#10;##  $ type: chr  &#34;ham&#34; &#34;ham&#34; &#34;spam&#34; &#34;ham&#34; ...&#10;##  $ text: chr  &#34;Go until jurong point, crazy.. Available only in bugis n great world la e buffet... Cine there got amore wat...&#34; &#34;Ok lar... Joking wif u oni...&#34; &#34;Free entry in 2 a wkly comp to win FA Cup final tkts 21st May 2005. Text FA to 87121 to receive entry question(std txt rate)T&#38;C&#34;| __truncated__ &#34;U dun say so early hor... U c already then say...&#34; ...</span><br></pre></td></tr></table></figure>
<p>注意如果在<code>read.table</code>里面不指定<code>quote=NULL</code>那么会遇到如下问题</p>
<blockquote>
<p>Warning message:In scan(file, what, nmax, sep, dec, quote, skip, nlines, na.strings,  :  EOF within quoted string</p>
</blockquote>
<p>实际上你如果仔细研究一下数据，你可以发现这是因为数据里面的5082行开始有<code>&quot;&quot;</code>导致。</p>
<p>接下来将<code>type</code>转换为factor变量，因为贝叶斯分类要求目标变量为factor类型。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sms_raw$type = factor(sms_raw$type)</span><br><span class="line">table(sms_raw$type)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## &#10;##  ham spam &#10;## 4827  747</span><br></pre></td></tr></table></figure>
<p>数据集里面有4827条正常短信，747条垃圾短信</p>
<h2 id="u6570_u636E_u9884_u5904_u7406"><a href="#u6570_u636E_u9884_u5904_u7406" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>对于文本的分析通常我们会用到<a href="http://tm.r-forge.r-project.org/" target="_blank" rel="external"><code>tm</code>包</a></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span>(tm)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Loading required package: tm</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sms_corpus &lt;- Corpus(VectorSource(sms_raw$text))</span><br></pre></td></tr></table></figure>
<p>这里将原始数据中的短消息都作为向量输入构建语料库</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(sms_corpus)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## A corpus with 5574 text documents</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inspect(sms_corpus[<span class="number">1</span>:<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## A corpus with 3 text documents&#10;## &#10;## The metadata consists of 2 tag-value pairs and a data frame&#10;## Available tags are:&#10;##   create_date creator &#10;## Available variables in the data frame are:&#10;##   MetaID &#10;## &#10;## [[1]]&#10;## Go until jurong point, crazy.. Available only in bugis n great world la e buffet... Cine there got amore wat...&#10;## &#10;## [[2]]&#10;## Ok lar... Joking wif u oni...&#10;## &#10;## [[3]]&#10;## Free entry in 2 a wkly comp to win FA Cup final tkts 21st May 2005. Text FA to 87121 to receive entry question(std txt rate)T&#38;C&#39;s apply 08452810075over18&#39;s</span><br></pre></td></tr></table></figure>
<p>这里可以看出语料库有5574个文档，实际与我们的数据集样本数一样。每个文档对应的就是一条短信。从前3条短信我们看出，文档的里面有标题，数字，还有标点符号，以及大小写，为了方便分析我们进行如下处理：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">corpus_clean &lt;- tm_map(sms_corpus, tolower)</span><br><span class="line">corpus_clean &lt;- tm_map(corpus_clean, removeNumbers)</span><br><span class="line">corpus_clean &lt;- tm_map(corpus_clean, removeWords, stopwords())</span><br><span class="line">corpus_clean &lt;- tm_map(corpus_clean, removePunctuation)</span><br><span class="line">corpus_clean &lt;- tm_map(corpus_clean, stripWhitespace)</span><br><span class="line">inspect(corpus_clean[<span class="number">1</span>:<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## A corpus with 3 text documents&#10;## &#10;## The metadata consists of 2 tag-value pairs and a data frame&#10;## Available tags are:&#10;##   create_date creator &#10;## Available variables in the data frame are:&#10;##   MetaID &#10;## &#10;## [[1]]&#10;## go jurong point crazy available bugis n great world la e buffet cine got amore wat&#10;## &#10;## [[2]]&#10;## ok lar joking wif u oni&#10;## &#10;## [[3]]&#10;## free entry wkly comp win fa cup final tkts st may text fa receive entry questionstd txt ratetcs apply s</span><br></pre></td></tr></table></figure>
<p>以上依次把所有词转换为小写，去掉数字，去掉停止词（就是类似and，or，the之类，也就是冠词、介词、副词或连词），去掉标点，最后去掉所有空格。</p>
<p>完成了上述步骤，我们就需要统计每个词在文档中出现的频率了，这可以通过构建document term稀疏矩阵完成，这个稀疏矩阵的行对应一个文档，列则对应了每个词。term document则反过来。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sms_dtm &lt;- DocumentTermMatrix(corpus_clean)</span><br></pre></td></tr></table></figure>
<h2 id="u51C6_u5907_u8BAD_u7EC3_u4E0E_u6D4B_u8BD5_u6570_u636E"><a href="#u51C6_u5907_u8BAD_u7EC3_u4E0E_u6D4B_u8BD5_u6570_u636E" class="headerlink" title="准备训练与测试数据"></a>准备训练与测试数据</h2><p>有了上面的矩阵，我们就可以开始准备训练数据与测试数据了，还是用<code>caret</code>包的<code>createDataPartition</code>来完成，可以看出训练与测试数据中的垃圾短信比例都相似。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span>(caret)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Loading required package: caret</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Warning: package &#39;caret&#39; was built under R version 3.0.3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Loading required package: lattice&#10;## Loading required package: ggplot2</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">set.seed(<span class="number">2014</span>)</span><br><span class="line">inTrain = createDataPartition(y = sms_raw$type, p = <span class="number">0.75</span>, list = <span class="literal">FALSE</span>)</span><br><span class="line">sms_raw_train = sms_raw[inTrain, ]</span><br><span class="line">sms_raw_test = sms_raw[-inTrain, ]</span><br><span class="line"></span><br><span class="line">sms_dtm_train = sms_dtm[inTrain, ]</span><br><span class="line">sms_dtm_test = sms_dtm[-inTrain, ]</span><br><span class="line"></span><br><span class="line">sms_corpus_train = corpus_clean[inTrain]</span><br><span class="line">sms_corpus_test = corpus_clean[-inTrain]</span><br><span class="line"></span><br><span class="line">prop.table(table(sms_raw_train$type))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## &#10;##    ham   spam &#10;## 0.8659 0.1341</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prop.table(table(sms_raw_test$type))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## &#10;##    ham   spam &#10;## 0.8664 0.1336</span><br></pre></td></tr></table></figure>
<h2 id="wordcloud"><a href="#wordcloud" class="headerlink" title="wordcloud"></a>wordcloud</h2><p>最简单的文本分析方法就是市场词云了，我们用<code>wordcloud</code>包</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span>(wordcloud)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Loading required package: wordcloud&#10;## Loading required package: Rcpp</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Warning: package &#39;Rcpp&#39; was built under R version 3.0.3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Loading required package: RColorBrewer</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wordcloud(sms_corpus_train, min.freq = <span class="number">40</span>, random.order = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/rmachine/rmachine-10-8.png" alt=""> </p>
<p>这里的<code>min.freq</code>是词出现的最小频率，通常我们用语料库的10%来开始(训练语料库有4182个文档)。上面那个词云只是给出了一个总体印象，对我们的分析没有太大帮助，所有我们考虑分布看看垃圾邮件与正常邮件的区别</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spam &lt;- subset(sms_raw_train, type == <span class="string">"spam"</span>)</span><br><span class="line">ham &lt;- subset(sms_raw_train, type == <span class="string">"ham"</span>)</span><br><span class="line">wordcloud(spam$text, max.words = <span class="number">40</span>, scale = c(<span class="number">3</span>, <span class="number">0.5</span>))</span><br></pre></td></tr></table></figure>
<p><img src="/img/rmachine/rmachine-10-91.png" alt=""> </p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wordcloud(ham$text, max.words = <span class="number">40</span>, scale = c(<span class="number">3</span>, <span class="number">0.5</span>))</span><br></pre></td></tr></table></figure>
<p><img src="/img/rmachine/rmachine-10-92.png" alt=""> </p>
<p>很显然可以看出垃圾邮件里面<code>free,now,prize,text claim</code>比较多。</p>
<h2 id="u8BCD_u9891"><a href="#u8BCD_u9891" class="headerlink" title="词频"></a>词频</h2><p>把所有的词都考虑进来显然不是很好的方法，我们的矩阵有7986个特征，因此我们需要考虑缩小范围，于是采用<code>findFreqTerms</code>的方法取大于5的特征（具体取多少根据数据的数据情况）：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findFreqTerms(sms_dtm_train, <span class="number">5</span>)[<span class="number">10</span>:<span class="number">20</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##  [1] &#34;actually&#34;  &#34;add&#34;       &#34;address&#34;   &#34;admirer&#34;   &#34;advance&#34;  &#10;##  [6] &#34;aft&#34;       &#34;afternoon&#34; &#34;age&#34;       &#34;ago&#34;       &#34;ahead&#34;    &#10;## [11] &#34;aight&#34;</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sms_dict &lt;- Dictionary(findFreqTerms(sms_dtm_train, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<p>获得了频数大于5的词后，我们再利用它来生成一个字典，这样可以在文档矩阵中指出，我只取字典中有的词，新的矩阵就只有1252个特征了。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sms_train &lt;- DocumentTermMatrix(sms_corpus_train, list(dictionary = sms_dict))</span><br><span class="line">sms_test &lt;- DocumentTermMatrix(sms_corpus_test, list(dictionary = sms_dict))</span><br></pre></td></tr></table></figure>
<p>我们的目标是想通过短信里面有或者是没有某个词来判断是否是垃圾短信，那么我们很显然应该使用的矩阵是标记某个词在某个短信中出现了还是没有出现。因此写个函数来完成这一个功能：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">convert_counts &lt;- <span class="keyword">function</span>(x) &#123;</span><br><span class="line">    x &lt;- ifelse(x &gt; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    x &lt;- factor(x, levels = c(<span class="number">0</span>, <span class="number">1</span>), labels = c(<span class="string">"No"</span>, <span class="string">"Yes"</span>))</span><br><span class="line">    <span class="keyword">return</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对矩阵每一列进行这样的处理：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sms_train &lt;- apply(sms_train, MARGIN = <span class="number">2</span>, convert_counts)</span><br><span class="line">sms_test &lt;- apply(sms_test, MARGIN = <span class="number">2</span>, convert_counts)</span><br></pre></td></tr></table></figure>
<p>于是我们可以得到最终用来构建模型的数据集。</p>
<h2 id="u6A21_u578B_u8BAD_u7EC3"><a href="#u6A21_u578B_u8BAD_u7EC3" class="headerlink" title="模型训练"></a>模型训练</h2><p>在R里面有多个包都提供朴素贝叶斯分类，比如<code>e1071</code>包，还有<code>klaR</code>包的<code>NaiveBayes()</code>。这里使用<code>e1071</code></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span>(e1071)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Loading required package: e1071&#10;## Loading required package: class</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sms_classifier &lt;- naiveBayes(sms_train, sms_raw_train$type)</span><br></pre></td></tr></table></figure>
<p>于是我们得到了分类器<code>sms_classifier</code></p>
<h2 id="u6A21_u578B_u8BC4_u4F30"><a href="#u6A21_u578B_u8BC4_u4F30" class="headerlink" title="模型评估"></a>模型评估</h2><p>有了模型就可以对测试数据进行预测:</p>
<p>`pred(m,test,type=”class”)</p>
<p>这里的type如果为class代表是分类，如果是raw则代表概率的计算</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sms_test_pred &lt;- predict(sms_classifier, sms_test)</span><br><span class="line"><span class="keyword">require</span>(gmodels)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Loading required package: gmodels</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Warning: package &#39;gmodels&#39; was built under R version 3.0.3</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CrossTable(sms_test_pred, sms_raw_test$type, prop.chisq = <span class="literal">FALSE</span>, prop.t = <span class="literal">FALSE</span>, </span><br><span class="line">    dnn = c(<span class="string">"predicted"</span>, <span class="string">"actual"</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## &#10;##  &#10;##    Cell Contents&#10;## |-------------------------|&#10;## |                       N |&#10;## |           N / Row Total |&#10;## |           N / Col Total |&#10;## |-------------------------|&#10;## &#10;##  &#10;## Total Observations in Table:  1392 &#10;## &#10;##  &#10;##              | actual &#10;##    predicted |       ham |      spam | Row Total | &#10;## -------------|-----------|-----------|-----------|&#10;##          ham |      1202 |        29 |      1231 | &#10;##              |     0.976 |     0.024 |     0.884 | &#10;##              |     0.997 |     0.156 |           | &#10;## -------------|-----------|-----------|-----------|&#10;##         spam |         4 |       157 |       161 | &#10;##              |     0.025 |     0.975 |     0.116 | &#10;##              |     0.003 |     0.844 |           | &#10;## -------------|-----------|-----------|-----------|&#10;## Column Total |      1206 |       186 |      1392 | &#10;##              |     0.866 |     0.134 |           | &#10;## -------------|-----------|-----------|-----------|&#10;## &#10;##</span><br></pre></td></tr></table></figure>
<p>我们可以看出简单的贝叶斯模型的效果却很好，97.6%的正确率，186封垃圾邮件中29封误判为了正常邮件。而1206封正常邮件中4封误判为垃圾邮件。把正常邮件误判为垃圾邮件的影响显然更大，这是需要考虑的地方。</p>
<h2 id="u6A21_u578B_u6539_u8FDB"><a href="#u6A21_u578B_u6539_u8FDB" class="headerlink" title="模型改进"></a>模型改进</h2><p>前面说过了拉普拉斯估计的问题，那么如果我们假设拉普拉斯估计会怎么样呢？</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sms_classifier2 &lt;- naiveBayes(sms_train, sms_raw_train$type, laplace = <span class="number">1</span>)</span><br><span class="line">sms_test_pred2 &lt;- predict(sms_classifier2, sms_test)</span><br><span class="line">CrossTable(sms_test_pred2, sms_raw_test$type, prop.chisq = <span class="literal">FALSE</span>, prop.t = <span class="literal">FALSE</span>, </span><br><span class="line">    prop.r = <span class="literal">FALSE</span>, dnn = c(<span class="string">"predicted"</span>, <span class="string">"actual"</span>))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## &#10;##  &#10;##    Cell Contents&#10;## |-------------------------|&#10;## |                       N |&#10;## |           N / Col Total |&#10;## |-------------------------|&#10;## &#10;##  &#10;## Total Observations in Table:  1392 &#10;## &#10;##  &#10;##              | actual &#10;##    predicted |       ham |      spam | Row Total | &#10;## -------------|-----------|-----------|-----------|&#10;##          ham |      1204 |        30 |      1234 | &#10;##              |     0.998 |     0.161 |           | &#10;## -------------|-----------|-----------|-----------|&#10;##         spam |         2 |       156 |       158 | &#10;##              |     0.002 |     0.839 |           | &#10;## -------------|-----------|-----------|-----------|&#10;## Column Total |      1206 |       186 |      1392 | &#10;##              |     0.866 |     0.134 |           | &#10;## -------------|-----------|-----------|-----------|&#10;## &#10;##</span><br></pre></td></tr></table></figure>
<p>加了拉普拉斯估计后，正常邮件误判为垃圾邮件减少了2封，而垃圾邮件误判为正常邮件的增加了1封。似乎新的模型要好些。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/数据科学/">数据科学</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/R/">R</a><a href="/tags/数据科学/">数据科学</a><a href="/tags/机器学习/">机器学习</a><a href="/tags/机器学习与R/">机器学习与R</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/08/22/2014-8-22-naive-bayes/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/08/22/2014-8-22-naive-bayes/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/08/22/2014-8-22-kNN-2/" title="机器学习与R(9)-k nearest neighbors-2" itemprop="url">机器学习与R(9)-k nearest neighbors-2</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="中继点" target="_blank" itemprop="author">中继点</a>
		
  <p class="article-time">
    <time datetime="2014-08-22T11:46:35.000Z" itemprop="datePublished"> 發表於 2014 Aug 22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>利用kNN算法来诊断乳腺癌</p>
<h2 id="u80CC_u666F"><a href="#u80CC_u666F" class="headerlink" title="背景"></a>背景</h2><p>乳腺癌的早期检测来源对乳腺异常包块的检测。如果存在包块，那么会继续乳腺穿刺取样，之后利用显微镜下的分析来判断是良性还是恶性。如果我们可以用机器学习来完成癌症细胞的自动识别则我们可以为健康系统带来大大好处，比如检测效率的提升。同时自动的筛选系统可以大大减少人工的主观性。</p>
<h2 id="u6570_u636E_u51C6_u5907"><a href="#u6570_u636E_u51C6_u5907" class="headerlink" title="数据准备"></a>数据准备</h2><p>这里我们使用Breast Cancer Wisconsin Diagnostic数据集，你可以从<a href="http://mlr.cs.umass.edu/ml/machine-learning-databases/breast-cancer-wisconsin/wdbc.data" target="_blank" rel="external">这里</a>下载它，数据说明<a href="http://mlr.cs.umass.edu/ml/machine-learning-databases/breast-cancer-wisconsin/wdbc.names" target="_blank" rel="external">点击这里</a>。</p>
<p>数据包含了569个样本，32个特征的数据，其中关键特征为:</p>
<ul>
<li>Radius</li>
<li>Texture</li>
<li>Perimeter</li>
<li>Area</li>
<li>Smoothness</li>
<li>Compactness</li>
<li>Concavity</li>
<li>Concave points</li>
<li>Symmetry</li>
<li>Fractal dimension</li>
</ul>
<p>数据分别度量了这些特征的均值，标准差，以及最大值，在数据集中依次为3～12，13～22，23～32列。第1列为id，第2列为诊断结果，<code>B</code>为良性，<code>M</code>为恶性。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wdbc = read.csv(<span class="string">"wdbc.data"</span>, header = <span class="literal">F</span>)</span><br><span class="line">wdbc.names = c(<span class="string">"Radius"</span>, <span class="string">"Texture"</span>, <span class="string">"Perimeter"</span>, <span class="string">"Area"</span>, <span class="string">"Smoothness"</span>, <span class="string">"Compactness"</span>, </span><br><span class="line">    <span class="string">"Concavity"</span>, <span class="string">"Concave points"</span>, <span class="string">"Symmetry"</span>, <span class="string">"Fractal dimension"</span>)</span><br><span class="line">wdbc.names = c(wdbc.names, paste(wdbc.names, <span class="string">"_mean"</span>, sep = <span class="string">""</span>), paste(wdbc.names, </span><br><span class="line">    <span class="string">"_worst"</span>, sep = <span class="string">""</span>))</span><br><span class="line">names(wdbc) = c(<span class="string">"id"</span>, <span class="string">"diagnosis"</span>, wdbc.names)</span><br></pre></td></tr></table></figure>
<p>最终的数据为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str(wdbc)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## &#39;data.frame&#39;:&#9;569 obs. of  32 variables:&#10;##  $ id                     : int  842302 842517 84300903 84348301 84358402 843786 844359 84458202 844981 84501001 ...&#10;##  $ diagnosis              : Factor w/ 2 levels &#34;B&#34;,&#34;M&#34;: 2 2 2 2 2 2 2 2 2 2 ...&#10;##  $ Radius                 : num  18 20.6 19.7 11.4 20.3 ...&#10;##  $ Texture                : num  10.4 17.8 21.2 20.4 14.3 ...&#10;##  $ Perimeter              : num  122.8 132.9 130 77.6 135.1 ...&#10;##  $ Area                   : num  1001 1326 1203 386 1297 ...&#10;##  $ Smoothness             : num  0.1184 0.0847 0.1096 0.1425 0.1003 ...&#10;##  $ Compactness            : num  0.2776 0.0786 0.1599 0.2839 0.1328 ...&#10;##  $ Concavity              : num  0.3001 0.0869 0.1974 0.2414 0.198 ...&#10;##  $ Concave points         : num  0.1471 0.0702 0.1279 0.1052 0.1043 ...&#10;##  $ Symmetry               : num  0.242 0.181 0.207 0.26 0.181 ...&#10;##  $ Fractal dimension      : num  0.0787 0.0567 0.06 0.0974 0.0588 ...&#10;##  $ Radius_mean            : num  1.095 0.543 0.746 0.496 0.757 ...&#10;##  $ Texture_mean           : num  0.905 0.734 0.787 1.156 0.781 ...&#10;##  $ Perimeter_mean         : num  8.59 3.4 4.58 3.44 5.44 ...&#10;##  $ Area_mean              : num  153.4 74.1 94 27.2 94.4 ...&#10;##  $ Smoothness_mean        : num  0.0064 0.00522 0.00615 0.00911 0.01149 ...&#10;##  $ Compactness_mean       : num  0.049 0.0131 0.0401 0.0746 0.0246 ...&#10;##  $ Concavity_mean         : num  0.0537 0.0186 0.0383 0.0566 0.0569 ...&#10;##  $ Concave points_mean    : num  0.0159 0.0134 0.0206 0.0187 0.0188 ...&#10;##  $ Symmetry_mean          : num  0.03 0.0139 0.0225 0.0596 0.0176 ...&#10;##  $ Fractal dimension_mean : num  0.00619 0.00353 0.00457 0.00921 0.00511 ...&#10;##  $ Radius_worst           : num  25.4 25 23.6 14.9 22.5 ...&#10;##  $ Texture_worst          : num  17.3 23.4 25.5 26.5 16.7 ...&#10;##  $ Perimeter_worst        : num  184.6 158.8 152.5 98.9 152.2 ...&#10;##  $ Area_worst             : num  2019 1956 1709 568 1575 ...&#10;##  $ Smoothness_worst       : num  0.162 0.124 0.144 0.21 0.137 ...&#10;##  $ Compactness_worst      : num  0.666 0.187 0.424 0.866 0.205 ...&#10;##  $ Concavity_worst        : num  0.712 0.242 0.45 0.687 0.4 ...&#10;##  $ Concave points_worst   : num  0.265 0.186 0.243 0.258 0.163 ...&#10;##  $ Symmetry_worst         : num  0.46 0.275 0.361 0.664 0.236 ...&#10;##  $ Fractal dimension_worst: num  0.1189 0.089 0.0876 0.173 0.0768 ...</span><br></pre></td></tr></table></figure>
<p>从这里我们知道数据集中357个样本为良性，212个为恶性肿瘤</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table(wdbc$diagnosis)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## &#10;##   B   M &#10;## 357 212</span><br></pre></td></tr></table></figure>
<p>这里我们再修改一下数据,同时去掉id，因为id对预测没有意义：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wdbc$diagnosis = factor(wdbc$diagnosis, levels = c(<span class="string">"B"</span>, <span class="string">"M"</span>), labels = c(<span class="string">"Benign"</span>, </span><br><span class="line">    <span class="string">"Malignant"</span>))</span><br><span class="line">round(prop.table(table(wdbc$diagnosis)) * <span class="number">100</span>, digits = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## &#10;##    Benign Malignant &#10;##      62.7      37.3</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wdbc = wdbc[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>通过<code>summary</code>，我们很明显看出不同的特征的度量值差别太大：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">summary(wdbc[c(<span class="string">"Radius_mean"</span>, <span class="string">"Area_mean"</span>, <span class="string">"Smoothness_mean"</span>)])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##   Radius_mean      Area_mean     Smoothness_mean  &#10;##  Min.   :0.112   Min.   :  6.8   Min.   :0.00171  &#10;##  1st Qu.:0.232   1st Qu.: 17.9   1st Qu.:0.00517  &#10;##  Median :0.324   Median : 24.5   Median :0.00638  &#10;##  Mean   :0.405   Mean   : 40.3   Mean   :0.00704  &#10;##  3rd Qu.:0.479   3rd Qu.: 45.2   3rd Qu.:0.00815  &#10;##  Max.   :2.873   Max.   :542.2   Max.   :0.03113</span><br></pre></td></tr></table></figure>
<h2 id="u6570_u636E_u8F6C_u6362"><a href="#u6570_u636E_u8F6C_u6362" class="headerlink" title="数据转换"></a>数据转换</h2><p>显然数据需要转换,我们定义转换函数为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">normalize &lt;- <span class="keyword">function</span>(x) &#123;</span><br><span class="line">    <span class="keyword">return</span>((x - min(x))/(max(x) - min(x)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来对数据进行转换后，执行<code>summary</code>可以看出特征的区间分布已经统一了：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wdbc_n &lt;- as.data.frame(lapply(wdbc[<span class="number">2</span>:<span class="number">31</span>], normalize))</span><br><span class="line">summary(wdbc_n[c(<span class="string">"Radius_mean"</span>, <span class="string">"Area_mean"</span>, <span class="string">"Smoothness_mean"</span>)])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##   Radius_mean       Area_mean      Smoothness_mean&#10;##  Min.   :0.0000   Min.   :0.0000   Min.   :0.000  &#10;##  1st Qu.:0.0438   1st Qu.:0.0206   1st Qu.:0.117  &#10;##  Median :0.0770   Median :0.0331   Median :0.159  &#10;##  Mean   :0.1063   Mean   :0.0626   Mean   :0.181  &#10;##  3rd Qu.:0.1330   3rd Qu.:0.0717   3rd Qu.:0.219  &#10;##  Max.   :1.0000   Max.   :1.0000   Max.   :1.000</span><br></pre></td></tr></table></figure>
<p>接下来我们需要构造训练数据与测试数据，实际通常的做法是training,validation,test三个数据集，validataion用来校正提高模型准确性。这里简单起见我们只用train和test数据集，最简单的方法是如下：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wdbc_train = wdbc_n[<span class="number">1</span>:<span class="number">469</span>, ]</span><br><span class="line">wdbc_test = wdbc_n[<span class="number">470</span>:<span class="number">569</span>, ]</span><br><span class="line">wdbc_train_label = wdbc[<span class="number">1</span>:<span class="number">469</span>, <span class="number">1</span>]</span><br><span class="line">wdbc_test_label = wdbc[<span class="number">470</span>:<span class="number">569</span>, <span class="number">1</span>]</span><br><span class="line">mal_rate = table(wdbc_train_label)</span><br><span class="line">round(mal_rate[<span class="number">2</span>]/sum(mal_rate), digits = <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Malignant &#10;##       0.4</span><br></pre></td></tr></table></figure>
<p>这个方法虽然简单，但需要注意这里我们不是随机采样，如果样本中的恶性肿瘤大部分布在1：469显然就有很大问题。当然另一种方法就是用<code>sample</code>函数，例如：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set.seed(<span class="number">2014</span>)</span><br><span class="line">inTrain = sample(<span class="number">1</span>:dim(wdbc_n)[<span class="number">1</span>], <span class="number">469</span>, replace = <span class="literal">F</span>)</span><br><span class="line">wdbc_train = wdbc_n[inTrain, ]</span><br><span class="line">wdbc_test = wdbc_n[-inTrain, ]</span><br><span class="line">wdbc_train_label = wdbc[inTrain, <span class="number">1</span>]</span><br><span class="line">wdbc_test_label = wdbc[-inTrain, <span class="number">1</span>]</span><br><span class="line">mal_rate = table(wdbc_train_label)</span><br><span class="line">round(mal_rate[<span class="number">2</span>]/sum(mal_rate), digits = <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Malignant &#10;##      0.37</span><br></pre></td></tr></table></figure>
<p>除此之外，个人常用<code>caret</code>包的<code>createDataPartition</code>来完成这一工作：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span>(caret)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Loading required package: caret</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Warning: package &#39;caret&#39; was built under R version 3.0.3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Loading required package: lattice&#10;## Loading required package: ggplot2</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set.seed(<span class="number">2014</span>)</span><br><span class="line">inTrain = createDataPartition(y = wdbc$diagnosis, p = <span class="number">0.8</span>, list = <span class="literal">FALSE</span>)</span><br><span class="line">wdbc_train = wdbc_n[inTrain, ]</span><br><span class="line">wdbc_test = wdbc_n[-inTrain, ]</span><br><span class="line">wdbc_train_label = wdbc[inTrain, <span class="number">1</span>]</span><br><span class="line">wdbc_test_label = wdbc[-inTrain, <span class="number">1</span>]</span><br><span class="line">mal_rate = table(wdbc_train_label)</span><br><span class="line">round(mal_rate[<span class="number">2</span>]/sum(mal_rate), digits = <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Malignant &#10;##      0.37</span><br></pre></td></tr></table></figure>
<h2 id="u6784_u5EFA_u6A21_u578B"><a href="#u6784_u5EFA_u6A21_u578B" class="headerlink" title="构建模型"></a>构建模型</h2><p>这里kNN实现，我们采用<code>class</code>包的实现，当然其他实现你可以参考CRAN。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span>(class)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Loading required package: class</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wdbc_test_pred &lt;- knn(train = wdbc_train, test = wdbc_test, cl = wdbc_train_label, </span><br><span class="line">    k = <span class="number">21</span>)</span><br></pre></td></tr></table></figure>
<p>这里k=21，基于是采用<code>length(wdbc_train_label)</code>的平方根。<code>knn</code>的使用说明如下：</p>
<ul>
<li>train: 训练数据</li>
<li>test: 测试数据</li>
<li>cl: factor,训练数据的对应分类</li>
</ul>
<h2 id="u6A21_u578B_u8BC4_u4F30"><a href="#u6A21_u578B_u8BC4_u4F30" class="headerlink" title="模型评估"></a>模型评估</h2><p>这里采用<code>gmodels</code>的<code>CrossTable</code>函数</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span>(gmodels)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Loading required package: gmodels</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Warning: package &#39;gmodels&#39; was built under R version 3.0.3</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CrossTable(x = wdbc_test_label, y = wdbc_test_pred, prop.chisq = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## &#10;##  &#10;##    Cell Contents&#10;## |-------------------------|&#10;## |                       N |&#10;## |           N / Row Total |&#10;## |           N / Col Total |&#10;## |         N / Table Total |&#10;## |-------------------------|&#10;## &#10;##  &#10;## Total Observations in Table:  113 &#10;## &#10;##  &#10;##                 | wdbc_test_pred &#10;## wdbc_test_label |    Benign | Malignant | Row Total | &#10;## ----------------|-----------|-----------|-----------|&#10;##          Benign |        71 |         0 |        71 | &#10;##                 |     1.000 |     0.000 |     0.628 | &#10;##                 |     0.959 |     0.000 |           | &#10;##                 |     0.628 |     0.000 |           | &#10;## ----------------|-----------|-----------|-----------|&#10;##       Malignant |         3 |        39 |        42 | &#10;##                 |     0.071 |     0.929 |     0.372 | &#10;##                 |     0.041 |     1.000 |           | &#10;##                 |     0.027 |     0.345 |           | &#10;## ----------------|-----------|-----------|-----------|&#10;##    Column Total |        74 |        39 |       113 | &#10;##                 |     0.655 |     0.345 |           | &#10;## ----------------|-----------|-----------|-----------|&#10;## &#10;##</span><br></pre></td></tr></table></figure>
<p>分别得到TN = 71,TP = 39, FN=1,FP=0。因此：</p>
<p>accuracy = (TN+TP)/100=97.345%<br>sensitivity=TP/(TP+FN)= 92.86%<br>Specificity=TN/(TN+FP)= 100%  </p>
<p>详细解释可以看wikipedia <a href="http://en.wikipedia.org/wiki/Sensitivity_and_specificity" target="_blank" rel="external">Sensitivity and specificity</a>。简单说sensitivity是检查正确识别恶性肿瘤的比例，Specificity检查正确排除恶性肿瘤的比例。</p>
<h2 id="u6A21_u578B_u6539_u8FDB"><a href="#u6A21_u578B_u6539_u8FDB" class="headerlink" title="模型改进"></a>模型改进</h2><p>前面我们采用的是最大最小标准化，还可以用z-score来实验一次。最大最小值标准化强制把数据压缩在了0～1之间，也许减小了极值的影响，不过可能极值正好是恶性的标志呢？以下采用z-score重复前面的步骤：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wdbc_z = as.data.frame(scale(wdbc[-<span class="number">1</span>]))</span><br><span class="line">summary(wdbc_z$Area_mean)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. &#10;##  -0.737  -0.494  -0.347   0.000   0.107  11.000</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set.seed(<span class="number">2014</span>)</span><br><span class="line">inTrain = createDataPartition(y = wdbc$diagnosis, p = <span class="number">0.8</span>, list = <span class="literal">FALSE</span>)</span><br><span class="line">wdbc_train = wdbc_z[inTrain, ]</span><br><span class="line">wdbc_test = wdbc_z[-inTrain, ]</span><br><span class="line">wdbc_train_label = wdbc[inTrain, <span class="number">1</span>]</span><br><span class="line">wdbc_test_label = wdbc[-inTrain, <span class="number">1</span>]</span><br><span class="line">wdbc_test_pred = knn(train = wdbc_train, test = wdbc_test, cl = wdbc_train_label, </span><br><span class="line">    k = <span class="number">21</span>)</span><br><span class="line">CrossTable(x = wdbc_test_label, y = wdbc_test_pred, prop.chisq = <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## &#10;##  &#10;##    Cell Contents&#10;## |-------------------------|&#10;## |                       N |&#10;## |           N / Row Total |&#10;## |           N / Col Total |&#10;## |         N / Table Total |&#10;## |-------------------------|&#10;## &#10;##  &#10;## Total Observations in Table:  113 &#10;## &#10;##  &#10;##                 | wdbc_test_pred &#10;## wdbc_test_label |    Benign | Malignant | Row Total | &#10;## ----------------|-----------|-----------|-----------|&#10;##          Benign |        71 |         0 |        71 | &#10;##                 |     1.000 |     0.000 |     0.628 | &#10;##                 |     0.947 |     0.000 |           | &#10;##                 |     0.628 |     0.000 |           | &#10;## ----------------|-----------|-----------|-----------|&#10;##       Malignant |         4 |        38 |        42 | &#10;##                 |     0.095 |     0.905 |     0.372 | &#10;##                 |     0.053 |     1.000 |           | &#10;##                 |     0.035 |     0.336 |           | &#10;## ----------------|-----------|-----------|-----------|&#10;##    Column Total |        75 |        38 |       113 | &#10;##                 |     0.664 |     0.336 |           | &#10;## ----------------|-----------|-----------|-----------|&#10;## &#10;##</span><br></pre></td></tr></table></figure>
<p>我们发现z-score的效果比之前的差:</p>
<p>accuracy = (TN+TP)/113=96.46%<br>sensitivity=TP/(TP+FN)= 90.47%<br>Specificity=TN/(TN+FP)= 100%  </p>
<p>此外我们还可以调整k，这里就不重复了。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/数据科学/">数据科学</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/R/">R</a><a href="/tags/数据科学/">数据科学</a><a href="/tags/机器学习/">机器学习</a><a href="/tags/机器学习与R/">机器学习与R</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/08/22/2014-8-22-kNN-2/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/08/22/2014-8-22-kNN-2/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/08/22/2014-8-22-kNN-1/" title="机器学习与R(8)-k nearest neighbors-1" itemprop="url">机器学习与R(8)-k nearest neighbors-1</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="中继点" target="_blank" itemprop="author">中继点</a>
		
  <p class="article-time">
    <time datetime="2014-08-22T11:46:35.000Z" itemprop="datePublished"> 發表於 2014 Aug 22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>今天我们介绍最简单但是却很实用的kNN分类算法的R实现。</p>
<h2 id="kNN_u7B80_u4ECB"><a href="#kNN_u7B80_u4ECB" class="headerlink" title="kNN简介"></a>kNN简介</h2><p>基于Nearest Neighbors的分类可以用于：</p>
<ul>
<li>比如文字识别，面部识别</li>
<li>预测某人是否喜欢推荐的电影（Netflix）</li>
<li>基因模式识别，比如用于检测某种疾病</li>
</ul>
<p>通常最近邻居分类器适用于特征与目标类之间的关系为比较复杂的数字类型，或者说二者关系难以理解，但是相似类间特征总是相似。kNN算法：</p>
<ul>
<li>简单有效，对数据分布没有假设，数据训练也很快</li>
<li>但是它没有模型输出，因此限制了对特征间关系的理解</li>
<li>分类阶段也比较慢，耗费内存</li>
<li>对nominal特征以及缺少数据需要预先处理</li>
</ul>
<h2 id="u7B97_u6CD5"><a href="#u7B97_u6CD5" class="headerlink" title="算法"></a>算法</h2><p>kNN分类的思想很简单就是<strong>物以类聚，人以群分</strong>，根据与待分类数据集中的最近的k个训练集中的分类标签来对决定其类别。比如说我们已经知道如下数据：</p>
<table>
<thead>
<tr>
<th style="text-align:right">食物</th>
<th style="text-align:right">甜度</th>
<th style="text-align:right">脆度</th>
<th style="text-align:right">食物类别</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">apple</td>
<td style="text-align:right">10</td>
<td style="text-align:right">9</td>
<td style="text-align:right">水果</td>
</tr>
<tr>
<td style="text-align:right">bacon</td>
<td style="text-align:right">1</td>
<td style="text-align:right">4</td>
<td style="text-align:right">蛋白质</td>
</tr>
<tr>
<td style="text-align:right">banana</td>
<td style="text-align:right">10</td>
<td style="text-align:right">1</td>
<td style="text-align:right">水果</td>
</tr>
<tr>
<td style="text-align:right">carrot</td>
<td style="text-align:right">7</td>
<td style="text-align:right">10</td>
<td style="text-align:right">蔬菜</td>
</tr>
<tr>
<td style="text-align:right">celery</td>
<td style="text-align:right">3</td>
<td style="text-align:right">10</td>
<td style="text-align:right">蔬菜</td>
</tr>
<tr>
<td style="text-align:right">cheese</td>
<td style="text-align:right">1</td>
<td style="text-align:right">1</td>
<td style="text-align:right">蛋白质</td>
</tr>
</tbody>
</table>
<p>kNN算法会所有特征作为多维空间的坐标，通过计算这些点之间的距离来计算每一个样本间的相似性。</p>
<p><img src="/img/rmachine/knn-algorim.png" alt="kNN算法"></p>
<p>显然从这里我们可以看出组内数据间的相似性。此时如果我有一个西红柿需要分类，那么根据它的k个最近邻居我们就可以做出判断，k=1时分类与最近那个相同，k=3那么就是投票决定。</p>
<p><img src="/img/rmachine/knn-tomato.png" alt="kNN算法"></p>
<p>前面讲到了距离那么必然涉及距离如何计算的。常用的有欧几里德距离：</p>
<p>$$ dist(p,q)=\sqrt{(p_1-q_1)^2+(p_2-q_2)^2+(p_3-q_3)^2+…} $$</p>
<p>因此我们可以计算：</p>
<table>
<thead>
<tr>
<th style="text-align:right">食物</th>
<th style="text-align:right">甜度</th>
<th style="text-align:right">脆度</th>
<th style="text-align:right">食物类别</th>
<th style="text-align:right">与tomato的距离</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">grape</td>
<td style="text-align:right">8</td>
<td style="text-align:right">5</td>
<td style="text-align:right">水果</td>
<td style="text-align:right">sqrt((6 - 8)^2 + (4 - 5)^2) = 2.2</td>
</tr>
<tr>
<td style="text-align:right">green bean</td>
<td style="text-align:right">3</td>
<td style="text-align:right">7</td>
<td style="text-align:right">蔬菜</td>
<td style="text-align:right">sqrt((6 - 3)^2 + (4 - 7)^2) = 4.2</td>
</tr>
<tr>
<td style="text-align:right">nuts</td>
<td style="text-align:right">3</td>
<td style="text-align:right">6</td>
<td style="text-align:right">蛋白质</td>
<td style="text-align:right">sqrt((6 - 3)^2 + (4 - 6)^2) = 3.6</td>
</tr>
<tr>
<td style="text-align:right">orange</td>
<td style="text-align:right">7</td>
<td style="text-align:right">3</td>
<td style="text-align:right">水果</td>
<td style="text-align:right">sqrt((6 - 7)^2 + (4 - 3)^2) = 1.4</td>
</tr>
</tbody>
</table>
<p>如果k=1，那么西红柿与orange最近，就应该是水果，如果k=3，就是投票，橘子和葡萄都说它是水果，那它就是水果了。</p>
<h2 id="k_u7684_u9009_u62E9"><a href="#k_u7684_u9009_u62E9" class="headerlink" title="k的选择"></a>k的选择</h2><p>很明显k的选择对最终结果大有影响，这就是机器学习中几点的bias与variance取舍问题，鱼和熊掌不可兼得。如果k很大，那么可以减少干扰数据的影响，但是此时就导致了系统性偏差，比如如果去k为总的训练数据数，那么每次投票肯定都是训练数据中多的类别胜利。显然训练数据的系统性偏差会影响结果。而如果k=1，那么某个干扰数据或者异常数据会影响最终结果的准确性，所以我们始终是在bias与variance直接取舍。</p>
<p><img src="/img/rmachine/knn-bias-variance.png" alt="bias vs variance"></p>
<p>k通常会在3～10直接取值，或者是k等于训练数据的平方根。比如15个数据，可能会取k=4</p>
<blockquote>
<p>另一个不常用的是k取较大值，但是我们在投票时权重不同</p>
</blockquote>
<h2 id="u6570_u636E_u7684_u9884_u5904_u7406"><a href="#u6570_u636E_u7684_u9884_u5904_u7406" class="headerlink" title="数据的预处理"></a>数据的预处理</h2><p>有了计算距离的方法，也有了k的取值，是否我们就可以开始分类了？不要急，还有重要的一步就是，数据的预处理。简单考虑一下，比如我们度量各个特征的时候刻度单位不同，那么会带来什么问题。特征A取值是从0～1，另一个特征B则是0～10000，这里特征B的1000，不代表是特征A 的1的1000倍，因此我们要对数据进行标准化。传统的是采用最小最大值标准化方法：</p>
<p>$$ X_new=\frac{X-min(X)}{max(X)-min(X)} $$</p>
<p>这样$X_new$的取值就在0～1之间了。另一种方法则是z-score:</p>
<p>$$ X_new=\frac{X-\mu}{\sigma}=\frac{x-mean(x)}{sd(x)} $$</p>
<p>数据已经标准化了是否就ok了？不是的，欧几里德距离只能用于数字，对于nominal变量（就是分类变量啦），无法处理。这个时候我们可以通过dummy（哑元）来处理。比如：</p>
<ul>
<li>性别为male就取1</li>
<li>其它取0</li>
</ul>
<p>那如果不止2类，是多个呢？一种方法就是我创建（n-1)个哑元变量，还有一种就是如果你的分类变量是有顺序的，而且每一级间的间隔是固定的那你可以用比如1，2，3来代表冷，温暖，热。不过这时一定要注意这个间隔的问题，比如穷人，中产，富人，显然中产和穷人，富人和中产的差距就不是一样的。</p>
<h2 id="u61D2_u60F0_u7684kNN"><a href="#u61D2_u60F0_u7684kNN" class="headerlink" title="懒惰的kNN"></a>懒惰的kNN</h2><p>前面我们在什么是机器学习时说过机器学习有一个抽象的过程，而kNN实际没有抽象与泛化（generalization）的过程。kNN因此是懒惰的学习或者叫instance-based learning / rote learning。</p>
<p>kNN也是非参数化的，而后面我们要说的回归则是参数化的。尽管kNN分类器很懒惰，但是却很有用，后面我们用UCI的机器学习数据来看R里面的实现。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/数据科学/">数据科学</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/R/">R</a><a href="/tags/数据科学/">数据科学</a><a href="/tags/机器学习/">机器学习</a><a href="/tags/机器学习与R/">机器学习与R</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/08/22/2014-8-22-kNN-1/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/08/22/2014-8-22-kNN-1/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2014/08/22/2014-8-22-exploring-data-2/" title="机器学习与R(7)-数据探索-2" itemprop="url">机器学习与R(7)-数据探索-2</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="中继点" target="_blank" itemprop="author">中继点</a>
		
  <p class="article-time">
    <time datetime="2014-08-22T11:31:01.000Z" itemprop="datePublished"> 發表於 2014 Aug 22</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="u76D2_u5B50_u56FE"><a href="#u76D2_u5B50_u56FE" class="headerlink" title="盒子图"></a>盒子图</h2><p>boxplot是用图形表示Q1,Q3,median,min,max的方法</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boxplot(contribution$Class.Year,main=<span class="string">"Boxplot for Class Year"</span>,ylab=<span class="string">"Class Year"</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/rmachine/rmachine-7-21.png" alt=""> </p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boxplot(contribution$FY00Giving,main=<span class="string">"Boxplot for donation in FY00"</span>,ylab=<span class="string">"donation $"</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/rmachine/rmachine-7-22.png" alt=""> </p>
<p>通过图形，很容易我们可以看出给学校捐款的学生大多是85年前毕业的，而大部分人没有捐款，少数人在贡献。</p>
<h2 id="u76F4_u65B9_u56FE"><a href="#u76F4_u65B9_u56FE" class="headerlink" title="直方图"></a>直方图</h2><p>histogram是另一种描述数据分布的方式</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hist(contribution$Class.Year)</span><br></pre></td></tr></table></figure>
<p><img src="/img/rmachine/rmachine-7-31.png" alt=""> </p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hist(contribution$FY00Giving)</span><br></pre></td></tr></table></figure>
<p><img src="/img/rmachine/rmachine-7-32.png" alt=""> </p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hist(subset(contribution,FY00Giving&gt;<span class="number">0</span>&amp;FY00Giving&lt;<span class="number">500</span>)$FY00Giving)</span><br></pre></td></tr></table></figure>
<p><img src="/img/rmachine/rmachine-7-33.png" alt=""> </p>
<p>从<code>Class.Year</code>我们看出数据集中1997毕业的最多，而FY00Giving大部分为0，进一步还看出大部分人捐款都在100以下。同时我们还了解到了数据的偏度(skew)。</p>
<p>偏度：偏度（Skewness）是描述某变量取值分布对称性的统计量。<a href="http://www.r-tutor.com/elementary-statistics/numerical-measures/skewness" target="_blank" rel="external">http://www.r-tutor.com/elementary-statistics/numerical-measures/skewness</a></p>
<ul>
<li>Skewness=0 分布形态与正态分布偏度相同</li>
<li>Skewness&gt;0 正偏差数值较大，为正偏或右偏。长尾巴拖在右边。</li>
<li>Skewness&lt;0 负偏差数值较大，为负偏或左偏。长尾巴拖在左边。 </li>
</ul>
<p>利用来自<code>e1071</code>包的函数<code>skewness</code>我们可以验证到Class.Year分布是左偏的，FY00Giving是严重右偏的。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span>(e1071)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Loading required package: e1071</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skewness(contribution$Class.Year)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] -0.3364</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skewness(contribution$FY00Giving)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 13.38</span><br></pre></td></tr></table></figure>
<h2 id="u6807_u51C6_u5DEE_u4E0E_u65B9_u5DEE"><a href="#u6807_u51C6_u5DEE_u4E0E_u65B9_u5DEE" class="headerlink" title="标准差与方差"></a>标准差与方差</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sd(contribution$FY00Giving)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] 1171</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var(sd(contribution$FY00Giving))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## [1] NA</span><br></pre></td></tr></table></figure>
<p>标准差是描述数据离mean的距离。对正态分布68%的数据在1个标准差内，95%的在2个标准差内，99.7在3个标准差内，这就是我们常说的$/sigma$</p>
<h2 id="u5206_u7C7B_uFF08categorical_uFF09__u53D8_u91CF"><a href="#u5206_u7C7B_uFF08categorical_uFF09__u53D8_u91CF" class="headerlink" title="分类（categorical） 变量"></a>分类（categorical） 变量</h2><p>此时我们可以通过频数表来统计</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table(contribution$Major)&#10;major_table=table(contribution$Major)&#10;prop.table(major_table)&#10;round(prop.table(major_table)*100)</span><br></pre></td></tr></table></figure>
<p><code>table</code>统计频数，<code>prop.table</code>则可以计算比例。</p>
<h2 id="CrossTable"><a href="#CrossTable" class="headerlink" title="CrossTable"></a>CrossTable</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span>(gmodels)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Loading required package: gmodels</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## Warning: there is no package called &#39;gmodels&#39;</span><br></pre></td></tr></table></figure>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?CrossTable</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## No documentation for &#39;CrossTable&#39; in specified packages and libraries:&#10;## you could try &#39;??CrossTable&#39;</span><br></pre></td></tr></table></figure>
<p><code>gmodels</code>包的<code>CrossTable</code>函数提供了更丰富的功能，可以通过<code>?CrossTable</code>查看</p>
<h2 id="u6563_u70B9_u56FE"><a href="#u6563_u70B9_u56FE" class="headerlink" title="散点图"></a>散点图</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data(trees)</span><br><span class="line">plot(trees$Height,trees$Volume)</span><br></pre></td></tr></table></figure>
<p><img src="/img/rmachine/rmachine-7-7.png" alt=""> </p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/数据科学/">数据科学</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/R/">R</a><a href="/tags/数据科学/">数据科学</a><a href="/tags/机器学习/">机器学习</a><a href="/tags/机器学习与R/">机器学习与R</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2014/08/22/2014-8-22-exploring-data-2/#comments" class="ds-thread-count comments-count-link" data-thread-key="2014/08/22/2014-8-22-exploring-data-2/" data-count-type="comments">&nbsp;</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/"><span></span>Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="顯示側邊欄"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隱藏側邊欄"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分類</p>
		<ul>
		
		  
			<li><a href="/categories/数据科学/" title="数据科学">数据科学<sup>38</sup></a></li>
		  
		
		  
			<li><a href="/categories/杂记/" title="杂记">杂记<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/笔记/" title="笔记">笔记<sup>19</sup></a></li>
		  
		
		  
			<li><a href="/categories/行业观察/" title="行业观察">行业观察<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/软件定价/" title="软件定价">软件定价<sup>12</sup></a></li>
		  
		
		  
			<li><a href="/categories/软件技术/" title="软件技术">软件技术<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">標簽</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/数据科学/" title="数据科学">数据科学<sup>33</sup></a></li>
			
		
			
				<li><a href="/tags/R/" title="R">R<sup>26</sup></a></li>
			
		
			
				<li><a href="/tags/笔记/" title="笔记">笔记<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/经济学/" title="经济学">经济学<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/凯恩斯/" title="凯恩斯">凯恩斯<sup>15</sup></a></li>
			
		
			
				<li><a href="/tags/软件定价/" title="软件定价">软件定价<sup>12</sup></a></li>
			
		
			
				<li><a href="/tags/机器学习/" title="机器学习">机器学习<sup>11</sup></a></li>
			
		
			
				<li><a href="/tags/Introduction-to-data-science/" title="Introduction to data science">Introduction to data science<sup>11</sup></a></li>
			
		
			
				<li><a href="/tags/机器学习与R/" title="机器学习与R">机器学习与R<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/data-science/" title="data science">data science<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/可视化/" title="可视化">可视化<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/企业成长/" title="企业成长">企业成长<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/创业/" title="创业">创业<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/培训/" title="培训">培训<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/R培训/" title="R培训">R培训<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/TED/" title="TED">TED<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/markdown/" title="markdown">markdown<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/数据分析/" title="数据分析">数据分析<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Kaggle/" title="Kaggle">Kaggle<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/软件项目管理/" title="软件项目管理">软件项目管理<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=1543589403&verifier=996dff3a&dpc=1"></iframe>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情鏈接</p>
    <ul>
        
    </ul>
</div>

  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 訂閱</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> life long leaner <br/>
			关注大数据,R,移动互联,研发管理,lean startup,lifelong learning</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/1543589403" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="中继点">中继点</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-37263323-2', 'auto');  
ga('send', 'pageview');
</script>





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回頂部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
